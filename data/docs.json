{
  "version": "1.0.1",
  "resources": {
    "augeas": {
      "name": "AugeasRes",
      "kind": "augeas",
      "file": "augeas.go",
      "description": "AugeasRes is a resource that enables you to use the augeas resource. Currently only allows you to change simple files (e.g sshd_config).",
      "fields": {
        "file": {
          "name": "File",
          "type": "str",
          "description": "File is the path to the file targeted by this resource."
        },
        "lens": {
          "name": "Lens",
          "type": "str",
          "description": "Lens is the lens used by this resource. If specified, mgmt will lower the augeas overhead by only loading that lens."
        },
        "sets": {
          "name": "Sets",
          "type": "[]struct{path str; value str}",
          "description": "Sets is a list of changes that will be applied to the file, in the form of [\"path\", \"value\"]. mgmt will run augeas.Get() before augeas.Set(), to prevent changing the file when it is not needed."
        }
      }
    },
    "aws:ec2": {
      "name": "AwsEc2Res",
      "kind": "aws:ec2",
      "file": "aws_ec2.go",
      "description": "AwsEc2Res is an AWS EC2 resource. In order to create a client session, your AWS credentials must be present in ~/.aws - For detailed instructions see http://docs.aws.amazon.com/cli/latest/userguide/cli-config-files.html",
      "fields": {
        "erroronmalformedpost": {
          "name": "ErrorOnMalformedPost",
          "type": "bool",
          "description": "ErrorOnMalformedPost controls whether or not malformed HTTP post requests, that cause JSON decoder errors, will also make the engine shut down. If ErrorOnMalformedPost set to true and an error occurs, Watch() will return the error and the engine will shut down."
        },
        "imageid": {
          "name": "ImageID",
          "type": "str",
          "description": "ImageID to use, and note that it must be available on the chosen region."
        },
        "region": {
          "name": "Region",
          "type": "str",
          "description": "Region must match one of the AwsRegions. This list is static at the moment."
        },
        "state": {
          "name": "State",
          "type": "str",
          "description": "State must be running, stopped, or terminated."
        },
        "type": {
          "name": "Type",
          "type": "str",
          "description": "Type of ec2 instance, eg: t2.micro for example."
        },
        "userdata": {
          "name": "UserData",
          "type": "str",
          "description": "UserData is used to run bash and cloud-init commands on first launch. See http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html for documentation and examples."
        },
        "watchendpoint": {
          "name": "WatchEndpoint",
          "type": "str",
          "description": "WatchEndpoint is the public url of the sns endpoint, eg: http://server:12345/ for example."
        },
        "watchlistenaddr": {
          "name": "WatchListenAddr",
          "type": "str",
          "description": "WatchListenAddr is the local address or port that the sns listens on, eg: 10.0.0.0:23456 or 23456."
        }
      }
    },
    "bmc:power": {
      "name": "BmcPowerRes",
      "kind": "bmc:power",
      "file": "bmc_power.go",
      "description": "BmcPowerRes is a resource that manages power state of a BMC. This is usually used for turning computers on and off. The name value can be a big URL string in the form: `driver://user:pass@hostname:port` for example you may see: gofishs://ADMIN:hunter2@127.0.0.1:8800 to use the \"https\" variant of the gofish driver.\nNOTE: New drivers should either not end in \"s\" or at least not be identical to the name of another driver an \"s\" is added or removed to the end.",
      "fields": {
        "driver": {
          "name": "Driver",
          "type": "str",
          "description": "Driver to use, such as: \"gofish\" or \"rpc\". This is a different concept than the \"bmclib\" driver vs provider distinction. Here we just statically pick what we're using without any magic. If not specified, we parse this from the Name scheme. If this ends with an extra \"s\" then we use https instead of http."
        },
        "hostname": {
          "name": "Hostname",
          "type": "str",
          "description": "Hostname to connect to. If not specified, we parse this from the Name."
        },
        "insecure_password": {
          "name": "InsecurePassword",
          "type": "bool",
          "description": "InsecurePassword can be set to true to allow a password in the Name."
        },
        "password": {
          "name": "Password",
          "type": "str",
          "description": "Password to use to connect. We do NOT parse this from the Name unless you set InsecurePassword to true."
        },
        "port": {
          "name": "Port",
          "type": "int",
          "description": "Port to connect to. If not specified, we parse this from the Name."
        },
        "state": {
          "name": "State",
          "type": "str",
          "description": "State of machine power. Can be \"on\" or \"off\"."
        },
        "username": {
          "name": "Username",
          "type": "str",
          "description": "Username to use to connect. If not specified, we parse this from the Name. Name? It's not really part of the BMC unique identifier so maybe we shouldn't use that."
        }
      }
    },
    "config:etcd": {
      "name": "ConfigEtcdRes",
      "kind": "config:etcd",
      "file": "config_etcd.go",
      "description": "ConfigEtcdRes is a resource that sets mgmt's etcd configuration.",
      "fields": {
        "allow_size_shutdown": {
          "name": "AllowSizeShutdown",
          "type": "bool",
          "description": "AllowSizeShutdown is a required safety flag that you must set to true if you want to allow causing a cluster shutdown by setting IdealClusterSize to zero."
        },
        "idealclustersize": {
          "name": "IdealClusterSize",
          "type": "int",
          "description": "IdealClusterSize is the requested minimum size of the cluster. If you set this to zero, it will cause a cluster wide shutdown if AllowSizeShutdown is true. If it's not true, then it will cause a validation error."
        }
      }
    },
    "consul:kv": {
      "name": "ConsulKVRes",
      "kind": "consul:kv",
      "file": "consul_kv.go",
      "description": "ConsulKVRes is a resource that writes a value into a Consul datastore. The name of the resource can either be the key name, or the concatenation of the server address and the key name: http://127.0.0.1:8500/my-key. If the param keys are specified, then those are used. If the Name cannot be properly parsed by url.Parse, then it will be considered as the Key's value. If the Key is specified explicitly, then we won't use anything from the Name.",
      "fields": {
        "address": {
          "name": "Address",
          "type": "str",
          "description": "Address is the address of the Consul server. Default: 127.0.0.1:8500."
        },
        "key": {
          "name": "Key",
          "type": "str",
          "description": "Key is the name of the key. Defaults to the name of the resource."
        },
        "scheme": {
          "name": "Scheme",
          "type": "str",
          "description": "Scheme is the URI scheme for the Consul server. Default: http."
        },
        "token": {
          "name": "Token",
          "type": "str",
          "description": "Token is used to provide an ACL token to use for this resource."
        },
        "value": {
          "name": "Value",
          "type": "str",
          "description": "Value is the value for the key."
        }
      }
    },
    "cron": {
      "name": "CronRes",
      "kind": "cron",
      "file": "cron.go",
      "description": "CronRes is a systemd-timer cron resource.",
      "fields": {
        "accuracysec": {
          "name": "AccuracySec",
          "type": "str",
          "description": "AccuracySec is the accuracy of the timer in systemd-time time span format. It defaults to one minute."
        },
        "persistent": {
          "name": "Persistent",
          "type": "bool",
          "description": "Persistent, if true, means the time when the service unit was last triggered is stored on disk. When the timer is activated, the service unit is triggered immediately if it would have been triggered at least once during the time when the timer was inactive. It defaults to false."
        },
        "randomizeddelaysec": {
          "name": "RandomizedDelaySec",
          "type": "str",
          "description": "RandomizedDelaySec delays the timer by a randomly selected, evenly distributed amount of time between 0 and the specified time value. The value must be a valid systemd-time time span."
        },
        "remainafterelapse": {
          "name": "RemainAfterElapse",
          "type": "bool",
          "description": "RemainAfterElapse, if true, means an elapsed timer will stay loaded, and its state remains queryable. If false, an elapsed timer unit that cannot elapse anymore is unloaded. It defaults to true."
        },
        "session": {
          "name": "Session",
          "type": "bool",
          "description": "Session, if true, creates the timer as the current user, rather than root. The service it points to must also be a user unit. It defaults to false."
        },
        "startup": {
          "name": "Startup",
          "type": "str",
          "description": "Startup specifies what should happen on startup. Values can be: enabled, disabled, and undefined (empty string). We default to enabled."
        },
        "state": {
          "name": "State",
          "type": "str",
          "description": "State must be 'exists' or 'absent'."
        },
        "time": {
          "name": "Time",
          "type": "str",
          "description": "Time must be used with all triggers. For 'OnCalendar', it must be in the format defined in 'man systemd-time' under the heading 'Calendar Events'. For all other triggers, time should be a valid time span as defined in 'man systemd-time'"
        },
        "trigger": {
          "name": "Trigger",
          "type": "str",
          "description": "Trigger is the type of timer. Valid types are 'OnCalendar', 'OnActiveSec'. 'OnBootSec'. 'OnStartupSec'. 'OnUnitActiveSec', and 'OnUnitInactiveSec'. For more information see 'man systemd.timer'."
        },
        "unit": {
          "name": "Unit",
          "type": "str",
          "description": "Unit is the name of the systemd service unit. It is only necessary to set if you want to specify a service with a different name than the resource."
        },
        "wakesystem": {
          "name": "WakeSystem",
          "type": "bool",
          "description": "WakeSystem, if true, will cause the system to resume from suspend, should it be suspended and if the system supports this. It defaults to false."
        }
      }
    },
    "deploy:tar": {
      "name": "DeployTar",
      "kind": "deploy:tar",
      "file": "deploy_tar.go",
      "description": "DeployTar is a resource that archives a deploy filesystem using tar, thus combining them into a single file. The name of the resource is the path to the resultant archive file. The input comes from the current deploy. This uses hashes to determine if something was changed, so as a result, this may not be suitable if you can create a sha256 hash collision. this changes, or consider porting this to use that as a composite resource. file resource to store those contents on disk with whatever mode we want...",
      "fields": {
        "format": {
          "name": "Format",
          "type": "int",
          "description": "Format is the header format to use. If you change this, then the file will get rearchived. The strange thing is that it seems the header format is stored for each individual file. The available values are: const.res.tar.format.unknown, const.res.tar.format.ustar, const.res.tar.format.pax, and const.res.tar.format.gnu which have values of 0, 2, 4, and 8 respectively."
        },
        "path": {
          "name": "Path",
          "type": "str",
          "description": "Path, which defaults to the name if not specified, represents the destination path for the compressed file being created. It must be an absolute path, and as a result must start with a slash. Since it is a file, it must not end with a slash."
        }
      }
    },
    "dhcp:host": {
      "name": "DHCPHostRes",
      "kind": "dhcp:host",
      "file": "dhcp.go",
      "description": "DHCPHostRes is a representation of a static host assignment in DHCP.",
      "fields": {
        "ip": {
          "name": "IP",
          "type": "str",
          "description": "IP is the IPv4 address with the CIDR suffix. The suffix is required because it specifies the netmask to be used in the DHCPv4 protocol. For example, you might specify 192.0.2.42/24 which represents a mask of 255.255.255.0 that will be sent."
        },
        "mac": {
          "name": "Mac",
          "type": "str",
          "description": "Mac is the mac address of the host in lower case and separated with colons."
        },
        "nbp": {
          "name": "NBP",
          "type": "str",
          "description": "NBP is the network boot program URL. This is used for the tftp server name and the boot file name. For example, you might use: tftp://192.0.2.13/pxelinux.0 for a common bios, pxe boot setup. Note that the \"scheme\" prefix is required, and that it's impossible to specify a file that doesn't begin with a leading slash. If you wish to specify a \"root less\" file (common for legacy tftp setups) then you can use this feature in conjunction with the NBPPath parameter. For DHCPv4, the scheme must be \"tftp\"."
        },
        "nbp_path": {
          "name": "NBPPath",
          "type": "str",
          "description": "NBPPath overrides the path that is sent for the nbp protocols. By default it is taken from parsing a URL in NBP, but this can override that. This is useful if you require a path that doesn't start with a slash. This is sometimes desirable for legacy tftp setups."
        },
        "server": {
          "name": "Server",
          "type": "str",
          "description": "Server is the name of the dhcp server resource to group this into. If it is omitted, and there is only a single dhcp resource, then it will be grouped into it automatically. If there is more than one main dhcp resource being used, then the grouping behaviour is *undefined* when this is not specified, and it is not recommended to leave this blank!"
        }
      }
    },
    "dhcp:range": {
      "name": "DHCPRangeRes",
      "kind": "dhcp:range",
      "file": "dhcp.go",
      "description": "DHCPRangeRes is a representation of a range allocator in DHCP. To declare a range you must specify either the `network` field or the `from` and `to` fields as ip with cidr's, or `from` and `to` fields without cidr's but with the `mask` field as either a dotted netmask or a `/number` field. If you specify none of these, then the resource name will be interpreted the same way that the `network` field os. The last ip in the range (which is often used as a broadcast address) is never allocated.",
      "fields": {
        "from": {
          "name": "From",
          "type": "str",
          "description": "From is the start address in the range inclusive. If it is specified in cidr notation, then the `mask` field must not be used. Otherwise it must be used. In both situations the cidr or mask must be consistent with the `to` field. If this field is used, you must not use the `network` field."
        },
        "mask": {
          "name": "Mask",
          "type": "str",
          "description": "Mask is the cidr or netmask of ip addresses in the specified range. This field must only be used if both `from` and `to` are specified, and if neither of them specify a cidr suffix. If neither do, then the mask here can be in either dotted format or, preferably, in cidr format by starting with a slash."
        },
        "nbp": {
          "name": "NBP",
          "type": "str",
          "description": "NBP is the network boot program URL. This is used for the tftp server name and the boot file name. For example, you might use: tftp://192.0.2.13/pxelinux.0 for a common bios, pxe boot setup. Note that the \"scheme\" prefix is required, and that it's impossible to specify a file that doesn't begin with a leading slash. If you wish to specify a \"root less\" file (common for legacy tftp setups) then you can use this feature in conjunction with the NBPPath parameter. For DHCPv4, the scheme must be \"tftp\"."
        },
        "nbp_path": {
          "name": "NBPPath",
          "type": "str",
          "description": "NBPPath overrides the path that is sent for the nbp protocols. By default it is taken from parsing a URL in NBP, but this can override that. This is useful if you require a path that doesn't start with a slash. This is sometimes desirable for legacy tftp setups."
        },
        "network": {
          "name": "Network",
          "type": "str",
          "description": "Network is the network number and cidr to determine the range. For example, the common network range of 192.168.42.1 to 192.168.42.255 should have a network field here of 192.168.42.0/24. You can either specify this field or `from` and `to`, but not a different combination. If you don't specify any of these fields, then the resource name will be parsed as if it was used here."
        },
        "persist": {
          "name": "Persist",
          "type": "bool",
          "description": "Persist should be true if you want to persist the lease information to disk so that a new (or changed) invocation of this resource with the same name, will regain that existing initial state at startup. that we could have redundant dhcp servers which share the same state. This would require having a distributed allocator through etcd too! database if any field param changes, as opposed to just looking at the name field alone."
        },
        "server": {
          "name": "Server",
          "type": "str",
          "description": "Server is the name of the dhcp server resource to group this into. If it is omitted, and there is only a single dhcp resource, then it will be grouped into it automatically. If there is more than one main dhcp resource being used, then the grouping behaviour is *undefined* when this is not specified, and it is not recommended to leave this blank!"
        },
        "skip": {
          "name": "Skip",
          "type": "[]str",
          "description": "Skip is a list ip's in either cidr or standalone representation which will be skipped and not allocated."
        },
        "to": {
          "name": "To",
          "type": "str",
          "description": "To is the end address in the range inclusive. If it is specified in cidr notation, then the `mask` field must not be used. Otherwise it must be used. In both situations the cidr or mask must be consistent with the `from` field. If this field is used, you must not use the `network` field."
        }
      }
    },
    "dhcp:server": {
      "name": "DHCPServerRes",
      "kind": "dhcp:server",
      "file": "dhcp.go",
      "description": "DHCPServerRes is a simple dhcp server resource. It responds to dhcp client requests, but does not actually apply any state. The name is used as the address to listen on, unless the Address field is specified, and in that case it is used instead. The resource can offer up dhcp client leases from any number of dhcp:host resources which will get autogrouped into this resource at runtime.\nThis server is not meant as a featureful replacement for the venerable dhcpd, but rather as a simple, dynamic, integrated alternative for bootstrapping new machines and clusters in an elegant way.\n",
      "fields": {
        "address": {
          "name": "Address",
          "type": "str",
          "description": "Address is the listen address to use for the dhcp server. It is common to use `:67` (the standard) to listen on UDP port 67 on all addresses."
        },
        "dns": {
          "name": "DNS",
          "type": "[]str",
          "description": "DNS represents a list of DNS servers to offer to the DHCP client."
        },
        "interface": {
          "name": "Interface",
          "type": "str",
          "description": "Interface is interface to bind to. For example `eth0` for the common case. You may leave this field blank to not run any specific binding. BUG: https://github.com/insomniacslk/dhcp/issues/372"
        },
        "leasetime": {
          "name": "LeaseTime",
          "type": "str",
          "description": "LeaseTime is the default lease duration in a format that is parseable by the golang time.ParseDuration function, for example \"60s\" or \"10m\" or \"1h42m13s\". If it is unspecified, then a default will be used. If the empty string is specified, then no lease time will be set in the DHCP protocol, and your DHCP server might not work as you intend."
        },
        "nbp": {
          "name": "NBP",
          "type": "str",
          "description": "NBP is the network boot program URL. This is used for the tftp server name and the boot file name. For example, you might use: tftp://192.0.2.13/pxelinux.0 for a common bios, pxe boot setup. Note that the \"scheme\" prefix is required, and that it's impossible to specify a file that doesn't begin with a leading slash. If you wish to specify a \"root less\" file (common for legacy tftp setups) then you can use this feature in conjunction with the NBPPath parameter. For DHCPv4, the scheme must be \"tftp\". This values is used as the default for all dhcp:host resources. You can specify this here, and the NBPPath per-resource and they will successfully combine."
        },
        "routers": {
          "name": "Routers",
          "type": "[]str",
          "description": "Routers represents a list of routers to offer to the DHCP client. It is most common to only specify one unless you know what you're doing."
        },
        "serverid": {
          "name": "ServerID",
          "type": "str",
          "description": "ServerID is a unique IPv4 identifier for this server as specified in the DHCPv4 protocol. It is almost always the IP address of the DHCP server. If you don't specify this, then we will attempt to determine it from the specified interface. If it is set to the empty string, then this won't be set in the DHCP protocol, and your DHCP server might not work as you intend. Otherwise, if a valid value is specified, then this will be used as long as it validates correctly. Please note that if you attempt to automatically determine this from the specified interface, then this only happens at runtime when the first DHCP request needs this or during CheckApply, either of which could fail if for some reason it is not available."
        }
      }
    },
    "docker:container": {
      "name": "DockerContainerRes",
      "kind": "docker:container",
      "file": "docker_container.go",
      "description": "DockerContainerRes is a docker container resource.",
      "fields": {
        "apiversion": {
          "name": "APIVersion",
          "type": "str",
          "description": "APIVersion allows you to override the host's default client API version."
        },
        "cmd": {
          "name": "Cmd",
          "type": "[]str",
          "description": "Cmd is a command, or list of commands to run on the container."
        },
        "env": {
          "name": "Env",
          "type": "[]str",
          "description": "Env is a list of environment variables. E.g. [\"VAR=val\",]."
        },
        "force": {
          "name": "Force",
          "type": "bool",
          "description": "Force, if true, this will destroy and redeploy the container if the image is incorrect."
        },
        "image": {
          "name": "Image",
          "type": "str",
          "description": "Image is a docker image, or image:tag."
        },
        "ports": {
          "name": "Ports",
          "type": "map{str: map{int: int}}",
          "description": "Ports is a map of port bindings. E.g. {\"tcp\" => {8080 => 80},}. The key is the host port, and the val is the inner service port to forward to."
        },
        "state": {
          "name": "State",
          "type": "str",
          "description": "State of the container must be running, stopped, or removed."
        }
      }
    },
    "docker:image": {
      "name": "DockerImageRes",
      "kind": "docker:image",
      "file": "docker_image.go",
      "description": "DockerImageRes is a docker image resource. The resource's name must be a docker image in any supported format (url, image, or image:tag).",
      "fields": {
        "apiversion": {
          "name": "APIVersion",
          "type": "str",
          "description": "APIVersion allows you to override the host's default client API version."
        },
        "state": {
          "name": "State",
          "type": "str",
          "description": "State of the image must be exists or absent."
        }
      }
    },
    "exec": {
      "name": "ExecRes",
      "kind": "exec",
      "file": "exec.go",
      "description": "ExecRes is an exec resource for running commands.\nThis resource attempts to minimise the effects of the execution environment, and, in particular, will start the new process with an empty environment (as would `execve` with an empty `envp` array). If you want the environment to inherit the mgmt process' environment, you can import it from \"sys\" and use it with `env => sys.env()` in your exec resource.",
      "fields": {
        "args": {
          "name": "Args",
          "type": "[]str",
          "description": "Args is a list of args to pass to Cmd. This can be used *instead* of passing the full command and args as a single string to Cmd. It can only be used when a Shell is *not* specified. The advantage of this is that you don't have to worry about escape characters."
        },
        "cmd": {
          "name": "Cmd",
          "type": "str",
          "description": "Cmd is the command to run. If this is not specified, we use the name. Remember that if you're not using `Shell` (the default) then adding single quotes around args make them part of the actual values. IOW, if your command is: \"touch '/tmp/foo'\", then (1) it probably won't be able to find the \"touch\" command (use /usr/bin/touch instead) and (2) the file won't be in the /tmp/ directory, it will be an oddly named file that contains two single quotes, and it will likely error since the dir path doesn't exist. In general, it's best to use the `Args` field instead of including them here."
        },
        "creates": {
          "name": "Creates",
          "type": "str",
          "description": "Creates is the absolute file path to check for before running the main cmd. If this path exists, then the cmd will not run. More precisely we attempt to `stat` the file, so it must succeed for a skip. This also adds a watch on this path which re-checks things when it changes."
        },
        "cwd": {
          "name": "Cwd",
          "type": "str",
          "description": "Cwd is the dir to run the command in. If empty, then this will use the working directory of the calling process. (This process is mgmt, not the process being run here.) Keep in mind that if you're running this command as a user that does not have perms to the current directory, you may wish to set this to `/` to avoid hitting an error such as: `could not change directory to \"/root\": Permission denied`."
        },
        "donecmd": {
          "name": "DoneCmd",
          "type": "str",
          "description": "DoneCmd is the command that runs after the regular Cmd runs successfully. This is a useful pattern to avoid the shelling out to bash simply to do `$cmd && echo done > /tmp/donefile`. If this command errors, it behaves as if the normal Cmd had errored."
        },
        "donecwd": {
          "name": "DoneCwd",
          "type": "str",
          "description": "DoneCwd is the Cwd for the DoneCmd. See the docs for Cwd."
        },
        "doneshell": {
          "name": "DoneShell",
          "type": "str",
          "description": "DoneShell is the Shell for the DoneCmd. See the docs for Shell."
        },
        "env": {
          "name": "Env",
          "type": "map{str: str}",
          "description": "Env allows the user to specify environment variables for script execution. These are taken using a map of format of VAR_KEY -> value. Omitting this value or setting it to an empty array will cause the program to be run with an empty environment."
        },
        "group": {
          "name": "Group",
          "type": "str",
          "description": "Group is the (optional) group to use to execute the command. It is used for any command being run."
        },
        "ifcmd": {
          "name": "IfCmd",
          "type": "str",
          "description": "IfCmd is the command that runs to guard against running the Cmd. If this command succeeds, then Cmd *will not* be blocked from running. If this command returns a non-zero result, then the Cmd will not be run. Any error scenario or timeout will cause the resource to error."
        },
        "ifcwd": {
          "name": "IfCwd",
          "type": "str",
          "description": "IfCwd is the Cwd for the IfCmd. See the docs for Cwd."
        },
        "ifequals": {
          "name": "IfEquals",
          "type": "str",
          "description": "IfEquals specifies that if the ifcmd returns zero, and that the output matches this string, then it will guard against the Cmd running. This can be the empty string. Remember to take into account if the output includes a trailing newline or not. (Hint: it usually does!)"
        },
        "ifshell": {
          "name": "IfShell",
          "type": "str",
          "description": "IfShell is the Shell for the IfCmd. See the docs for Shell."
        },
        "nifcmd": {
          "name": "NIfCmd",
          "type": "str",
          "description": "NIfCmd is the command that runs to guard against running the Cmd. If this command succeeds, then Cmd *will* be blocked from running. If this command returns a non-zero result, then the Cmd will be allowed to run if not blocked by anything else. This is the opposite of the IfCmd."
        },
        "nifcwd": {
          "name": "NIfCwd",
          "type": "str",
          "description": "NIfCwd is the Cwd for the NIfCmd. See the docs for Cwd."
        },
        "nifshell": {
          "name": "NIfShell",
          "type": "str",
          "description": "NIfShell is the Shell for the NIfCmd. See the docs for Shell."
        },
        "send_output": {
          "name": "SendOutput",
          "type": "str",
          "description": "SendOutput is a value which can be sent for the Send/Recv Output field if no value is available in the cache. This is used in very specialized scenarios (particularly prototyping and unclean environments) and should not be used routinely. It should be used only in situations where we didn't produce our own sending values, and there are none in the cache, and instead are relying on a runtime mechanism to help us out. This can commonly occur if you wish to make incremental progress when locally testing some code using Send/Recv, but you are combining it with --tmp-prefix for other reasons."
        },
        "send_stderr": {
          "name": "SendStderr",
          "type": "str",
          "description": "SendStderr is like SendOutput but for stderr alone. See those docs."
        },
        "send_stdout": {
          "name": "SendStdout",
          "type": "str",
          "description": "SendStdout is like SendOutput but for stdout alone. See those docs."
        },
        "shell": {
          "name": "Shell",
          "type": "str",
          "description": "Shell is the (optional) shell to use to run the cmd. If you specify this, then you can't use the Args parameter. Note that unless you use absolute paths, or set the PATH variable, the shell might not be able to find the program you're trying to run."
        },
        "timeout": {
          "name": "Timeout",
          "type": "int",
          "description": "Timeout is the number of seconds to wait before sending a Kill to the running command. If the Kill is received before the process exits, then this be treated as an error."
        },
        "user": {
          "name": "User",
          "type": "str",
          "description": "User is the (optional) user to use to execute the command. It is used for any command being run."
        },
        "watchcmd": {
          "name": "WatchCmd",
          "type": "str",
          "description": "WatchCmd is the command to run to detect event changes. Each line of output from this command is treated as an event."
        },
        "watchcwd": {
          "name": "WatchCwd",
          "type": "str",
          "description": "WatchCwd is the Cwd for the WatchCmd. See the docs for Cwd."
        },
        "watchfiles": {
          "name": "WatchFiles",
          "type": "[]str",
          "description": "WatchFiles is a list of files that will be kept track of."
        },
        "watchshell": {
          "name": "WatchShell",
          "type": "str",
          "description": "WatchShell is the Shell for the WatchCmd. See the docs for Shell."
        }
      }
    },
    "file": {
      "name": "FileRes",
      "kind": "file",
      "file": "file.go",
      "description": "FileRes is a file and directory resource. Dirs are defined by names ending in a slash.",
      "fields": {
        "basename": {
          "name": "Basename",
          "type": "str",
          "description": "Basename is used to override the path basename. (The file portion.)"
        },
        "content": {
          "name": "Content",
          "type": "str",
          "description": "Content specifies the file contents to use. If this is nil, they are left undefined. It cannot be combined with the Source or Fragments parameters."
        },
        "dirname": {
          "name": "Dirname",
          "type": "str",
          "description": "Dirname is used to override the path dirname. (The directory portion.)"
        },
        "force": {
          "name": "Force",
          "type": "bool",
          "description": "Force must be set if we want to perform an unusual operation, such as changing a file into a directory or vice-versa. This is also required when changing a file or directory into a symlink or vice-versa."
        },
        "fragments": {
          "name": "Fragments",
          "type": "[]str",
          "description": "Fragments specifies that the file is built from a list of individual files. If one of the files is a directory, then the list of files in that directory are the fragments to combine. Multiple of these can be used together, although most simple cases will probably only either involve a single directory path or a fixed list of individual files. All paths are absolute and as a result must start with a slash. The directories (if any) must end with a slash as well. This cannot be combined with the Content or Source parameters. If a file with param is reversed, the reversed file is one that has `Content` set instead. Automatic edges will be added from these fragments. This currently isn't recursive in that if a fragment is a directory, this only searches one level deep at the moment."
        },
        "group": {
          "name": "Group",
          "type": "str",
          "description": "Group specifies the file group. You can specify either the string name, or a string representation of the group integer gid."
        },
        "mode": {
          "name": "Mode",
          "type": "str",
          "description": "Mode is the mode of the file as a string representation of the octal form or symbolic form."
        },
        "owner": {
          "name": "Owner",
          "type": "str",
          "description": "Owner specifies the file owner. You can specify either the string name, or a string representation of the owner integer uid."
        },
        "path": {
          "name": "Path",
          "type": "str",
          "description": "Path, which defaults to the name if not specified, represents the destination path for the file or directory being managed. It must be an absolute path, and as a result must start with a slash."
        },
        "purge": {
          "name": "Purge",
          "type": "bool",
          "description": "Purge specifies that when true, any unmanaged file in this file directory will be removed. As a result, this file resource must be a directory. This isn't particularly meaningful if you don't also set Recurse to true. This doesn't work with Content or Fragments."
        },
        "recurse": {
          "name": "Recurse",
          "type": "bool",
          "description": "Recurse specifies if you want to work recursively on the resource. It is used when copying a source directory, or to determine if a watch should be recursive or not. When making a directory, this is required if you'd need the parent directories to be made as well. (Analogous to the `mkdir -p` option.)"
        },
        "source": {
          "name": "Source",
          "type": "str",
          "description": "Source specifies the source contents for the file resource. It cannot be combined with the Content or Fragments parameters. It must be an absolute path, and it can point to a file or a directory. If it points to a file, then that will will be copied through directly. If it points to a directory, then it will copy the directory \"rsync style\" onto the file destination. As a result, if this is a file, then the main file res must be a file, and if it is a directory, then this must be a directory. To meaningfully copy a full directory, you also need to specify the Recurse parameter, which is currently required. If you want an existing dir to be turned into a file (or vice-versa) instead of erroring, then you'll also need to specify the Force parameter. If source is undefined and the file path is a directory, then a directory will be created. If left undefined, and combined with the Purge option too, then any unmanaged file in this dir will be removed. Lastly, if the Symlink parameter is true, then this specifies the source that the symbolic symlink points to."
        },
        "state": {
          "name": "State",
          "type": "str",
          "description": "State specifies the desired state of the file. It can be either `exists` or `absent`. If you do not specify this, we will not be able to create or remove a file if it might be logical for another param to require that. Instead it will error. This means that this field is not implied by specifying some content or a mode. This is also used when determining how we manage a symlink."
        },
        "symlink": {
          "name": "Symlink",
          "type": "bool",
          "description": "Symlink specifies that the file should be a symbolic link to the source contents. Those do not have to point to an actual file or directory. The source in that case can be either an absolute or relative path."
        }
      }
    },
    "firewalld": {
      "name": "FirewalldRes",
      "kind": "firewalld",
      "file": "firewalld.go",
      "description": "FirewalldRes is a simple resource to interact with the firewalld service. It is not a replacement for a modern, robust tool like `shorewall`, but it has its uses such as for small, desktop use cases. The API of this resource might change to either add new features, split this into multiple resources, or to optimize the execution if it turns out to be too expensive to run large amounts of these as-is. The name variable currently has no useful purpose. Keep in mind that this resource requires root permissions to be able change the firewall settings and to monitor for changes. The change detection uses the nftables monitor facility.",
      "fields": {
        "ports": {
          "name": "Ports",
          "type": "[]str",
          "description": "Ports are the list of port/protocol combinations to manage to the desired state. These are strings of port number (slash) protocol like `4280/tcp` and `38/udp`."
        },
        "services": {
          "name": "Services",
          "type": "[]str",
          "description": "Services are the list of services to manage to the desired state. These are single lower case strings like `dhcp`, and `tftp`."
        },
        "state": {
          "name": "State",
          "type": "str",
          "description": "State is the desired state."
        },
        "zone": {
          "name": "Zone",
          "type": "str",
          "description": "Zone is the name of the zone to manage. If unspecified, we will attempt to get the default zone automatically. In this situation, it is possible that this default changes over time if it is acted upon by external tools that use firewalld."
        }
      }
    },
    "fwattr": {
      "name": "FWAttrRes",
      "kind": "fwattr",
      "file": "fwattr.go",
      "description": "FWAttrRes is a resource for interacting with the kernel firmware attributes API. This resource will automatically use the correct \"value\" for a key when more than one is possible for that particular vendor. If you have a mapping that is not in our database, please send a patch.\nPlease note that on some platforms such as Lenovo (thinklmi), there is an architectural limitation that prevents more than 48 attributes from being set before presumably needing to reboot.\nhttps://www.kernel.org/doc/Documentation/ABI/testing/sysfs-class-firmware-attributes\nApparently if we go over, you need to manually enter the BIOS to clear the error. Of course we can never know if the user edited these elsewhere.",
      "fields": {
        "check": {
          "name": "Check",
          "type": "bool",
          "description": "Check (which defaults to true) turns off the validation that runs before we attempt to change a setting. This should only be used in rare exceptions where you have an old/buggy version of firmware that has illogical data presented through the kernel API. For example, one version of BootOrder on thinklmi had type \"enumeration\" and \"possible_values\" of: `HDD0;HDD1;HDD2;...` but took a \"current_value\" of `HDD0:HDD1:HDD2:...` which would be illogical. Newer versions just have type \"string\"."
        },
        "driver": {
          "name": "Driver",
          "type": "str",
          "description": "Driver is the interface that is supported. Available options can be found in the /sys/class/firmware-attributes/ directory. Common values include \"thinklmi\" (lenovo), \"dell-wmi-sysman\" (dell) and more. If you do not specify this, then we will attempt to determine it automatically, however if zero or more than one option exists, then this will error."
        },
        "key": {
          "name": "Key",
          "type": "str",
          "description": "Key is the name of the field to modify. If this is not set we use the Name field. This is case sensitive."
        },
        "skip": {
          "name": "Skip",
          "type": "bool",
          "description": "Skip let's you turn this resource into a \"noop\" if the key doesn't exist. This should ideally not be used because a typo would effectively make this resource ineffective. As a result, if you use this, it will emit a warning. This option is very useful, because you can add a more general \"configuration set\" of values to all of your machine, without having to match them precisely, and this won't cause errors if one of them has an old version of a BIOS without that feature. This will also skip if the attributes API doesn't exist on this machine."
        },
        "strict": {
          "name": "Strict",
          "type": "bool",
          "description": "Strict means that we won't use the \"quirks\" alternate values mapping if the exact key is not available. It should not be harmful to keep this off, but it would be useful to find which old values are being used long after legacy firmware has been deprecated."
        },
        "value": {
          "name": "Value",
          "type": "str",
          "description": "Value is the string value to set. Make sure you specify it in the same format that the kernel offers it as to avoid automation \"flapping\" or errors. You can test this by writing a value to the /sys/class/firmware-attributes/<driver>/<key>/current_value path with `echo foo >` and seeing if it works without erroring. You must not include the trailing newline which is present all values.\nthis also be an int or a bool, and for booleans, map them using our json file to the correct string value of \"Enabled\" (for those keys of the boolean variety)."
        }
      }
    },
    "group": {
      "name": "GroupRes",
      "kind": "group",
      "file": "group.go",
      "description": "GroupRes is a user group resource.",
      "fields": {
        "gid": {
          "name": "GID",
          "type": "int",
          "description": "GID is the group's gid."
        },
        "state": {
          "name": "State",
          "type": "str",
          "description": "State is `exists` or `absent`."
        }
      }
    },
    "gsettings": {
      "name": "GsettingsRes",
      "kind": "gsettings",
      "file": "gsettings.go",
      "description": "GsettingsRes is a resource for setting dconf values through gsettings. The ideal scenario is that this runs as the same user that wants settings set. This should be done by a local user-specific mgmt daemon. As a special case, we can run as root (or anyone with permission) which launches a subprocess which setuid/setgid's to that user to run the needed operations. To specify the schema and key, set the resource name as \"schema key\" (separated by a single space character) or use the parameters.",
      "fields": {
        "group": {
          "name": "Group",
          "type": "str",
          "description": "Group is the (optional) group to use to execute the command. It is used for any command being run."
        },
        "key": {
          "name": "Key",
          "type": "str",
          "description": "Key is the key to set."
        },
        "schema": {
          "name": "Schema",
          "type": "str",
          "description": "Schema is the schema to use in. This can be schema:path if the schema doesn't have a fixed path. See the `gsettings` manual for more info."
        },
        "type": {
          "name": "Type",
          "type": "str",
          "description": "Type is the type value to set. This can be \"bool\", \"str\", \"int\", or \"custom\"."
        },
        "user": {
          "name": "User",
          "type": "str",
          "description": "User is the (optional) user to use to execute the command. It is used for any command being run."
        },
        "value": {
          "name": "Value",
          "type": "variant",
          "description": "Value is the value to set. It is interface{} because it can hold any value type."
        }
      }
    },
    "gzip": {
      "name": "GzipRes",
      "kind": "gzip",
      "file": "gzip.go",
      "description": "GzipRes is a resource that compresses a path or some raw data using gzip. The name of the resource is the path to the resultant compressed file. The input can either come from a file path if specified with Input or it looks at the Content field for raw data. It uses hashes to determine if something was changed, so as a result, this may not be suitable if you can create a sha256 hash collision.",
      "fields": {
        "content": {
          "name": "Content",
          "type": "str",
          "description": "Content is the raw data to compress. If Input is not specified, then we use this parameter. If you forget to specify both of these, then you will compress zero-length data!"
        },
        "input": {
          "name": "Input",
          "type": "str",
          "description": "Input represents the input file to be compressed. It must be an absolute path, and as a result must start with a slash. Since it is a file, it must not end with a slash. If this is specified, we use it, otherwise we use the Content parameter."
        },
        "level": {
          "name": "Level",
          "type": "int",
          "description": "Level is the compression level to use. If you change this, then the file will get recompressed. The available values are: const.res.gzip.level.no_compression, const.res.gzip.level.best_speed, const.res.gzip.level.best_compression, const.res.gzip.level.default_compression, and const.res.gzip.level.huffman_only."
        },
        "path": {
          "name": "Path",
          "type": "str",
          "description": "Path, which defaults to the name if not specified, represents the destination path for the compressed file being created. It must be an absolute path, and as a result must start with a slash. Since it is a file, it must not end with a slash."
        }
      }
    },
    "hetzner:vm": {
      "name": "HetznerVMRes",
      "kind": "hetzner:vm",
      "file": "hetzner_vm.go",
      "description": "HetznerVMRes is a Hetzner cloud resource (1). It connects with the cloud API using the hcloud-go package provided by Hetzner. The API token for a new project must be generated manually, via the cloud console (2), before this resource can establish a connection with the API. One Hetzner resource represents one server instance, and multiple instances can be registered under the same project. A resource in the \"absent\" state only exists as a local mcl struct, and does not exist as server instance on Hetzner's side. NOTE: the Hetzner cloud console must be used to create a new project, generate the corresponding API token, and initialize the desired SSH keys. All registered SSH keys are used when creating a server, and a subset of those can be enabled for rescue mode via the \"serverrescuekeys\" param. NOTE: complete and up-to-date serverconfig options must be requested from the Hetzner API, but hcloud-go-getopts (3) provides a static reference. NOTE: this resources requires polling, via the \"Meta:poll\" param. The Hetzner API imposes a maximum rate of 3600 requests per hour that must be taken into account for intensive and/or long term operations. When running N hetzner:vm resources under the same Hetzner project, it is recommended to use a polling interval of at least N seconds. High rates of change to other params will require additional API requests at CheckApply. When frequent param updates are expected for long term operations, it is reommended to increase the polling interval again to prevent rate limit errors. NOTE: running multiple concurrent mcl scripts on the same resource might cause unexpected behavior in the API or the resource state. Use with care. 1) https://docs.hetzner.cloud/ 2) https://console.hetzner.cloud/ 3) https://github.com/jefmasereel/hcloud-go-getopts",
      "fields": {
        "allowrebuild": {
          "name": "AllowRebuild",
          "type": "str",
          "description": "AllowRebuild provides flexible protection against unexpected server rebuilds. Any changes to the \"servertype\", \"datacenter\" or \"image\" params require a destructive rebuild, which deletes all data on that server. The user must explicitly allow these operations with AllowRebuild. Choose from three options: \"ifneeded\" allows all rebuilds that are needed by CheckApply to meet the specified params. \"ignore\" disables these rebuilds, but continues without error. The default option (\"\") disables always returns an error when CheckApply requests a rebuild. NOTE: Soft updates related to power and rescue mode are always allowed, because they are only required for explicit changes to resource fields."
        },
        "apitoken": {
          "name": "APIToken",
          "type": "str",
          "description": "APIToken specifies the unique API token corresponding to a Hetzner project. Keep this token private! It provides full access to this project, so a leaked token will be vulnerable to abuse. Read it from a local file or the mgmt deploy, or provide it directly as a string. NOTE: It must be generated manually via https://console.hetzner.cloud/. NOTE: This token is usually a 64 character alphanumeric string."
        },
        "datacenter": {
          "name": "Datacenter",
          "type": "str",
          "description": "Datacenter determines where the resource is hosted.  A complete and up-to-date list of options must be requested from the Hetzner API, but hcloud-go-getopts (url) provides a static reference. The datacenter options include \"nbg1-dc3\", \"fsn1-dc14\", \"hel1-dc2\" etc. https://github.com/JefMasereel/hcloud-go-getopts/"
        },
        "image": {
          "name": "Image",
          "type": "str",
          "description": "Image determines the operating system to be installed. A complete and up-to-date list of options must be requested from the Hetzner API, but hcloud-go-getopts (url) provides a static reference. The image type options include \"centos-7\", \"ubuntu-18.04\", \"debian-10\" etc. https://github.com/JefMasereel/hcloud-go-getopts/"
        },
        "serverrescuekeys": {
          "name": "ServerRescueSSHKeys",
          "type": "[]str",
          "description": "ServerRescueSSHKeys can be used to select a subset of keys that should be enabled for rescue mode operations over SSH. From all SSH keys known to the project client, choose a subset of keys by name, as an array of strings. New keys must first be added manually via the cloud console. An error is thrown if a given keyname is not recognized by the client. NOTE: live changes to this keylist while rescue mode is already enabled are not (yet) detected or applied by CheckApply."
        },
        "serverrescuemode": {
          "name": "ServerRescueMode",
          "type": "str",
          "description": "ServerRescueMode specifies the image type used when enabling rescue mode. The supported image types are \"linux32\", \"linux64\" and \"freebsd64\". Alternatively, leave this string empty to disable rescue mode (default). Other input values will not pass Validate and result in an error. NOTE: rescue mode can not be enabled if the server is absent. NOTE: Rescue mode can be used to log into the server over SSH and access the disks when the normal OS has trouble booting on its own."
        },
        "servertype": {
          "name": "ServerType",
          "type": "str",
          "description": "ServerType determines the machine type as defined by Hetzner. A complete and up-to-date list of options must be requested from the Hetzner API, but hcloud-go-getopts (url) provides a static reference. Basic servertype options include \"cx11\", \"cx21\", \"cx31\" etc. NOTE: make sure to check the price of the selected servertype! The listed examples are usually very cheap, but never free. Price and availability can also be dependent on the selected datacenter. https://github.com/JefMasereel/hcloud-go-getopts/"
        },
        "state": {
          "name": "State",
          "type": "str",
          "description": "State specifies the desired state of the server instance. The supported options are \"\" (undefined), \"absent\", \"exists\", \"off\" and \"running\". HetznerStateUndefined (\"\") leaves the state undefined by default. HetznerStateExists (\"exists\") indicates that the server must exist. HetznerStateAbsent (\"absent\") indicates that the server must not exist. HetznerStateRunning (\"running\") tells the server it must be powered on. HetznerStateOff (\"off\") tells the server it must be powered off. NOTE: any other inputs will not pass Validate and result in an error. NOTE: setting the state of a live server to \"absent\" will delete all data and services that are located on that instance! Use with caution."
        },
        "userdata": {
          "name": "UserData",
          "type": "str",
          "description": "UserData can be used to run commands on the server instance at creation. https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html."
        },
        "waitinterval": {
          "name": "WaitInterval",
          "type": "int",
          "description": "WaitInterval is the interval in seconds that is used when waiting for transient states to converge between intermediate operations. A zero value causes the waiter to run without delays (burst requests). Although such burst requests are allowed, it is recommended to use a wait interval that keeps the total request rate under 3600 requests per hour. Take these factors into account: polling rate \"Meta:poll\", number of active resources under the same Hetzner project, and the expected rate of param updates. This will help to prevent rate limit errors."
        },
        "waittimeout": {
          "name": "WaitTimeout",
          "type": "int",
          "description": "WaitTimeout will cancel wait loops if they do not exit cleanly before the expected time in seconds, in order to detect defective loops and avoid unnecessary consumption of computational resources."
        }
      }
    },
    "hostname": {
      "name": "HostnameRes",
      "kind": "hostname",
      "file": "hostname.go",
      "description": "HostnameRes is a resource that allows setting and watching the hostname. If you don't specify any parameters, the Name is used. The Hostname field is used if none of the other parameters are used. If the parameters are set to the empty string, then those variants are not managed by the resource.",
      "fields": {
        "hostname": {
          "name": "Hostname",
          "type": "str",
          "description": "Hostname specifies the hostname we want to set in all of the places that it's possible. This is the fallback value for all the three fields below. If only this Hostname field is specified, this will set all tree fields (PrettyHostname, StaticHostname, TransientHostname) to this value."
        },
        "pretty_hostname": {
          "name": "PrettyHostname",
          "type": "str",
          "description": "PrettyHostname is a free-form UTF8 host name for presentation to the user."
        },
        "static_hostname": {
          "name": "StaticHostname",
          "type": "str",
          "description": "StaticHostname is the one configured in /etc/hostname or a similar file. It is chosen by the local user. It is not always in sync with the current host name as returned by the gethostname() system call."
        },
        "transient_hostname": {
          "name": "TransientHostname",
          "type": "str",
          "description": "TransientHostname is the one configured via the kernel's sethostbyname(). It can be different from the static hostname in case DHCP or mDNS have been configured to change the name based on network information."
        }
      }
    },
    "http:server": {
      "name": "HTTPServerRes",
      "kind": "http:server",
      "file": "http_server.go",
      "description": "HTTPServerRes is an http server resource. It serves files, but does not actually apply any state. The name is used as the address to listen on, unless the Address field is specified, and in that case it is used instead. This resource can offer up files for serving that are specified either inline in this resource by specifying an http root, or as http:server:file resources which will get autogrouped into this resource at runtime. The two methods can be combined as well.\nThis server also supports autogrouping some more magical resources into it. For example, the http:server:flag and http:server:ui resources add in magic endpoints.\nThis server is not meant as a featureful replacement for the venerable and modern httpd servers out there, but rather as a simple, dynamic, integrated alternative for bootstrapping new machines and clusters in an elegant way.\n",
      "fields": {
        "address": {
          "name": "Address",
          "type": "str",
          "description": "Address is the listen address to use for the http server. It is common to use `:80` (the standard) to listen on TCP port 80 on all addresses."
        },
        "read_timeout": {
          "name": "ReadTimeout",
          "type": "int",
          "description": "ReadTimeout is the maximum duration in seconds for reading during the http request. If it is zero, then there is no timeout. If this is unspecified, then the value of Timeout is used instead if it is set. For more information, see the golang net/http Server documentation."
        },
        "root": {
          "name": "Root",
          "type": "str",
          "description": "Root is the root directory that we should serve files from. If it is not specified, then it is not used. Any http file resources will have precedence over anything in here, in case the same path exists twice."
        },
        "shutdown_timeout": {
          "name": "ShutdownTimeout",
          "type": "int",
          "description": "ShutdownTimeout is the maximum duration in seconds to wait for the server to shutdown gracefully before calling Close. By default it is nice to let client connections terminate gracefully, however it might take longer than we are willing to wait, particularly if one is long polling or running a very long download. As a result, you can set a timeout here. The default is zero which means it will wait indefinitely. The shutdown process can also be cancelled by the interrupt handler which this resource supports. If this is unspecified, then the value of Timeout is used instead if it is set."
        },
        "timeout": {
          "name": "Timeout",
          "type": "int",
          "description": "Timeout is the maximum duration in seconds to use for unspecified timeouts. In other words, when this value is specified, it is used as the value for the other *Timeout values when they aren't used. Put another way, this makes it easy to set all the different timeouts with a single parameter."
        },
        "write_timeout": {
          "name": "WriteTimeout",
          "type": "int",
          "description": "WriteTimeout is the maximum duration in seconds for writing during the http request. If it is zero, then there is no timeout. If this is unspecified, then the value of Timeout is used instead if it is set. For more information, see the golang net/http Server documentation."
        }
      }
    },
    "http:server:file": {
      "name": "HTTPServerFileRes",
      "kind": "http:server:file",
      "file": "http_server_file.go",
      "description": "HTTPServerFileRes is a file that exists within an http server. The name is used as the public path of the file, unless the filename field is specified, and in that case it is used instead. The way this works is that it autogroups at runtime with an existing http resource, and in doing so makes the file associated with this resource available for serving from that http server.",
      "fields": {
        "data": {
          "name": "Data",
          "type": "str",
          "description": "Data is the file content that should be used as the source for this file resource. It must not be combined with the path field."
        },
        "filename": {
          "name": "Filename",
          "type": "str",
          "description": "Filename is the name of the file this data should appear as on the http server."
        },
        "path": {
          "name": "Path",
          "type": "str",
          "description": "Path is the absolute path to a file that should be used as the source for this file resource. It must not be combined with the data field. If this corresponds to a directory, then it will used as a root dir that will be served as long as the resource name or Filename are also a directory ending with a slash."
        },
        "server": {
          "name": "Server",
          "type": "str",
          "description": "Server is the name of the http server resource to group this into. If it is omitted, and there is only a single http resource, then it will be grouped into it automatically. If there is more than one main http resource being used, then the grouping behaviour is *undefined* when this is not specified, and it is not recommended to leave this blank!"
        }
      }
    },
    "http:server:flag": {
      "name": "HTTPServerFlagRes",
      "kind": "http:server:flag",
      "file": "http_server_flag.go",
      "description": "HTTPServerFlagRes is a special path that exists within an http server. The name is used as the public path of the flag, unless the path field is specified, and in that case it is used instead. The way this works is that it autogroups at runtime with an existing http resource, and in doing so makes the flag associated with this resource available to cause actions when it receives a request on that http server. If you create a flag which responds to the same type of request as an http:server:file resource or any other kind of resource, it is undefined behaviour which will answer the request. The most common clash will happen if both are present at the same path.",
      "fields": {
        "key": {
          "name": "Key",
          "type": "str",
          "description": "Key is the querystring name that is used to capture a value as."
        },
        "path": {
          "name": "Path",
          "type": "str",
          "description": "Path is the path that this will present as on the http server."
        },
        "server": {
          "name": "Server",
          "type": "str",
          "description": "Server is the name of the http server resource to group this into. If it is omitted, and there is only a single http resource, then it will be grouped into it automatically. If there is more than one main http resource being used, then the grouping behaviour is *undefined* when this is not specified, and it is not recommended to leave this blank!"
        }
      }
    },
    "http:server:proxy": {
      "name": "HTTPServerProxyRes",
      "kind": "http:server:proxy",
      "file": "http_server_proxy.go",
      "description": "HTTPServerProxyRes is a resource representing a special path that exists within an http server. The name is used as the public path of the endpoint, unless the path field is specified, and in that case it is used instead. The way this works is that it autogroups at runtime with an existing http server resource, and in doing so makes the path associated with this resource available when serving files. When something under the path is accessed, this is pulled from the backing http server, which makes an http client connection if needed to pull the authoritative file down, saves it locally for future use, and then returns it to the original http client caller. On a subsequent call, if the cache was not invalidated, the file doesn't need to be fetched from the network. In effect, this works as a caching http proxy. If you create this as a resource which responds to the same type of request as an http:server:file resource or any other kind of resource, it is undefined behaviour which will answer the request. The most common clash will happen if both are present at the same path. This particular implementation stores some file data in memory as a convenience instead of streaming directly to clients. This makes locking much easier, but is wasteful. If you plan on using this for huge files and on systems with low amounts of memory, you might want to optimize this. The resultant proxy path is determined by subtracting the `Sub` field from the `Path` (and request path) and then appending the result to the `Head` field.",
      "fields": {
        "cache": {
          "name": "Cache",
          "type": "str",
          "description": "Cache is an absolute path to a location on disk where cached files can be stored. If this is empty then we will not cache any files."
        },
        "head": {
          "name": "Head",
          "type": "str",
          "description": "Head is the string to add on as a prefix to the new URL we are building for the proxy. If this is empty, the proxy can't work, and we can only rely on what is available in our local cache. This is typically the protocol and hostname for the backing server."
        },
        "path": {
          "name": "Path",
          "type": "str",
          "description": "Path is the path that this presents as on the grouped http server. It overrides the Name var if specified."
        },
        "server": {
          "name": "Server",
          "type": "str",
          "description": "Server is the name of the http server resource to group this into. If it is omitted, and there is only a single http resource, then it will be grouped into it automatically. If there is more than one main http resource being used, then the grouping behaviour is *undefined* when this is not specified, and it is not recommended to leave this blank!"
        },
        "sub": {
          "name": "Sub",
          "type": "str",
          "description": "Sub is the string to remove from the start of the request, the path of which is looking at the Name/Path field to see if it matches. If it matches, it then translates to the destination server by removing this `Sub` string from the start of the path request, and then prepending on the `Head` field to get to the resultant proxy URL. If this is empty, then nothing is subtracted."
        }
      }
    },
    "http:server:ui": {
      "name": "HTTPServerUIRes",
      "kind": "http:server:ui",
      "file": "http_server_ui.go",
      "description": "HTTPServerUIRes is a web UI resource that exists within an http server. The name is used as the public path of the ui, unless the path field is specified, and in that case it is used instead. The way this works is that it autogroups at runtime with an existing http server resource, and in doing so makes the form associated with this resource available for serving from that http server.",
      "fields": {
        "data": {
          "name": "Data",
          "type": "struct{title str; head str}",
          "description": "Data represents some additional data to attach to the resource."
        },
        "path": {
          "name": "Path",
          "type": "str",
          "description": "Path is the name of the path that this should be exposed under. For example, you might want to name this \"/ui/\" to expose it as \"ui\" under the server root. This overrides the name variable that is set."
        },
        "server": {
          "name": "Server",
          "type": "str",
          "description": "Server is the name of the http server resource to group this into. If it is omitted, and there is only a single http resource, then it will be grouped into it automatically. If there is more than one main http resource being used, then the grouping behaviour is *undefined* when this is not specified, and it is not recommended to leave this blank!"
        }
      }
    },
    "http:server:ui:input": {
      "name": "HTTPServerUIInputRes",
      "kind": "http:server:ui:input",
      "file": "http_server_ui_input.go",
      "description": "HTTPServerUIInputRes is a form element that exists within a http:server:ui resource, which exists within an http server. The name is used as the unique id of the field, unless the id field is specified, and in that case it is used instead. The way this works is that it autogroups at runtime with an existing http:server:ui resource, and in doing so makes the form field associated with this resource available as part of that ui which is itself grouped and served from the http server resource.",
      "fields": {
        "id": {
          "name": "ID",
          "type": "str",
          "description": "ID is the unique id for this element. It is used in form fields and should not be a private identifier. It must be unique within a given http ui."
        },
        "path": {
          "name": "Path",
          "type": "str",
          "description": "Path is the name of the http ui resource to group this into. If it is omitted, and there is only a single http ui resource, then it will be grouped into it automatically. If there is more than one main http ui resource being used, then the grouping behaviour is *undefined* when this is not specified, and it is not recommended to leave this blank!"
        },
        "sort": {
          "name": "Sort",
          "type": "str",
          "description": "Sort is a string that you can use to determine the global sorted display order of all the elements in a ui."
        },
        "store": {
          "name": "Store",
          "type": "str",
          "description": "Store the data in this source. It will also read in a default value from there if one is present. It will watch it for changes as well, and update the displayed value if it's changed from another source. This cannot be used at the same time as the Value field."
        },
        "type": {
          "name": "Type",
          "type": "str",
          "description": "Type specifies the type of input field this is, and some information about it."
        },
        "value": {
          "name": "Value",
          "type": "str",
          "description": "Value is the default value to use for the form field. If you change it, then the resource graph will change and we'll rebuild and have the new value visible. You can use either this or the Store field. swap to a new resource graph, and maybe Store is not needed?"
        }
      }
    },
    "kv": {
      "name": "KVRes",
      "kind": "kv",
      "file": "kv.go",
      "description": "KVRes is a resource which writes a key/value pair into cluster wide storage. It will ensure that the key is set to the requested value. The one exception is that if you use the SkipLessThan parameter, then it will only replace the stored value with the requested value if it is greater than that stored one. This allows the KV resource to be used in fast acting, finite state machines which have monotonically increasing state values that represent progression. The one exception is that when this resource receives a refresh signal, then it will set the value to be the exact one if they are not identical already.",
      "fields": {
        "key": {
          "name": "Key",
          "type": "str",
          "description": "Key represents the key to set. If it is not specified, the Name value is used instead."
        },
        "mapped": {
          "name": "Mapped",
          "type": "bool",
          "description": "Mapped specifies that we will store the value in a map with each hostname as part of the key. This is very useful for exchanging values when running this resource on multiple nodes simultaneously. To read/write/watch a single, global key, this value should be false. Note that resources may fight if more than one uses this. The `world` functions like `exchange`, require this to be true, since they're pulling values out of a pool that each node sets. The `world` functions like `getval`, require this to be false, since they're pulling values directly out of the same namespace that is shared by all nodes."
        },
        "skipcmpstyle": {
          "name": "SkipCmpStyle",
          "type": "int",
          "description": "SkipCmpStyle is the type of compare function used when determining if the value is greater when using the SkipLessThan parameter."
        },
        "skiplessthan": {
          "name": "SkipLessThan",
          "type": "bool",
          "description": "SkipLessThan causes the value to be updated as long as it is greater."
        },
        "value": {
          "name": "Value",
          "type": "str",
          "description": "Value represents the string value to set. If this value is nil or, undefined, then this will delete that key."
        }
      }
    },
    "line": {
      "name": "LineRes",
      "kind": "line",
      "file": "line.go",
      "description": "LineRes is a simple resource that adds or removes a line of text from a file. For more complicated control over the file, use the regular File resource.",
      "fields": {
        "content": {
          "name": "Content",
          "type": "str",
          "description": "Content specifies the line contents to add or remove. If this is empty, then it does nothing."
        },
        "file": {
          "name": "File",
          "type": "str",
          "description": "File is the absolute path to the file that we are managing."
        },
        "state": {
          "name": "State",
          "type": "str",
          "description": "State specifies the desired state of the line. It can be either `exists` or `absent`. If you do not specify this, we will not be able to create or remove a line."
        },
        "trim": {
          "name": "Trim",
          "type": "bool",
          "description": "Trim specifies that we will trim any whitespace from the beginning and end of the content. This makes it easier to pass in data from a file that ends with a newline, and avoid adding an unnecessary blank."
        }
      }
    },
    "mount": {
      "name": "MountRes",
      "kind": "mount",
      "file": "mount.go",
      "description": "MountRes is a systemd mount resource that adds/removes entries from /etc/fstab, and makes sure the defined device is mounted or unmounted accordingly. The mount point is set according to the resource's name.",
      "fields": {
        "device": {
          "name": "Device",
          "type": "str",
          "description": "Device is the location of the device or image."
        },
        "freq": {
          "name": "Freq",
          "type": "int",
          "description": "Freq is the dump frequency."
        },
        "options": {
          "name": "Options",
          "type": "map{str: str}",
          "description": "Options are mount options."
        },
        "passno": {
          "name": "PassNo",
          "type": "int",
          "description": "PassNo is the verification order."
        },
        "state": {
          "name": "State",
          "type": "str",
          "description": "State must be exists or absent. If absent, remaining fields are ignored."
        },
        "type": {
          "name": "Type",
          "type": "str",
          "description": "Type of the filesystem."
        }
      }
    },
    "msg": {
      "name": "MsgRes",
      "kind": "msg",
      "file": "msg.go",
      "description": "MsgRes is a resource that writes messages to logs.",
      "fields": {
        "body": {
          "name": "Body",
          "type": "str",
          "description": "Body is the body of the message to send."
        },
        "fields": {
          "name": "Fields",
          "type": "map{str: str}",
          "description": "Fields are the key/value pairs set in the journal if we are using it."
        },
        "journal": {
          "name": "Journal",
          "type": "bool",
          "description": "Journal should be true to enable systemd journaled (journald) output."
        },
        "priority": {
          "name": "Priority",
          "type": "str",
          "description": "Priority is the priority of the message. Currently this is one of: Emerg, Alert, Crit, Err, Warning, Notice, Info, Debug."
        },
        "syslog": {
          "name": "Syslog",
          "type": "bool",
          "description": "Syslog should be true to enable traditional syslog output. This is probably going to somewhere in `/var/log/` on your filesystem."
        }
      }
    },
    "net": {
      "name": "NetRes",
      "kind": "net",
      "file": "net.go",
      "description": "NetRes is a network interface resource based on netlink. It manages the state of a network link. Configuration is also stored in a networkd configuration file, so the network is available upon reboot. The name of the resource is the string representing the network interface name. This could be \"eth0\" for example. It supports flipping the state if you ask for it to be reversible.",
      "fields": {
        "addrs": {
          "name": "Addrs",
          "type": "[]str",
          "description": "Addrs is the list of addresses to set on the interface. They must each be in CIDR notation such as: 192.0.2.42/24 for example."
        },
        "gateway": {
          "name": "Gateway",
          "type": "str",
          "description": "Gateway represents the default route to set for the interface."
        },
        "ip_forward": {
          "name": "IPForward",
          "type": "bool",
          "description": "IPForward is a boolean that sets whether we should forward incoming packets onward when this is set. It default to unspecified, which downstream (in the systemd-networkd configuration) defaults to false."
        },
        "state": {
          "name": "State",
          "type": "str",
          "description": "State is the desired state of the interface. It can be \"up\", \"down\", or the empty string to leave that unspecified."
        }
      }
    },
    "noop": {
      "name": "NoopRes",
      "kind": "noop",
      "file": "noop.go",
      "description": "NoopRes is a no-op resource that does nothing.",
      "fields": {
        "comment": {
          "name": "Comment",
          "type": "str",
          "description": "Comment is a useless comment field that you can use however you like."
        }
      }
    },
    "nspawn": {
      "name": "NspawnRes",
      "kind": "nspawn",
      "file": "nspawn.go",
      "description": "NspawnRes is an nspawn container resource.",
      "fields": {
        "state": {
          "name": "State",
          "type": "str",
          "description": "State specifies the desired state for this resource. This must be either `running` or `stopped`."
        }
      }
    },
    "password": {
      "name": "PasswordRes",
      "kind": "password",
      "file": "password.go",
      "description": "PasswordRes is a no-op resource that returns a random password string.",
      "fields": {
        "check_recovery": {
          "name": "CheckRecovery",
          "type": "bool",
          "description": "CheckRecovery specifies that we should recover from, regenerate, and carry on casually without erroring the resource if the \"check\" facility fails. This can happen when loading a saved password from disk which is not of the expected length. In this case, we'd discard the old saved password and create a new one without erroring."
        },
        "length": {
          "name": "Length",
          "type": "int",
          "description": "Length is the number of characters to return."
        },
        "saved": {
          "name": "Saved",
          "type": "bool",
          "description": "Saved caches the password in the clear locally."
        }
      }
    },
    "pippet": {
      "name": "PippetRes",
      "kind": "pippet",
      "file": "pippet.go",
      "description": "PippetRes is a wrapper resource for puppet. It implements the functional equivalent of an exec resource that calls \"puppet resource <type> <title> <params>\", but offers superior performance through a long-running Puppet process that receives resources through a pipe (hence the name).",
      "fields": {
        "params": {
          "name": "Params",
          "type": "str",
          "description": "Params is expected to be a hash in YAML format, pairing resource parameter names with their respective values, e.g. { ensure: present }"
        },
        "title": {
          "name": "Title",
          "type": "str",
          "description": "Title is used by Puppet as the resource title. Puppet will often assign special meaning to the title, e.g. use it as the path for a file resource, or the name of a package."
        },
        "type": {
          "name": "Type",
          "type": "str",
          "description": "Type is the exact name of the wrapped Puppet resource type, e.g. \"file\", \"mount\". This needs not be a core type. It can be a type from a module. The Puppet installation local to the mgmt agent machine must be able recognize it. It has to be a native type though, as opposed to defined types from your Puppet manifest code."
        }
      }
    },
    "pkg": {
      "name": "PkgRes",
      "kind": "pkg",
      "file": "pkg.go",
      "description": "PkgRes is a package resource for packagekit.\nIt will attempt to make automatic edges with the package name, unless Meta:autoedge is false. For the unique scenario where you are adding a new package repository, and then installing something from it, you will want to disable automatic edges, or this will fail to find the package during the Init stage before mgmt can even run and create the repo! As a result, add an edge between this and the repo creation stage, and avoid graph errors!",
      "fields": {
        "allownonfree": {
          "name": "AllowNonFree",
          "type": "bool",
          "description": "AllowNonFree specifies if we want to allow nonfree packages to be found? Please see the PackageKit documentation for more information."
        },
        "allowunsupported": {
          "name": "AllowUnsupported",
          "type": "bool",
          "description": "AllowUnsupported specifies if we want to unsupported packages to be found? Please see the PackageKit documentation for more information."
        },
        "allowuntrusted": {
          "name": "AllowUntrusted",
          "type": "bool",
          "description": "AllowUntrusted specifies if we want to allow untrusted packages to be installed. Please see the PackageKit documentation for more information."
        },
        "state": {
          "name": "State",
          "type": "str",
          "description": "State determines if we want to install or uninstall the package, and what version we want to pin if any. Valid values include: installed, uninstalled, newest, and `version`, where you just put the raw version string desired."
        }
      }
    },
    "print": {
      "name": "PrintRes",
      "kind": "print",
      "file": "print.go",
      "description": "PrintRes is a resource that is useful for printing a message to the screen. It will also display a message when it receives a notification. It supports automatic grouping.",
      "fields": {
        "msg": {
          "name": "Msg",
          "type": "str",
          "description": "Msg is the message to display."
        },
        "refresh_only": {
          "name": "RefreshOnly",
          "type": "bool",
          "description": "RefreshOnly is an option that causes the message to be printed only when notified by another resource. When set to true, this resource cannot be autogrouped."
        }
      }
    },
    "schedule": {
      "name": "ScheduleRes",
      "kind": "schedule",
      "file": "schedule.go",
      "description": "ScheduleRes is a resource which starts up a \"distributed scheduler\". All nodes of the same namespace will be part of the same scheduling pool. The scheduling result can be determined by using the \"schedule\" function. If the options specified are different among peers in the same namespace, then it is undefined which options if any will get chosen.",
      "fields": {
        "max": {
          "name": "Max",
          "type": "int",
          "description": "Max is the max number of hosts to elect. If this is unspecified, then a default of 1 is used."
        },
        "namespace": {
          "name": "Namespace",
          "type": "str",
          "description": "Namespace represents the namespace key to use. If it is not specified, the Name value is used instead."
        },
        "reuse": {
          "name": "Reuse",
          "type": "bool",
          "description": "Reuse specifies that we reuse the client lease on reconnect. If reuse is false, then on host disconnect, that hosts entry will immediately expire, and the scheduler will react instantly and remove that host entry from the list. If this is true, or if the host closes without a clean shutdown, it will take the TTL number of seconds to remove the entry."
        },
        "strategy": {
          "name": "Strategy",
          "type": "str",
          "description": "Strategy is the scheduling strategy to use. If this value is nil or, undefined, then a default will be chosen automatically."
        },
        "ttl": {
          "name": "TTL",
          "type": "int",
          "description": "TTL is the time to live for added scheduling \"votes\". If this value is nil or, undefined, then a default value is used. See the `Reuse` entry for more information."
        }
      }
    },
    "svc": {
      "name": "SvcRes",
      "kind": "svc",
      "file": "svc.go",
      "description": "SvcRes is a service resource for systemd units.",
      "fields": {
        "session": {
          "name": "Session",
          "type": "bool",
          "description": "Session specifies if this is for a system service (false) or a user session specific service (true)."
        },
        "startup": {
          "name": "Startup",
          "type": "str",
          "description": "Startup specifies what should happen on startup. Values can be: enabled, disabled, and undefined (empty string)."
        },
        "state": {
          "name": "State",
          "type": "str",
          "description": "State is the desired state for this resource. Valid values include: running, stopped, and undefined (empty string)."
        }
      }
    },
    "sysctl": {
      "name": "SysctlRes",
      "kind": "sysctl",
      "file": "sysctl.go",
      "description": "SysctlRes is a resource for setting kernel parameters. /etc/sysctl.d/ and optionally blanks out the stock /etc/sysctl.conf file too.",
      "fields": {
        "path": {
          "name": "Filename",
          "type": "str",
          "description": "Filename is the full path for the persistence file which is usually read on boot. We usually use entries in the /etc/sysctl.d/ directory. By convention, they end in .conf and start with a numeric prefix and a dash. For example: /etc/sysctl.d/10-dmesg.conf for example. If this is omitted, the filename will be chosen automatically."
        },
        "persist": {
          "name": "Persist",
          "type": "bool",
          "description": "Persist specifies whether this value should be stored on disk where it will persist across reboots. It defaults to true. Keep in mind, that if this is not used, but `Runtime` is true, then the value will be restored anyways if `mgmt` runs on boot, which may be what you want anyways."
        },
        "runtime": {
          "name": "Runtime",
          "type": "bool",
          "description": "Runtime specifies whether this value should be set immediately. It defaults to true. If this is not set, then the value must be set in a file and the machine will have to reboot for the setting to take effect."
        },
        "value": {
          "name": "Value",
          "type": "str",
          "description": "Value is the string value to set. Make sure you specify it in the same format that the kernel parses it as to avoid automation \"flapping\". You can test this by writing a value to the correct /proc/sys/ path entry with `echo foo >` and then reading it back out and seeing what the \"parsed\" correct format is. You must not include the trailing newline which is present in the readback for all values."
        }
      }
    },
    "tar": {
      "name": "TarRes",
      "kind": "tar",
      "file": "tar.go",
      "description": "TarRes is a resource that archives a number of paths using tar, thus combining them into a single file. The name of the resource is the path to the resultant archive file. The input comes from a list of paths which can be either files or directories or both. Directories are added recursively of course. This uses hashes to determine if something was changed, so as a result, this may not be suitable if you can create a sha256 hash collision.",
      "fields": {
        "format": {
          "name": "Format",
          "type": "int",
          "description": "Format is the header format to use. If you change this, then the file will get rearchived. The strange thing is that it seems the header format is stored for each individual file. The available values are: const.res.tar.format.unknown, const.res.tar.format.ustar, const.res.tar.format.pax, and const.res.tar.format.gnu which have values of 0, 2, 4, and 8 respectively."
        },
        "inputs": {
          "name": "Inputs",
          "type": "[]str",
          "description": "Inputs represents the list of files to be compressed. They must each be absolute paths of either single files or directories, and as a result, each must start with a slash. Directories must end with a slash and files must not for standard behaviour. As a special exception, if you omit the trailing slash on a directory path, then this will include that directory name as a prefix. This is similar to how rsync chooses if it copies in the base directory or not."
        },
        "path": {
          "name": "Path",
          "type": "str",
          "description": "Path, which defaults to the name if not specified, represents the destination path for the compressed file being created. It must be an absolute path, and as a result must start with a slash. Since it is a file, it must not end with a slash."
        }
      }
    },
    "test": {
      "name": "TestRes",
      "kind": "test",
      "file": "test.go",
      "description": "TestRes is a resource that is mostly harmless and is used for internal tests.",
      "fields": {
        "alwaysgroup": {
          "name": "AlwaysGroup",
          "type": "bool",
          "description": ""
        },
        "anotherstr": {
          "name": "AnotherStr",
          "type": "str",
          "description": ""
        },
        "bool": {
          "name": "Bool",
          "type": "bool",
          "description": ""
        },
        "boolptr": {
          "name": "BoolPtr",
          "type": "bool",
          "description": ""
        },
        "byte": {
          "name": "Byte",
          "type": "int",
          "description": ""
        },
        "comment": {
          "name": "Comment",
          "type": "str",
          "description": ""
        },
        "comparefail": {
          "name": "CompareFail",
          "type": "bool",
          "description": ""
        },
        "expectrecv": {
          "name": "ExpectRecv",
          "type": "[]str",
          "description": ""
        },
        "float32": {
          "name": "Float32",
          "type": "float",
          "description": ""
        },
        "float64": {
          "name": "Float64",
          "type": "float",
          "description": ""
        },
        "func1": {
          "name": "Func1",
          "type": "func(0 int) str",
          "description": "Func1 passes the value 42 to the input and returns a string."
        },
        "int": {
          "name": "Int",
          "type": "int",
          "description": ""
        },
        "int16": {
          "name": "Int16",
          "type": "int",
          "description": ""
        },
        "int32": {
          "name": "Int32",
          "type": "int",
          "description": ""
        },
        "int64": {
          "name": "Int64",
          "type": "int",
          "description": ""
        },
        "int64ptr": {
          "name": "Int64Ptr",
          "type": "int",
          "description": ""
        },
        "int8": {
          "name": "Int8",
          "type": "int",
          "description": ""
        },
        "int8ptr": {
          "name": "Int8Ptr",
          "type": "int",
          "description": ""
        },
        "int8ptrptrptr": {
          "name": "Int8PtrPtrPtr",
          "type": "int",
          "description": "Int8PtrPtrPtr probably makes no sense, but is legal."
        },
        "interface": {
          "name": "Interface",
          "type": "variant",
          "description": ""
        },
        "mapintfloat": {
          "name": "MapIntFloat",
          "type": "map{int: float}",
          "description": ""
        },
        "mixedstruct": {
          "name": "MixedStruct",
          "type": "struct{somebool bool; somestr str; someint int; somefloat float}",
          "description": ""
        },
        "onlyshow": {
          "name": "OnlyShow",
          "type": "[]str",
          "description": ""
        },
        "rune": {
          "name": "Rune",
          "type": "int",
          "description": ""
        },
        "sendvalue": {
          "name": "SendValue",
          "type": "str",
          "description": ""
        },
        "slicestring": {
          "name": "SliceString",
          "type": "[]str",
          "description": ""
        },
        "str": {
          "name": "Str",
          "type": "str",
          "description": ""
        },
        "stringptr": {
          "name": "StringPtr",
          "type": "str",
          "description": ""
        },
        "uint": {
          "name": "Uint",
          "type": "int",
          "description": ""
        },
        "uint16": {
          "name": "Uint16",
          "type": "int",
          "description": ""
        },
        "uint32": {
          "name": "Uint32",
          "type": "int",
          "description": ""
        },
        "uint64": {
          "name": "Uint64",
          "type": "int",
          "description": ""
        },
        "uint8": {
          "name": "Uint8",
          "type": "int",
          "description": ""
        },
        "uint8ptr": {
          "name": "Uint8Ptr",
          "type": "int",
          "description": ""
        },
        "validatebool": {
          "name": "ValidateBool",
          "type": "bool",
          "description": ""
        },
        "validateerror": {
          "name": "ValidateError",
          "type": "str",
          "description": ""
        }
      }
    },
    "tftp:file": {
      "name": "TFTPFileRes",
      "kind": "tftp:file",
      "file": "tftp.go",
      "description": "TFTPFileRes is a file that exists within a tftp server. The name is used as the public path of the file, unless the filename field is specified, and in that case it is used instead. The way this works is that it autogroups at runtime with an existing tftp resource, and in doing so makes the file associated with this resource available for serving from that tftp server.",
      "fields": {
        "data": {
          "name": "Data",
          "type": "str",
          "description": "Data is the file content that should be used as the source for this file resource. It must not be combined with the path field."
        },
        "filename": {
          "name": "Filename",
          "type": "str",
          "description": "Filename is the name of the file this data should appear as on the tftp server."
        },
        "path": {
          "name": "Path",
          "type": "str",
          "description": "Path is the absolute path to a file that should be used as the source for this file resource. It must not be combined with the data field."
        },
        "server": {
          "name": "Server",
          "type": "str",
          "description": "Server is the name of the tftp server resource to group this into. If it is omitted, and there is only a single tftp resource, then it will be grouped into it automatically. If there is more than one main tftp resource being used, then the grouping behaviour is *undefined* when this is not specified, and it is not recommended to leave this blank!"
        }
      }
    },
    "tftp:server": {
      "name": "TFTPServerRes",
      "kind": "tftp:server",
      "file": "tftp.go",
      "description": "TFTPServerRes is a tftp server resource. It serves files, but does not actually apply any state. The name is used as the address to listen on, unless the Address field is specified, and in that case it is used instead. This resource can offer up files for serving that are specified either inline in this resource by specifying a tftp root, or as tftp:file resources which will get autogrouped into this resource at runtime. The two methods can be combined as well.",
      "fields": {
        "address": {
          "name": "Address",
          "type": "str",
          "description": "Address is the listen address to use for the tftp server. It is common to use `:69` (the standard) to listen on UDP port 69 on all addresses."
        },
        "root": {
          "name": "Root",
          "type": "str",
          "description": "Root is the root directory that we should serve files from. If it is not specified, then it is not used. Any tftp file resources will have precedence over anything in here, in case the same path exists twice."
        },
        "timeout": {
          "name": "Timeout",
          "type": "int",
          "description": "Timeout is the timeout in seconds to use for server connections."
        }
      }
    },
    "timer": {
      "name": "TimerRes",
      "kind": "timer",
      "file": "timer.go",
      "description": "TimerRes is a timer resource for time based events. It outputs an event every interval seconds.",
      "fields": {
        "interval": {
          "name": "Interval",
          "type": "int",
          "description": "Interval between runs in seconds."
        }
      }
    },
    "user": {
      "name": "UserRes",
      "kind": "user",
      "file": "user.go",
      "description": "UserRes is a user account resource.",
      "fields": {
        "allowduplicateuid": {
          "name": "AllowDuplicateUID",
          "type": "bool",
          "description": "AllowDuplicateUID is needed for a UID to be non-unique. This is rare but happens if you want more than one username to access the resources of the same UID. See the --non-unique flag in `useradd`."
        },
        "gid": {
          "name": "GID",
          "type": "int",
          "description": "GID of the user's primary group."
        },
        "group": {
          "name": "Group",
          "type": "str",
          "description": "Group is the name of the user's primary group."
        },
        "groups": {
          "name": "Groups",
          "type": "[]str",
          "description": "Groups are a list of supplemental groups."
        },
        "homedir": {
          "name": "HomeDir",
          "type": "str",
          "description": "HomeDir is the path to the user's home directory."
        },
        "shell": {
          "name": "Shell",
          "type": "str",
          "description": "Shell is the users login shell. Many options may exist in the `/etc/shells` file. If you set this, you most likely want to pick `/bin/bash` or `/usr/sbin/nologin`."
        },
        "state": {
          "name": "State",
          "type": "str",
          "description": "State is either exists or absent."
        },
        "uid": {
          "name": "UID",
          "type": "int",
          "description": "UID specifies the usually unique user ID. It must be unique unless AllowDuplicateUID is true."
        }
      }
    },
    "value": {
      "name": "ValueRes",
      "kind": "value",
      "file": "value.go",
      "description": "ValueRes is a no-op resource that accepts a value normally or via send/recv and it sends it via send/recv as well.\ntemporary placeholder value set or we'll get an invalid value error. This can be fixed eventually when we expand the resource API. See the Default method of this resource for more information.",
      "fields": {
        "any": {
          "name": "Any",
          "type": "variant",
          "description": "Any is an arbitrary value to store in this resource. It can also be sent via send/recv and received by the same mechanism as well. The received value overwrites this value for the lifetime of the resource. It is interface{} because it can hold any type. It has pointer because it is only set if an actual value exists."
        }
      }
    },
    "virt": {
      "name": "VirtRes",
      "kind": "virt",
      "file": "virt.go",
      "description": "VirtRes is a libvirt resource. A transient virt resource, which has its state set to `shutoff` is one which does not exist. The parallel equivalent is a file resource which removes a particular path.",
      "fields": {
        "auth": {
          "name": "Auth",
          "type": "struct{username str; password str}",
          "description": "Auth points to the libvirt credentials to use if any are necessary."
        },
        "boot": {
          "name": "Boot",
          "type": "[]str",
          "description": "Boot is the boot order. Values are `fd`, `hd`, `cdrom` and `network`."
        },
        "cdrom": {
          "name": "CDRom",
          "type": "[]struct{source str; type str}",
          "description": "CdRom is the list of cdrom devices to include."
        },
        "cpus": {
          "name": "CPUs",
          "type": "int",
          "description": "CPUs is the desired cpu count of the machine."
        },
        "disk": {
          "name": "Disk",
          "type": "[]struct{source str; type str}",
          "description": "Disk is the list of disk devices to include."
        },
        "filesystem": {
          "name": "Filesystem",
          "type": "[]struct{access str; source str; target str; read_only bool}",
          "description": "Filesystem is the list of file system devices to include."
        },
        "hotcpus": {
          "name": "HotCPUs",
          "type": "bool",
          "description": "HotCPUs specifies whether we can hot plug and unplug cpus."
        },
        "maxcpus": {
          "name": "MaxCPUs",
          "type": "int",
          "description": "MaxCPUs is the maximum number of cpus allowed in the machine. You need to set this so that on boot the `hardware` knows how many cpu `slots` it might need to make room for."
        },
        "memory": {
          "name": "Memory",
          "type": "int",
          "description": "Memory is the size in KBytes of memory to include in the machine."
        },
        "network": {
          "name": "Network",
          "type": "[]struct{name str; mac str}",
          "description": "Network is the list of network devices to include."
        },
        "osinit": {
          "name": "OSInit",
          "type": "str",
          "description": "OSInit is the init used by lxc."
        },
        "restartondiverge": {
          "name": "RestartOnDiverge",
          "type": "str",
          "description": "RestartOnDiverge is the restart policy, and can be: `ignore`, `ifneeded` or `error`."
        },
        "restartonrefresh": {
          "name": "RestartOnRefresh",
          "type": "bool",
          "description": "RestartOnRefresh specifies if we restart on refresh signal."
        },
        "state": {
          "name": "State",
          "type": "str",
          "description": "State is the desired vm state. Possible values include: `running`, `paused` and `shutoff`."
        },
        "transient": {
          "name": "Transient",
          "type": "bool",
          "description": "Transient is whether the vm is defined (false) or undefined (true)."
        },
        "uri": {
          "name": "URI",
          "type": "str",
          "description": "URI is the libvirt connection URI, eg: `qemu:///session`."
        }
      }
    },
    "virt:builder": {
      "name": "VirtBuilderRes",
      "kind": "virt:builder",
      "file": "virt_builder.go",
      "description": "VirtBuilderRes is a resource for building virtual machine images. It is based on the amazing virt-builder tool which is part of the guestfs suite of tools.",
      "fields": {
        "arch": {
          "name": "Arch",
          "type": "str",
          "description": "Arch specifies the CPU architecture to use for this machine. You will need to pick from the output of `virt-builder --list`. Note that not all OSVersion+Arch combinations may exist."
        },
        "bootstrap": {
          "name": "Bootstrap",
          "type": "bool",
          "description": "Bootstrap can be set to false to disable any automatic bootstrapping of running the mgmt binary on first boot. If this is set, we will attempt to copy the mgmt binary in, and then run it. This also adds additional packages to install which are needed to bootstrap mgmt. This defaults to true."
        },
        "copy_in": {
          "name": "CopyIn",
          "type": "[]struct{path str; dest str}",
          "description": "CopyIn is a list of local paths to copy into the machine dest. The dest directory must exist for this to work. Use Mkdir if you need to make a directory, since that step happens earlier. All paths must be absolute, and directories must end with a slash. This happens before the RunCmd stage in case you want to create something to be used there."
        },
        "firstboot_cmd": {
          "name": "FirstbootCmd",
          "type": "[]str",
          "description": "FirstbootCmd is a sequence of commands + args (one set per list item) to run once on first boot. consistency between this platform and other platforms that might not support the excellent libguestfs version of those scripts. (Make the logs look more homogeneous.)"
        },
        "format": {
          "name": "Format",
          "type": "str",
          "description": "Format is the disk image format. You likely want \"raw\" or \"qcow2\"."
        },
        "hostname": {
          "name": "Hostname",
          "type": "str",
          "description": "Hostname for the new machine."
        },
        "log_output": {
          "name": "LogOutput",
          "type": "bool",
          "description": "LogOutput logs the output of running this command to a file in the special $vardir directory. It defaults to true. Keep in mind that if you let virt-builder choose the password randomly, it will be output in these logs in cleartext!"
        },
        "mkdir": {
          "name": "Mkdir",
          "type": "[]str",
          "description": "Mkdir creates these directories in the guests. This happens before CopyIn runs. Directories must be absolute and end with a slash. Any intermediate directories are created, similar to how `mkdir -p` works."
        },
        "no_setup": {
          "name": "NoSetup",
          "type": "bool",
          "description": "NoSetup can be set to true to disable trying to install the package for the virt-builder binary."
        },
        "os_version": {
          "name": "OSVersion",
          "type": "str",
          "description": "OSVersion specifies which distro and version to use for installation. You will need to pick from the output of `virt-builder --list`."
        },
        "output": {
          "name": "Output",
          "type": "str",
          "description": "Output is the full absolute file path where the image will be created. If this file exists, then no action will be performed. when we can find a safe way to do so."
        },
        "packages": {
          "name": "Packages",
          "type": "[]str",
          "description": "Packages is the list of packages to install. If Bootstrap is true, then it will add additional packages that we install if needed."
        },
        "root_password_selector": {
          "name": "RootPasswordSelector",
          "type": "str",
          "description": "RootPasswordSelector is a string in the virt-builder format. See the manual page \"USERS AND PASSWORDS\" section for more information."
        },
        "root_ssh_inject": {
          "name": "RootSSHInject",
          "type": "bool",
          "description": "RootSSHInject disables installing the root ssh key into the new vm. If one is not present, then nothing is done.\tThis defaults to true."
        },
        "run_cmd": {
          "name": "RunCmd",
          "type": "[]str",
          "description": "RunCmd is a sequence of commands + args (one set per list item) to run in the build environment. These happen after the CopyIn stage."
        },
        "seeds": {
          "name": "Seeds",
          "type": "[]str",
          "description": "Seeds is a list of default etcd client endpoints to connect to. If you specify this, you must also set Bootstrap to true. These should likely be http URL's like: http://127.0.0.1:2379 or similar."
        },
        "selinux_relabel": {
          "name": "SelinuxRelabel",
          "type": "bool",
          "description": "SelinuxRelabel specifies that we should do an selinux relabel on the final image. This defaults to true."
        },
        "size": {
          "name": "Size",
          "type": "int",
          "description": "Size is the disk size of the new virtual machine in bytes."
        },
        "ssh_keys": {
          "name": "SSHKeys",
          "type": "[]struct{user str; type str; key str; comment str}",
          "description": "SSHKeys is a list of additional keys to add to the machine. This is not a map because you may wish to add more than one to that user account."
        },
        "tweaks": {
          "name": "Tweaks",
          "type": "bool",
          "description": "Tweaks adds some random tweaks to work around common bugs. This defaults to true. It also does some useful things that most may find desirable."
        },
        "update": {
          "name": "Update",
          "type": "bool",
          "description": "Update specifies that we should update the installed packages during image build. This defaults to true."
        }
      }
    }
  },
  "functions": {
    "concat": {
      "name": "Concat",
      "package": "",
      "func": "concat",
      "file": "concat.go",
      "description": "Concat concatenates two strings together.",
      "signature": "func(a str, b str) str"
    },
    "contains": {
      "name": "Contains",
      "package": "",
      "func": "contains",
      "file": "contains.go",
      "description": "Contains checks if a needle exists in a haystack, which is a list.",
      "signature": "func(needle ?1, haystack []?1) bool"
    },
    "convert.format_bool": {
      "name": "FormatBool",
      "package": "convert",
      "func": "format_bool",
      "file": "convert/format_bool.go",
      "description": "FormatBool converts a boolean to a string representation that can be consumed by ParseBool. This value will be `\"true\"` or `\"false\"`.",
      "signature": "func(a bool) str"
    },
    "convert.int_to_str": {
      "name": "IntToStr",
      "package": "convert",
      "func": "int_to_str",
      "file": "convert/to_str.go",
      "description": "IntToStr converts an integer to a string.",
      "signature": "func(a int) str"
    },
    "convert.parse_bool": {
      "name": "ParseBool",
      "package": "convert",
      "func": "parse_bool",
      "file": "convert/parse_bool.go",
      "description": "ParseBool parses a bool string and returns a boolean. It errors if you pass it an invalid value. Valid values match what is accepted by the golang strconv.ParseBool function. It's recommended to use the strings `true` or `false` if you are undecided about what string representation to choose.",
      "signature": "func(a str) bool"
    },
    "convert.str_to_int": {
      "name": "StrToInt",
      "package": "convert",
      "func": "str_to_int",
      "file": "convert/str_to_int.go",
      "description": "StrToInt converts a string to an integer.",
      "signature": "func(a str) int"
    },
    "convert.to_float": {
      "name": "ToFloat",
      "package": "convert",
      "func": "to_float",
      "file": "convert/to_float.go",
      "description": "ToFloat converts an integer to a float.",
      "signature": "func(a int) float"
    },
    "convert.to_int": {
      "name": "ToInt",
      "package": "convert",
      "func": "to_int",
      "file": "convert/to_int.go",
      "description": "ToInt converts a float to an integer.",
      "signature": "func(a float) int"
    },
    "datetime.format": {
      "name": "Format",
      "package": "datetime",
      "func": "format",
      "file": "datetime/format.go",
      "description": "Format returns returns a textual representation of the input time. The format has to be defined like specified by the golang \"time\" package. The time is the number of seconds since the epoch, and matches what comes from our Now function. Golang documentation: https://golang.org/pkg/time/#Time.Format",
      "signature": "func(a int, b str) str"
    },
    "datetime.hour": {
      "name": "Hour",
      "package": "datetime",
      "func": "hour",
      "file": "datetime/hour.go",
      "description": "Hour returns the hour of the day corresponding to the input time. The time is the number of seconds since the epoch, and matches what comes from our Now function.",
      "signature": "func(a int) int"
    },
    "datetime.now": {
      "name": "Now",
      "package": "datetime",
      "func": "now",
      "file": "datetime/now.go",
      "description": "Now is a fact which returns the current date and time.",
      "signature": "func() int"
    },
    "datetime.print": {
      "name": "Print",
      "package": "datetime",
      "func": "print",
      "file": "datetime/print.go",
      "description": "Print takes an epoch int and returns a string in unix format.",
      "signature": "func(a int) str"
    },
    "datetime.str_now": {
      "name": "StrNow",
      "package": "datetime",
      "func": "str_now",
      "file": "datetime/str_now.go",
      "description": "StrNow is a fact which returns the current date and time.",
      "signature": "func() str"
    },
    "datetime.weekday": {
      "name": "Weekday",
      "package": "datetime",
      "func": "weekday",
      "file": "datetime/weekday.go",
      "description": "Weekday returns the lowercased day of the week corresponding to the input time. The time is the number of seconds since the epoch, and matches what comes from our Now function.",
      "signature": "func(a int) str"
    },
    "deploy.abspath": {
      "name": "AbsPathFunc",
      "package": "deploy",
      "func": "abspath",
      "file": "deploy/abspath.go",
      "description": "AbsPathFunc is a function that returns the absolute, full path in the deploy from an input path that is relative to the calling file. If you pass it an empty string, you'll just get the absolute deploy directory path that you're in.",
      "signature": "func(path str) str"
    },
    "deploy.binary_path": {
      "name": "BinaryPath",
      "package": "deploy",
      "func": "binary_path",
      "file": "deploy/binary.go",
      "description": "BinaryPath returns the path to the binary of this program. This is useful for bootstrapping new machines when we want to get the path to copy it over from.",
      "signature": "func() str"
    },
    "deploy.bootstrap_packages": {
      "name": "BootstrapPackages",
      "package": "deploy",
      "func": "bootstrap_packages",
      "file": "deploy/bootstrap_packages.go",
      "description": "BootstrapPackages returns the list of packages corresponding to the distro for bootstrapping new machines which will need these installed before they can run mgmt.",
      "signature": "func(0 str) []str"
    },
    "deploy.readfile": {
      "name": "ReadFileFunc",
      "package": "deploy",
      "func": "readfile",
      "file": "deploy/readfile.go",
      "description": "ReadFileFunc is a function that reads the full contents from a file in our deploy. The file contents can only change with a new deploy, so this is static. Please note that this is different from the readfile function in the os package.",
      "signature": "func(filename str) str"
    },
    "deploy.readfileabs": {
      "name": "ReadFileAbsFunc",
      "package": "deploy",
      "func": "readfileabs",
      "file": "deploy/readfileabs.go",
      "description": "ReadFileAbsFunc is a function that reads the full contents from a file in our deploy. The file contents can only change with a new deploy, so this is static. In particular, this takes an absolute path relative to the root deploy. In general, you should use `deploy.readfile` instead. Please note that this is different from the readfile function in the os package.",
      "signature": "func(filename str) str"
    },
    "embedded/provisioner.cli_arch": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_arch",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() str"
    },
    "embedded/provisioner.cli_bios": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_bios",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() bool"
    },
    "embedded/provisioner.cli_bmc_uri": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_bmc_uri",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() str"
    },
    "embedded/provisioner.cli_distro": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_distro",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() str"
    },
    "embedded/provisioner.cli_dns": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_dns",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() []str"
    },
    "embedded/provisioner.cli_firewalld": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_firewalld",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() bool"
    },
    "embedded/provisioner.cli_flavour": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_flavour",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() str"
    },
    "embedded/provisioner.cli_handoff_code": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_handoff_code",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() str"
    },
    "embedded/provisioner.cli_handoff_exec": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_handoff_exec",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() str"
    },
    "embedded/provisioner.cli_handoff_hostname": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_handoff_hostname",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() str"
    },
    "embedded/provisioner.cli_handoff_module_path": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_handoff_module_path",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() str"
    },
    "embedded/provisioner.cli_interface": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_interface",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() str"
    },
    "embedded/provisioner.cli_ip": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_ip",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() str"
    },
    "embedded/provisioner.cli_luks": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_luks",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() bool"
    },
    "embedded/provisioner.cli_mac": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_mac",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() str"
    },
    "embedded/provisioner.cli_mirror": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_mirror",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() str"
    },
    "embedded/provisioner.cli_network": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_network",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() str"
    },
    "embedded/provisioner.cli_packages": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_packages",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() []str"
    },
    "embedded/provisioner.cli_part": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_part",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() str"
    },
    "embedded/provisioner.cli_password": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_password",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() str"
    },
    "embedded/provisioner.cli_prefix": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_prefix",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() str"
    },
    "embedded/provisioner.cli_router": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_router",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() str"
    },
    "embedded/provisioner.cli_rsync": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_rsync",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() str"
    },
    "embedded/provisioner.cli_version": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "cli_version",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() str"
    },
    "embedded/provisioner.onlyunify": {
      "name": "func1",
      "package": "embedded/provisioner",
      "func": "onlyunify",
      "file": "embedded/provisioner/provisioner.go",
      "description": "",
      "signature": "func() bool"
    },
    "example.answer": {
      "name": "TheAnswerToLifeTheUniverseAndEverything",
      "package": "example",
      "func": "answer",
      "file": "example/answer.go",
      "description": "TheAnswerToLifeTheUniverseAndEverything returns the Answer to Life, the Universe and Everything.",
      "signature": "func() int"
    },
    "example.errorbool": {
      "name": "ErrorBool",
      "package": "example",
      "func": "errorbool",
      "file": "example/errorbool.go",
      "description": "ErrorBool causes this function to error if you pass it true. Otherwise it returns a string reminding you how to use it.",
      "signature": "func(a bool) str"
    },
    "example.flipflop": {
      "name": "FlipFlop",
      "package": "example",
      "func": "flipflop",
      "file": "example/flipflop.go",
      "description": "FlipFlop is a fact which flips a bool repeatedly. This is an example fact and is not meant for serious computing. This would be better served by a flip function which you could specify an interval for.",
      "signature": "func() bool"
    },
    "example.int2str": {
      "name": "Int2Str",
      "package": "example",
      "func": "int2str",
      "file": "example/int2str.go",
      "description": "Int2Str takes an int, and returns it as a string.",
      "signature": "func(a int) str"
    },
    "example.plus": {
      "name": "Plus",
      "package": "example",
      "func": "plus",
      "file": "example/plus.go",
      "description": "Plus returns y + z.",
      "signature": "func(y str, z str) str"
    },
    "example.str2int": {
      "name": "Str2Int",
      "package": "example",
      "func": "str2int",
      "file": "example/str2int.go",
      "description": "Str2Int takes an str, and returns it as an int. If it can't convert it, it returns 0.",
      "signature": "func(a str) int"
    },
    "example.vumeter": {
      "name": "VUMeterFunc",
      "package": "example",
      "func": "vumeter",
      "file": "example/vumeter.go",
      "description": "VUMeterFunc is a gimmic function to display a vu meter from the microphone.",
      "signature": "func(symbol str, multiplier int, peak float) str"
    },
    "example/nested.hello": {
      "name": "Hello",
      "package": "example/nested",
      "func": "hello",
      "file": "example/nested/hello.go",
      "description": "Hello returns some string. This is just to test nesting.",
      "signature": "func() str"
    },
    "fmt.printf": {
      "name": "PrintfFunc",
      "package": "fmt",
      "func": "printf",
      "file": "fmt/printf.go",
      "description": "PrintfFunc is a static polymorphic function that compiles a format string and returns the output as a string. It bases its output on the values passed in to it. It examines the type of the arguments at compile time and then determines the static function signature by parsing the format string and using that to determine the final function signature. One consequence of this is that the format string must be a static string which is known at compile time. This is reasonable, because if it was a reactive, changing string, then we could expect the type signature to change, which is not allowed in our statically typed language."
    },
    "golang.template": {
      "name": "TemplateFunc",
      "package": "golang",
      "func": "template",
      "file": "golang/template.go",
      "description": "TemplateFunc is a static polymorphic function that compiles a template and returns the output as a string. It bases its output on the values passed in to it. It examines the type of the second argument (the input data vars) at compile time and then determines the static functions signature by including that in the overall signature. but only if they are not pure. We currently only use simple, pure functions."
    },
    "golang/html.escape_string": {
      "name": "HTMLEscapeString",
      "package": "golang/html",
      "func": "escape_string",
      "file": "https://pkg.go.dev/html#HTMLEscapeString",
      "description": "HTMLEscapeString is an autogenerated function. func EscapeString(s string) string EscapeString escapes special characters like \"<\" to become \"&lt;\". It escapes only five such characters: <, >, &, ' and \". UnescapeString(EscapeString(s)) == s always holds, but the converse isn't always true.",
      "signature": "func(s str) str"
    },
    "golang/html.unescape_string": {
      "name": "HTMLUnescapeString",
      "package": "golang/html",
      "func": "unescape_string",
      "file": "https://pkg.go.dev/html#HTMLUnescapeString",
      "description": "HTMLUnescapeString is an autogenerated function. func UnescapeString(s string) string UnescapeString unescapes entities like \"&lt;\" to become \"<\". It unescapes a larger range of entities than EscapeString escapes. For example, \"&aacute;\" unescapes to \"á\", as does \"&#225;\" and \"&#xE1;\". UnescapeString(EscapeString(s)) == s always holds, but the converse isn't always true.",
      "signature": "func(s str) str"
    },
    "golang/math.abs": {
      "name": "MathAbs",
      "package": "golang/math",
      "func": "abs",
      "file": "https://pkg.go.dev/math#Abs",
      "description": "MathAbs is an autogenerated function. func Abs(x float64) float64 Abs returns the absolute value of x.\nSpecial cases are:\nAbs(±Inf) = +Inf Abs(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.acos": {
      "name": "MathAcos",
      "package": "golang/math",
      "func": "acos",
      "file": "https://pkg.go.dev/math#Acos",
      "description": "MathAcos is an autogenerated function. func Acos(x float64) float64 Acos returns the arccosine, in radians, of x.\nSpecial case is:\nAcos(x) = NaN if x < -1 or x > 1",
      "signature": "func(x float) float"
    },
    "golang/math.acosh": {
      "name": "MathAcosh",
      "package": "golang/math",
      "func": "acosh",
      "file": "https://pkg.go.dev/math#Acosh",
      "description": "MathAcosh is an autogenerated function. func Acosh(x float64) float64 Acosh returns the inverse hyperbolic cosine of x.\nSpecial cases are:\nAcosh(+Inf) = +Inf Acosh(x) = NaN if x < 1 Acosh(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.asin": {
      "name": "MathAsin",
      "package": "golang/math",
      "func": "asin",
      "file": "https://pkg.go.dev/math#Asin",
      "description": "MathAsin is an autogenerated function. func Asin(x float64) float64 Asin returns the arcsine, in radians, of x.\nSpecial cases are:\nAsin(±0) = ±0 Asin(x) = NaN if x < -1 or x > 1",
      "signature": "func(x float) float"
    },
    "golang/math.asinh": {
      "name": "MathAsinh",
      "package": "golang/math",
      "func": "asinh",
      "file": "https://pkg.go.dev/math#Asinh",
      "description": "MathAsinh is an autogenerated function. func Asinh(x float64) float64 Asinh returns the inverse hyperbolic sine of x.\nSpecial cases are:\nAsinh(±0) = ±0 Asinh(±Inf) = ±Inf Asinh(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.atan": {
      "name": "MathAtan",
      "package": "golang/math",
      "func": "atan",
      "file": "https://pkg.go.dev/math#Atan",
      "description": "MathAtan is an autogenerated function. func Atan(x float64) float64 Atan returns the arctangent, in radians, of x.\nSpecial cases are:\nAtan(±0) = ±0 Atan(±Inf) = ±Pi/2",
      "signature": "func(x float) float"
    },
    "golang/math.atan_2": {
      "name": "MathAtan2",
      "package": "golang/math",
      "func": "atan_2",
      "file": "https://pkg.go.dev/math#Atan2",
      "description": "MathAtan2 is an autogenerated function. func Atan2(y float64, x float64) float64 Atan2 returns the arc tangent of y/x, using the signs of the two to determine the quadrant of the return value.\nSpecial cases are (in order):\nAtan2(y, NaN) = NaN Atan2(NaN, x) = NaN Atan2(+0, x>=0) = +0 Atan2(-0, x>=0) = -0 Atan2(+0, x<=-0) = +Pi Atan2(-0, x<=-0) = -Pi Atan2(y>0, 0) = +Pi/2 Atan2(y<0, 0) = -Pi/2 Atan2(+Inf, +Inf) = +Pi/4 Atan2(-Inf, +Inf) = -Pi/4 Atan2(+Inf, -Inf) = 3Pi/4 Atan2(-Inf, -Inf) = -3Pi/4 Atan2(y, +Inf) = 0 Atan2(y>0, -Inf) = +Pi Atan2(y<0, -Inf) = -Pi Atan2(+Inf, x) = +Pi/2 Atan2(-Inf, x) = -Pi/2",
      "signature": "func(y float, x float) float"
    },
    "golang/math.atanh": {
      "name": "MathAtanh",
      "package": "golang/math",
      "func": "atanh",
      "file": "https://pkg.go.dev/math#Atanh",
      "description": "MathAtanh is an autogenerated function. func Atanh(x float64) float64 Atanh returns the inverse hyperbolic tangent of x.\nSpecial cases are:\nAtanh(1) = +Inf Atanh(±0) = ±0 Atanh(-1) = -Inf Atanh(x) = NaN if x < -1 or x > 1 Atanh(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.cbrt": {
      "name": "MathCbrt",
      "package": "golang/math",
      "func": "cbrt",
      "file": "https://pkg.go.dev/math#Cbrt",
      "description": "MathCbrt is an autogenerated function. func Cbrt(x float64) float64 Cbrt returns the cube root of x.\nSpecial cases are:\nCbrt(±0) = ±0 Cbrt(±Inf) = ±Inf Cbrt(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.ceil": {
      "name": "MathCeil",
      "package": "golang/math",
      "func": "ceil",
      "file": "https://pkg.go.dev/math#Ceil",
      "description": "MathCeil is an autogenerated function. func Ceil(x float64) float64 Ceil returns the least integer value greater than or equal to x.\nSpecial cases are:\nCeil(±0) = ±0 Ceil(±Inf) = ±Inf Ceil(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.copysign": {
      "name": "MathCopysign",
      "package": "golang/math",
      "func": "copysign",
      "file": "https://pkg.go.dev/math#Copysign",
      "description": "MathCopysign is an autogenerated function. func Copysign(f float64, sign float64) float64 Copysign returns a value with the magnitude of f and the sign of sign.",
      "signature": "func(f float, sign float) float"
    },
    "golang/math.cos": {
      "name": "MathCos",
      "package": "golang/math",
      "func": "cos",
      "file": "https://pkg.go.dev/math#Cos",
      "description": "MathCos is an autogenerated function. func Cos(x float64) float64 Cos returns the cosine of the radian argument x.\nSpecial cases are:\nCos(±Inf) = NaN Cos(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.cosh": {
      "name": "MathCosh",
      "package": "golang/math",
      "func": "cosh",
      "file": "https://pkg.go.dev/math#Cosh",
      "description": "MathCosh is an autogenerated function. func Cosh(x float64) float64 Cosh returns the hyperbolic cosine of x.\nSpecial cases are:\nCosh(±0) = 1 Cosh(±Inf) = +Inf Cosh(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.dim": {
      "name": "MathDim",
      "package": "golang/math",
      "func": "dim",
      "file": "https://pkg.go.dev/math#Dim",
      "description": "MathDim is an autogenerated function. func Dim(x float64, y float64) float64 Dim returns the maximum of x-y or 0.\nSpecial cases are:\nDim(+Inf, +Inf) = NaN Dim(-Inf, -Inf) = NaN Dim(x, NaN) = Dim(NaN, x) = NaN",
      "signature": "func(x float, y float) float"
    },
    "golang/math.erf": {
      "name": "MathErf",
      "package": "golang/math",
      "func": "erf",
      "file": "https://pkg.go.dev/math#Erf",
      "description": "MathErf is an autogenerated function. func Erf(x float64) float64 Erf returns the error function of x.\nSpecial cases are:\nErf(+Inf) = 1 Erf(-Inf) = -1 Erf(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.erfc": {
      "name": "MathErfc",
      "package": "golang/math",
      "func": "erfc",
      "file": "https://pkg.go.dev/math#Erfc",
      "description": "MathErfc is an autogenerated function. func Erfc(x float64) float64 Erfc returns the complementary error function of x.\nSpecial cases are:\nErfc(+Inf) = 0 Erfc(-Inf) = 2 Erfc(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.erfcinv": {
      "name": "MathErfcinv",
      "package": "golang/math",
      "func": "erfcinv",
      "file": "https://pkg.go.dev/math#Erfcinv",
      "description": "MathErfcinv is an autogenerated function. func Erfcinv(x float64) float64 Erfcinv returns the inverse of [Erfc](x).\nSpecial cases are:\nErfcinv(0) = +Inf Erfcinv(2) = -Inf Erfcinv(x) = NaN if x < 0 or x > 2 Erfcinv(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.erfinv": {
      "name": "MathErfinv",
      "package": "golang/math",
      "func": "erfinv",
      "file": "https://pkg.go.dev/math#Erfinv",
      "description": "MathErfinv is an autogenerated function. func Erfinv(x float64) float64 Erfinv returns the inverse error function of x.\nSpecial cases are:\nErfinv(1) = +Inf Erfinv(-1) = -Inf Erfinv(x) = NaN if x < -1 or x > 1 Erfinv(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.exp": {
      "name": "MathExp",
      "package": "golang/math",
      "func": "exp",
      "file": "https://pkg.go.dev/math#Exp",
      "description": "MathExp is an autogenerated function. func Exp(x float64) float64 Exp returns e**x, the base-e exponential of x.\nSpecial cases are:\nExp(+Inf) = +Inf Exp(NaN) = NaN\nVery large values overflow to 0 or +Inf. Very small values underflow to 1.",
      "signature": "func(x float) float"
    },
    "golang/math.exp_2": {
      "name": "MathExp2",
      "package": "golang/math",
      "func": "exp_2",
      "file": "https://pkg.go.dev/math#Exp2",
      "description": "MathExp2 is an autogenerated function. func Exp2(x float64) float64 Exp2 returns 2**x, the base-2 exponential of x.\nSpecial cases are the same as [Exp].",
      "signature": "func(x float) float"
    },
    "golang/math.expm_1": {
      "name": "MathExpm1",
      "package": "golang/math",
      "func": "expm_1",
      "file": "https://pkg.go.dev/math#Expm1",
      "description": "MathExpm1 is an autogenerated function. func Expm1(x float64) float64 Expm1 returns e**x - 1, the base-e exponential of x minus 1. It is more accurate than [Exp](x) - 1 when x is near zero.\nSpecial cases are:\nExpm1(+Inf) = +Inf Expm1(-Inf) = -1 Expm1(NaN) = NaN\nVery large values overflow to -1 or +Inf.",
      "signature": "func(x float) float"
    },
    "golang/math.floor": {
      "name": "MathFloor",
      "package": "golang/math",
      "func": "floor",
      "file": "https://pkg.go.dev/math#Floor",
      "description": "MathFloor is an autogenerated function. func Floor(x float64) float64 Floor returns the greatest integer value less than or equal to x.\nSpecial cases are:\nFloor(±0) = ±0 Floor(±Inf) = ±Inf Floor(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.fma": {
      "name": "MathFMA",
      "package": "golang/math",
      "func": "fma",
      "file": "https://pkg.go.dev/math#FMA",
      "description": "MathFMA is an autogenerated function. func FMA(x float64, y float64, z float64) float64 FMA returns x * y + z, computed with only one rounding. (That is, FMA returns the fused multiply-add of x, y, and z.)",
      "signature": "func(x float, y float, z float) float"
    },
    "golang/math.gamma": {
      "name": "MathGamma",
      "package": "golang/math",
      "func": "gamma",
      "file": "https://pkg.go.dev/math#Gamma",
      "description": "MathGamma is an autogenerated function. func Gamma(x float64) float64 Gamma returns the Gamma function of x.\nSpecial cases are:\nGamma(+Inf) = +Inf Gamma(+0) = +Inf Gamma(-0) = -Inf Gamma(x) = NaN for integer x < 0 Gamma(-Inf) = NaN Gamma(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.hypot": {
      "name": "MathHypot",
      "package": "golang/math",
      "func": "hypot",
      "file": "https://pkg.go.dev/math#Hypot",
      "description": "MathHypot is an autogenerated function. func Hypot(p float64, q float64) float64 Hypot returns [Sqrt](p*p + q*q), taking care to avoid unnecessary overflow and underflow.\nSpecial cases are:\nHypot(±Inf, q) = +Inf Hypot(p, ±Inf) = +Inf Hypot(NaN, q) = NaN Hypot(p, NaN) = NaN",
      "signature": "func(p float, q float) float"
    },
    "golang/math.ilogb": {
      "name": "MathIlogb",
      "package": "golang/math",
      "func": "ilogb",
      "file": "https://pkg.go.dev/math#Ilogb",
      "description": "MathIlogb is an autogenerated function. func Ilogb(x float64) int Ilogb returns the binary exponent of x as an integer.\nSpecial cases are:\nIlogb(±Inf) = MaxInt32 Ilogb(0) = MinInt32 Ilogb(NaN) = MaxInt32",
      "signature": "func(x float) int"
    },
    "golang/math.inf": {
      "name": "MathInf",
      "package": "golang/math",
      "func": "inf",
      "file": "https://pkg.go.dev/math#Inf",
      "description": "MathInf is an autogenerated function. func Inf(sign int) float64 Inf returns positive infinity if sign >= 0, negative infinity if sign < 0.",
      "signature": "func(sign int) float"
    },
    "golang/math.is_inf": {
      "name": "MathIsInf",
      "package": "golang/math",
      "func": "is_inf",
      "file": "https://pkg.go.dev/math#IsInf",
      "description": "MathIsInf is an autogenerated function. func IsInf(f float64, sign int) bool IsInf reports whether f is an infinity, according to sign. If sign > 0, IsInf reports whether f is positive infinity. If sign < 0, IsInf reports whether f is negative infinity. If sign == 0, IsInf reports whether f is either infinity.",
      "signature": "func(f float, sign int) bool"
    },
    "golang/math.is_na_n": {
      "name": "MathIsNaN",
      "package": "golang/math",
      "func": "is_na_n",
      "file": "https://pkg.go.dev/math#IsNaN",
      "description": "MathIsNaN is an autogenerated function. func IsNaN(f float64) (is bool) IsNaN reports whether f is an IEEE 754 “not-a-number” value.",
      "signature": "func(f float) bool"
    },
    "golang/math.j_0": {
      "name": "MathJ0",
      "package": "golang/math",
      "func": "j_0",
      "file": "https://pkg.go.dev/math#J0",
      "description": "MathJ0 is an autogenerated function. func J0(x float64) float64 J0 returns the order-zero Bessel function of the first kind.\nSpecial cases are:\nJ0(±Inf) = 0 J0(0) = 1 J0(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.j_1": {
      "name": "MathJ1",
      "package": "golang/math",
      "func": "j_1",
      "file": "https://pkg.go.dev/math#J1",
      "description": "MathJ1 is an autogenerated function. func J1(x float64) float64 J1 returns the order-one Bessel function of the first kind.\nSpecial cases are:\nJ1(±Inf) = 0 J1(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.jn": {
      "name": "MathJn",
      "package": "golang/math",
      "func": "jn",
      "file": "https://pkg.go.dev/math#Jn",
      "description": "MathJn is an autogenerated function. func Jn(n int, x float64) float64 Jn returns the order-n Bessel function of the first kind.\nSpecial cases are:\nJn(n, ±Inf) = 0 Jn(n, NaN) = NaN",
      "signature": "func(n int, x float) float"
    },
    "golang/math.ldexp": {
      "name": "MathLdexp",
      "package": "golang/math",
      "func": "ldexp",
      "file": "https://pkg.go.dev/math#Ldexp",
      "description": "MathLdexp is an autogenerated function. func Ldexp(frac float64, exp int) float64 Ldexp is the inverse of [Frexp]. It returns frac × 2**exp.\nSpecial cases are:\nLdexp(±0, exp) = ±0 Ldexp(±Inf, exp) = ±Inf Ldexp(NaN, exp) = NaN",
      "signature": "func(frac float, exp int) float"
    },
    "golang/math.log": {
      "name": "MathLog",
      "package": "golang/math",
      "func": "log",
      "file": "https://pkg.go.dev/math#Log",
      "description": "MathLog is an autogenerated function. func Log(x float64) float64 Log returns the natural logarithm of x.\nSpecial cases are:\nLog(+Inf) = +Inf Log(0) = -Inf Log(x < 0) = NaN Log(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.log_10": {
      "name": "MathLog10",
      "package": "golang/math",
      "func": "log_10",
      "file": "https://pkg.go.dev/math#Log10",
      "description": "MathLog10 is an autogenerated function. func Log10(x float64) float64 Log10 returns the decimal logarithm of x. The special cases are the same as for [Log].",
      "signature": "func(x float) float"
    },
    "golang/math.log_1_p": {
      "name": "MathLog1p",
      "package": "golang/math",
      "func": "log_1_p",
      "file": "https://pkg.go.dev/math#Log1p",
      "description": "MathLog1p is an autogenerated function. func Log1p(x float64) float64 Log1p returns the natural logarithm of 1 plus its argument x. It is more accurate than [Log](1 + x) when x is near zero.\nSpecial cases are:\nLog1p(+Inf) = +Inf Log1p(±0) = ±0 Log1p(-1) = -Inf Log1p(x < -1) = NaN Log1p(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.log_2": {
      "name": "MathLog2",
      "package": "golang/math",
      "func": "log_2",
      "file": "https://pkg.go.dev/math#Log2",
      "description": "MathLog2 is an autogenerated function. func Log2(x float64) float64 Log2 returns the binary logarithm of x. The special cases are the same as for [Log].",
      "signature": "func(x float) float"
    },
    "golang/math.logb": {
      "name": "MathLogb",
      "package": "golang/math",
      "func": "logb",
      "file": "https://pkg.go.dev/math#Logb",
      "description": "MathLogb is an autogenerated function. func Logb(x float64) float64 Logb returns the binary exponent of x.\nSpecial cases are:\nLogb(±Inf) = +Inf Logb(0) = -Inf Logb(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.max": {
      "name": "MathMax",
      "package": "golang/math",
      "func": "max",
      "file": "https://pkg.go.dev/math#Max",
      "description": "MathMax is an autogenerated function. func Max(x float64, y float64) float64 Max returns the larger of x or y.\nSpecial cases are:\nMax(x, +Inf) = Max(+Inf, x) = +Inf Max(x, NaN) = Max(NaN, x) = NaN Max(+0, ±0) = Max(±0, +0) = +0 Max(-0, -0) = -0\nNote that this differs from the built-in function max when called with NaN and +Inf.",
      "signature": "func(x float, y float) float"
    },
    "golang/math.min": {
      "name": "MathMin",
      "package": "golang/math",
      "func": "min",
      "file": "https://pkg.go.dev/math#Min",
      "description": "MathMin is an autogenerated function. func Min(x float64, y float64) float64 Min returns the smaller of x or y.\nSpecial cases are:\nMin(x, -Inf) = Min(-Inf, x) = -Inf Min(x, NaN) = Min(NaN, x) = NaN Min(-0, ±0) = Min(±0, -0) = -0\nNote that this differs from the built-in function min when called with NaN and -Inf.",
      "signature": "func(x float, y float) float"
    },
    "golang/math.mod": {
      "name": "MathMod",
      "package": "golang/math",
      "func": "mod",
      "file": "https://pkg.go.dev/math#Mod",
      "description": "MathMod is an autogenerated function. func Mod(x float64, y float64) float64 Mod returns the floating-point remainder of x/y. The magnitude of the result is less than y and its sign agrees with that of x.\nSpecial cases are:\nMod(±Inf, y) = NaN Mod(NaN, y) = NaN Mod(x, 0) = NaN Mod(x, ±Inf) = x Mod(x, NaN) = NaN",
      "signature": "func(x float, y float) float"
    },
    "golang/math.na_n": {
      "name": "MathNaN",
      "package": "golang/math",
      "func": "na_n",
      "file": "https://pkg.go.dev/math#NaN",
      "description": "MathNaN is an autogenerated function. func NaN() float64 NaN returns an IEEE 754 “not-a-number” value.",
      "signature": "func() float"
    },
    "golang/math.nextafter": {
      "name": "MathNextafter",
      "package": "golang/math",
      "func": "nextafter",
      "file": "https://pkg.go.dev/math#Nextafter",
      "description": "MathNextafter is an autogenerated function. func Nextafter(x float64, y float64) (r float64) Nextafter returns the next representable float64 value after x towards y.\nSpecial cases are:\nNextafter(x, x)   = x Nextafter(NaN, y) = NaN Nextafter(x, NaN) = NaN",
      "signature": "func(x float, y float) float"
    },
    "golang/math.pow": {
      "name": "MathPow",
      "package": "golang/math",
      "func": "pow",
      "file": "https://pkg.go.dev/math#Pow",
      "description": "MathPow is an autogenerated function. func Pow(x float64, y float64) float64 Pow returns x**y, the base-x exponential of y.\nSpecial cases are (in order):\nPow(x, ±0) = 1 for any x Pow(1, y) = 1 for any y Pow(x, 1) = x for any x Pow(NaN, y) = NaN Pow(x, NaN) = NaN Pow(±0, y) = ±Inf for y an odd integer < 0 Pow(±0, -Inf) = +Inf Pow(±0, +Inf) = +0 Pow(±0, y) = +Inf for finite y < 0 and not an odd integer Pow(±0, y) = ±0 for y an odd integer > 0 Pow(±0, y) = +0 for finite y > 0 and not an odd integer Pow(-1, ±Inf) = 1 Pow(x, +Inf) = +Inf for |x| > 1 Pow(x, -Inf) = +0 for |x| > 1 Pow(x, +Inf) = +0 for |x| < 1 Pow(x, -Inf) = +Inf for |x| < 1 Pow(+Inf, y) = +Inf for y > 0 Pow(+Inf, y) = +0 for y < 0 Pow(-Inf, y) = Pow(-0, -y) Pow(x, y) = NaN for finite x < 0 and finite non-integer y",
      "signature": "func(x float, y float) float"
    },
    "golang/math.pow_10": {
      "name": "MathPow10",
      "package": "golang/math",
      "func": "pow_10",
      "file": "https://pkg.go.dev/math#Pow10",
      "description": "MathPow10 is an autogenerated function. func Pow10(n int) float64 Pow10 returns 10**n, the base-10 exponential of n.\nSpecial cases are:\nPow10(n) =    0 for n < -323 Pow10(n) = +Inf for n > 308",
      "signature": "func(n int) float"
    },
    "golang/math.remainder": {
      "name": "MathRemainder",
      "package": "golang/math",
      "func": "remainder",
      "file": "https://pkg.go.dev/math#Remainder",
      "description": "MathRemainder is an autogenerated function. func Remainder(x float64, y float64) float64 Remainder returns the IEEE 754 floating-point remainder of x/y.\nSpecial cases are:\nRemainder(±Inf, y) = NaN Remainder(NaN, y) = NaN Remainder(x, 0) = NaN Remainder(x, ±Inf) = x Remainder(x, NaN) = NaN",
      "signature": "func(x float, y float) float"
    },
    "golang/math.round": {
      "name": "MathRound",
      "package": "golang/math",
      "func": "round",
      "file": "https://pkg.go.dev/math#Round",
      "description": "MathRound is an autogenerated function. func Round(x float64) float64 Round returns the nearest integer, rounding half away from zero.\nSpecial cases are:\nRound(±0) = ±0 Round(±Inf) = ±Inf Round(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.round_to_even": {
      "name": "MathRoundToEven",
      "package": "golang/math",
      "func": "round_to_even",
      "file": "https://pkg.go.dev/math#RoundToEven",
      "description": "MathRoundToEven is an autogenerated function. func RoundToEven(x float64) float64 RoundToEven returns the nearest integer, rounding ties to even.\nSpecial cases are:\nRoundToEven(±0) = ±0 RoundToEven(±Inf) = ±Inf RoundToEven(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.signbit": {
      "name": "MathSignbit",
      "package": "golang/math",
      "func": "signbit",
      "file": "https://pkg.go.dev/math#Signbit",
      "description": "MathSignbit is an autogenerated function. func Signbit(x float64) bool Signbit reports whether x is negative or negative zero.",
      "signature": "func(x float) bool"
    },
    "golang/math.sin": {
      "name": "MathSin",
      "package": "golang/math",
      "func": "sin",
      "file": "https://pkg.go.dev/math#Sin",
      "description": "MathSin is an autogenerated function. func Sin(x float64) float64 Sin returns the sine of the radian argument x.\nSpecial cases are:\nSin(±0) = ±0 Sin(±Inf) = NaN Sin(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.sinh": {
      "name": "MathSinh",
      "package": "golang/math",
      "func": "sinh",
      "file": "https://pkg.go.dev/math#Sinh",
      "description": "MathSinh is an autogenerated function. func Sinh(x float64) float64 Sinh returns the hyperbolic sine of x.\nSpecial cases are:\nSinh(±0) = ±0 Sinh(±Inf) = ±Inf Sinh(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.sqrt": {
      "name": "MathSqrt",
      "package": "golang/math",
      "func": "sqrt",
      "file": "https://pkg.go.dev/math#Sqrt",
      "description": "MathSqrt is an autogenerated function. func Sqrt(x float64) float64 Sqrt returns the square root of x.\nSpecial cases are:\nSqrt(+Inf) = +Inf Sqrt(±0) = ±0 Sqrt(x < 0) = NaN Sqrt(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.tan": {
      "name": "MathTan",
      "package": "golang/math",
      "func": "tan",
      "file": "https://pkg.go.dev/math#Tan",
      "description": "MathTan is an autogenerated function. func Tan(x float64) float64 Tan returns the tangent of the radian argument x.\nSpecial cases are:\nTan(±0) = ±0 Tan(±Inf) = NaN Tan(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.tanh": {
      "name": "MathTanh",
      "package": "golang/math",
      "func": "tanh",
      "file": "https://pkg.go.dev/math#Tanh",
      "description": "MathTanh is an autogenerated function. func Tanh(x float64) float64 Tanh returns the hyperbolic tangent of x.\nSpecial cases are:\nTanh(±0) = ±0 Tanh(±Inf) = ±1 Tanh(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.trunc": {
      "name": "MathTrunc",
      "package": "golang/math",
      "func": "trunc",
      "file": "https://pkg.go.dev/math#Trunc",
      "description": "MathTrunc is an autogenerated function. func Trunc(x float64) float64 Trunc returns the integer value of x.\nSpecial cases are:\nTrunc(±0) = ±0 Trunc(±Inf) = ±Inf Trunc(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.y_0": {
      "name": "MathY0",
      "package": "golang/math",
      "func": "y_0",
      "file": "https://pkg.go.dev/math#Y0",
      "description": "MathY0 is an autogenerated function. func Y0(x float64) float64 Y0 returns the order-zero Bessel function of the second kind.\nSpecial cases are:\nY0(+Inf) = 0 Y0(0) = -Inf Y0(x < 0) = NaN Y0(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.y_1": {
      "name": "MathY1",
      "package": "golang/math",
      "func": "y_1",
      "file": "https://pkg.go.dev/math#Y1",
      "description": "MathY1 is an autogenerated function. func Y1(x float64) float64 Y1 returns the order-one Bessel function of the second kind.\nSpecial cases are:\nY1(+Inf) = 0 Y1(0) = -Inf Y1(x < 0) = NaN Y1(NaN) = NaN",
      "signature": "func(x float) float"
    },
    "golang/math.yn": {
      "name": "MathYn",
      "package": "golang/math",
      "func": "yn",
      "file": "https://pkg.go.dev/math#Yn",
      "description": "MathYn is an autogenerated function. func Yn(n int, x float64) float64 Yn returns the order-n Bessel function of the second kind.\nSpecial cases are:\nYn(n, +Inf) = 0 Yn(n ≥ 0, 0) = -Inf Yn(n < 0, 0) = +Inf if n is odd, -Inf if n is even Yn(n, x < 0) = NaN Yn(n, NaN) = NaN",
      "signature": "func(n int, x float) float"
    },
    "golang/math/rand.exp_float_64": {
      "name": "MathrandExpFloat64",
      "package": "golang/math/rand",
      "func": "exp_float_64",
      "file": "https://pkg.go.dev/math/rand#ExpFloat64",
      "description": "MathrandExpFloat64 is an autogenerated function. func ExpFloat64() float64 ExpFloat64 returns an exponentially distributed float64 in the range (0, +[math.MaxFloat64]] with an exponential distribution whose rate parameter (lambda) is 1 and whose mean is 1/lambda (1) from the default [Source]. To produce a distribution with a different rate parameter, callers can adjust the output using:\nsample = ExpFloat64() / desiredRateParameter",
      "signature": "func() float"
    },
    "golang/math/rand.float_64": {
      "name": "MathrandFloat64",
      "package": "golang/math/rand",
      "func": "float_64",
      "file": "https://pkg.go.dev/math/rand#Float64",
      "description": "MathrandFloat64 is an autogenerated function. func Float64() float64 Float64 returns, as a float64, a pseudo-random number in the half-open interval [0.0,1.0) from the default [Source].",
      "signature": "func() float"
    },
    "golang/math/rand.int": {
      "name": "MathrandInt",
      "package": "golang/math/rand",
      "func": "int",
      "file": "https://pkg.go.dev/math/rand#Int",
      "description": "MathrandInt is an autogenerated function. func Int() int Int returns a non-negative pseudo-random int from the default [Source].",
      "signature": "func() int"
    },
    "golang/math/rand.int_63": {
      "name": "MathrandInt63",
      "package": "golang/math/rand",
      "func": "int_63",
      "file": "https://pkg.go.dev/math/rand#Int63",
      "description": "MathrandInt63 is an autogenerated function. func Int63() int64 Int63 returns a non-negative pseudo-random 63-bit integer as an int64 from the default [Source].",
      "signature": "func() int"
    },
    "golang/math/rand.int_63_n": {
      "name": "MathrandInt63n",
      "package": "golang/math/rand",
      "func": "int_63_n",
      "file": "https://pkg.go.dev/math/rand#Int63n",
      "description": "MathrandInt63n is an autogenerated function. func Int63n(n int64) int64 Int63n returns, as an int64, a non-negative pseudo-random number in the half-open interval [0,n) from the default [Source]. It panics if n <= 0.",
      "signature": "func(n int) int"
    },
    "golang/math/rand.intn": {
      "name": "MathrandIntn",
      "package": "golang/math/rand",
      "func": "intn",
      "file": "https://pkg.go.dev/math/rand#Intn",
      "description": "MathrandIntn is an autogenerated function. func Intn(n int) int Intn returns, as an int, a non-negative pseudo-random number in the half-open interval [0,n) from the default [Source]. It panics if n <= 0.",
      "signature": "func(n int) int"
    },
    "golang/math/rand.norm_float_64": {
      "name": "MathrandNormFloat64",
      "package": "golang/math/rand",
      "func": "norm_float_64",
      "file": "https://pkg.go.dev/math/rand#NormFloat64",
      "description": "MathrandNormFloat64 is an autogenerated function. func NormFloat64() float64 NormFloat64 returns a normally distributed float64 in the range [-[math.MaxFloat64], +[math.MaxFloat64]] with standard normal distribution (mean = 0, stddev = 1) from the default [Source]. To produce a different normal distribution, callers can adjust the output using:\nsample = NormFloat64() * desiredStdDev + desiredMean",
      "signature": "func() float"
    },
    "golang/math/rand.read": {
      "name": "MathrandRead",
      "package": "golang/math/rand",
      "func": "read",
      "file": "https://pkg.go.dev/math/rand#Read",
      "description": "MathrandRead is an autogenerated function. func Read(p []byte) (n int, err error) Read generates len(p) random bytes from the default [Source] and writes them into p. It always returns len(p) and a nil error. Read, unlike the [Rand.Read] method, is safe for concurrent use.\nDeprecated: For almost all use cases, [crypto/rand.Read] is more appropriate. If a deterministic source is required, use [math/rand/v2.ChaCha8.Read].",
      "signature": "func(p str) int"
    },
    "golang/os.executable": {
      "name": "OsExecutable",
      "package": "golang/os",
      "func": "executable",
      "file": "https://pkg.go.dev/os#Executable",
      "description": "OsExecutable is an autogenerated function. func Executable() (string, error) Executable returns the path name for the executable that started the current process. There is no guarantee that the path is still pointing to the correct executable. If a symlink was used to start the process, depending on the operating system, the result might be the symlink or the path it pointed to. If a stable result is needed, [path/filepath.EvalSymlinks] might help.\nExecutable returns an absolute path unless an error occurred.\nThe main use case is finding resources located relative to an executable.",
      "signature": "func() str"
    },
    "golang/os.expand_env": {
      "name": "OsExpandEnv",
      "package": "golang/os",
      "func": "expand_env",
      "file": "https://pkg.go.dev/os#ExpandEnv",
      "description": "OsExpandEnv is an autogenerated function. func ExpandEnv(s string) string ExpandEnv replaces ${var} or $var in the string according to the values of the current environment variables. References to undefined variables are replaced by the empty string.",
      "signature": "func(s str) str"
    },
    "golang/os.getegid": {
      "name": "OsGetegid",
      "package": "golang/os",
      "func": "getegid",
      "file": "https://pkg.go.dev/os#Getegid",
      "description": "OsGetegid is an autogenerated function. func Getegid() int Getegid returns the numeric effective group id of the caller.\nOn Windows, it returns -1.",
      "signature": "func() int"
    },
    "golang/os.getenv": {
      "name": "OsGetenv",
      "package": "golang/os",
      "func": "getenv",
      "file": "https://pkg.go.dev/os#Getenv",
      "description": "OsGetenv is an autogenerated function. func Getenv(key string) string Getenv retrieves the value of the environment variable named by the key. It returns the value, which will be empty if the variable is not present. To distinguish between an empty value and an unset value, use [LookupEnv].",
      "signature": "func(key str) str"
    },
    "golang/os.geteuid": {
      "name": "OsGeteuid",
      "package": "golang/os",
      "func": "geteuid",
      "file": "https://pkg.go.dev/os#Geteuid",
      "description": "OsGeteuid is an autogenerated function. func Geteuid() int Geteuid returns the numeric effective user id of the caller.\nOn Windows, it returns -1.",
      "signature": "func() int"
    },
    "golang/os.getgid": {
      "name": "OsGetgid",
      "package": "golang/os",
      "func": "getgid",
      "file": "https://pkg.go.dev/os#Getgid",
      "description": "OsGetgid is an autogenerated function. func Getgid() int Getgid returns the numeric group id of the caller.\nOn Windows, it returns -1.",
      "signature": "func() int"
    },
    "golang/os.getpagesize": {
      "name": "OsGetpagesize",
      "package": "golang/os",
      "func": "getpagesize",
      "file": "https://pkg.go.dev/os#Getpagesize",
      "description": "OsGetpagesize is an autogenerated function. func Getpagesize() int Getpagesize returns the underlying system's memory page size.",
      "signature": "func() int"
    },
    "golang/os.getpid": {
      "name": "OsGetpid",
      "package": "golang/os",
      "func": "getpid",
      "file": "https://pkg.go.dev/os#Getpid",
      "description": "OsGetpid is an autogenerated function. func Getpid() int Getpid returns the process id of the caller.",
      "signature": "func() int"
    },
    "golang/os.getppid": {
      "name": "OsGetppid",
      "package": "golang/os",
      "func": "getppid",
      "file": "https://pkg.go.dev/os#Getppid",
      "description": "OsGetppid is an autogenerated function. func Getppid() int Getppid returns the process id of the caller's parent.",
      "signature": "func() int"
    },
    "golang/os.getuid": {
      "name": "OsGetuid",
      "package": "golang/os",
      "func": "getuid",
      "file": "https://pkg.go.dev/os#Getuid",
      "description": "OsGetuid is an autogenerated function. func Getuid() int Getuid returns the numeric user id of the caller.\nOn Windows, it returns -1.",
      "signature": "func() int"
    },
    "golang/os.getwd": {
      "name": "OsGetwd",
      "package": "golang/os",
      "func": "getwd",
      "file": "https://pkg.go.dev/os#Getwd",
      "description": "OsGetwd is an autogenerated function. func Getwd() (dir string, err error) Getwd returns an absolute path name corresponding to the current directory. If the current directory can be reached via multiple paths (due to symbolic links), Getwd may return any one of them.\nOn Unix platforms, if the environment variable PWD provides an absolute name, and it is a name of the current directory, it is returned.",
      "signature": "func() str"
    },
    "golang/os.hostname": {
      "name": "OsHostname",
      "package": "golang/os",
      "func": "hostname",
      "file": "https://pkg.go.dev/os#Hostname",
      "description": "OsHostname is an autogenerated function. func Hostname() (name string, err error) Hostname returns the host name reported by the kernel.",
      "signature": "func() str"
    },
    "golang/os.mkdir_temp": {
      "name": "OsMkdirTemp",
      "package": "golang/os",
      "func": "mkdir_temp",
      "file": "https://pkg.go.dev/os#MkdirTemp",
      "description": "OsMkdirTemp is an autogenerated function. func MkdirTemp(dir string, pattern string) (string, error) MkdirTemp creates a new temporary directory in the directory dir and returns the pathname of the new directory. The new directory's name is generated by adding a random string to the end of pattern. If pattern includes a \"*\", the random string replaces the last \"*\" instead. The directory is created with mode 0o700 (before umask). If dir is the empty string, MkdirTemp uses the default directory for temporary files, as returned by TempDir. Multiple programs or goroutines calling MkdirTemp simultaneously will not choose the same directory. It is the caller's responsibility to remove the directory when it is no longer needed.",
      "signature": "func(dir str, pattern str) str"
    },
    "golang/os.read_file": {
      "name": "OsReadFile",
      "package": "golang/os",
      "func": "read_file",
      "file": "https://pkg.go.dev/os#ReadFile",
      "description": "OsReadFile is an autogenerated function. func ReadFile(name string) ([]byte, error) ReadFile reads the named file and returns the contents. A successful call returns err == nil, not err == EOF. Because ReadFile reads the whole file, it does not treat an EOF from Read as an error to be reported.",
      "signature": "func(name str) str"
    },
    "golang/os.readlink": {
      "name": "OsReadlink",
      "package": "golang/os",
      "func": "readlink",
      "file": "https://pkg.go.dev/os#Readlink",
      "description": "OsReadlink is an autogenerated function. func Readlink(name string) (string, error) Readlink returns the destination of the named symbolic link. If there is an error, it will be of type *PathError.\nIf the link destination is relative, Readlink returns the relative path without resolving it to an absolute one.",
      "signature": "func(name str) str"
    },
    "golang/os.temp_dir": {
      "name": "OsTempDir",
      "package": "golang/os",
      "func": "temp_dir",
      "file": "https://pkg.go.dev/os#TempDir",
      "description": "OsTempDir is an autogenerated function. func TempDir() string TempDir returns the default directory to use for temporary files.\nOn Unix systems, it returns $TMPDIR if non-empty, else /tmp. On Windows, it uses GetTempPath, returning the first non-empty value from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory. On Plan 9, it returns /tmp.\nThe directory is neither guaranteed to exist nor have accessible permissions.",
      "signature": "func() str"
    },
    "golang/os.user_cache_dir": {
      "name": "OsUserCacheDir",
      "package": "golang/os",
      "func": "user_cache_dir",
      "file": "https://pkg.go.dev/os#UserCacheDir",
      "description": "OsUserCacheDir is an autogenerated function. func UserCacheDir() (string, error) UserCacheDir returns the default root directory to use for user-specific cached data. Users should create their own application-specific subdirectory within this one and use that.\nOn Unix systems, it returns $XDG_CACHE_HOME as specified by https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html if non-empty, else $HOME/.cache. On Darwin, it returns $HOME/Library/Caches. On Windows, it returns %LocalAppData%. On Plan 9, it returns $home/lib/cache.\nIf the location cannot be determined (for example, $HOME is not defined) or the path in $XDG_CACHE_HOME is relative, then it will return an error.",
      "signature": "func() str"
    },
    "golang/os.user_config_dir": {
      "name": "OsUserConfigDir",
      "package": "golang/os",
      "func": "user_config_dir",
      "file": "https://pkg.go.dev/os#UserConfigDir",
      "description": "OsUserConfigDir is an autogenerated function. func UserConfigDir() (string, error) UserConfigDir returns the default root directory to use for user-specific configuration data. Users should create their own application-specific subdirectory within this one and use that.\nOn Unix systems, it returns $XDG_CONFIG_HOME as specified by https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html if non-empty, else $HOME/.config. On Darwin, it returns $HOME/Library/Application Support. On Windows, it returns %AppData%. On Plan 9, it returns $home/lib.\nIf the location cannot be determined (for example, $HOME is not defined) or the path in $XDG_CONFIG_HOME is relative, then it will return an error.",
      "signature": "func() str"
    },
    "golang/os.user_home_dir": {
      "name": "OsUserHomeDir",
      "package": "golang/os",
      "func": "user_home_dir",
      "file": "https://pkg.go.dev/os#UserHomeDir",
      "description": "OsUserHomeDir is an autogenerated function. func UserHomeDir() (string, error) UserHomeDir returns the current user's home directory.\nOn Unix, including macOS, it returns the $HOME environment variable. On Windows, it returns %USERPROFILE%. On Plan 9, it returns the $home environment variable.\nIf the expected variable is not set in the environment, UserHomeDir returns either a platform-specific default value or a non-nil error.",
      "signature": "func() str"
    },
    "golang/os/exec.look_path": {
      "name": "OsexecLookPath",
      "package": "golang/os/exec",
      "func": "look_path",
      "file": "https://pkg.go.dev/os/exec#LookPath",
      "description": "OsexecLookPath is an autogenerated function. func LookPath(file string) (string, error) LookPath searches for an executable named file in the directories named by the PATH environment variable. If file contains a slash, it is tried directly and the PATH is not consulted. Otherwise, on success, the result is an absolute path.\nIn older versions of Go, LookPath could return a path relative to the current directory. As of Go 1.19, LookPath will instead return that path along with an error satisfying [errors.Is](err, [ErrDot]). See the package documentation for more details.",
      "signature": "func(file str) str"
    },
    "golang/path.base": {
      "name": "PathBase",
      "package": "golang/path",
      "func": "base",
      "file": "https://pkg.go.dev/path#Base",
      "description": "PathBase is an autogenerated function. func Base(path string) string Base returns the last element of path. Trailing slashes are removed before extracting the last element. If the path is empty, Base returns \".\". If the path consists entirely of slashes, Base returns \"/\".",
      "signature": "func(path str) str"
    },
    "golang/path.clean": {
      "name": "PathClean",
      "package": "golang/path",
      "func": "clean",
      "file": "https://pkg.go.dev/path#Clean",
      "description": "PathClean is an autogenerated function. func Clean(path string) string Clean returns the shortest path name equivalent to path by purely lexical processing. It applies the following rules iteratively until no further processing can be done:\n1. Replace multiple slashes with a single slash. 2. Eliminate each . path name element (the current directory). 3. Eliminate each inner .. path name element (the parent directory) along with the non-.. element that precedes it. 4. Eliminate .. elements that begin a rooted path: that is, replace \"/..\" by \"/\" at the beginning of a path.\nThe returned path ends in a slash only if it is the root \"/\".\nIf the result of this process is an empty string, Clean returns the string \".\".\nSee also Rob Pike, “Lexical File Names in Plan 9 or Getting Dot-Dot Right,” https://9p.io/sys/doc/lexnames.html",
      "signature": "func(path str) str"
    },
    "golang/path.dir": {
      "name": "PathDir",
      "package": "golang/path",
      "func": "dir",
      "file": "https://pkg.go.dev/path#Dir",
      "description": "PathDir is an autogenerated function. func Dir(path string) string Dir returns all but the last element of path, typically the path's directory. After dropping the final element using [Split], the path is Cleaned and trailing slashes are removed. If the path is empty, Dir returns \".\". If the path consists entirely of slashes followed by non-slash bytes, Dir returns a single slash. In any other case, the returned path does not end in a slash.",
      "signature": "func(path str) str"
    },
    "golang/path.ext": {
      "name": "PathExt",
      "package": "golang/path",
      "func": "ext",
      "file": "https://pkg.go.dev/path#Ext",
      "description": "PathExt is an autogenerated function. func Ext(path string) string Ext returns the file name extension used by path. The extension is the suffix beginning at the final dot in the final slash-separated element of path; it is empty if there is no dot.",
      "signature": "func(path str) str"
    },
    "golang/path.is_abs": {
      "name": "PathIsAbs",
      "package": "golang/path",
      "func": "is_abs",
      "file": "https://pkg.go.dev/path#IsAbs",
      "description": "PathIsAbs is an autogenerated function. func IsAbs(path string) bool IsAbs reports whether the path is absolute.",
      "signature": "func(path str) bool"
    },
    "golang/path.join": {
      "name": "PathJoin",
      "package": "golang/path",
      "func": "join",
      "file": "https://pkg.go.dev/path#Join",
      "description": "PathJoin is an autogenerated function. func Join(elem ...string) string Join joins any number of path elements into a single path, separating them with slashes. Empty elements are ignored. The result is Cleaned. However, if the argument list is empty or all its elements are empty, Join returns an empty string.",
      "signature": "func(elem []str) str"
    },
    "golang/path.match": {
      "name": "PathMatch",
      "package": "golang/path",
      "func": "match",
      "file": "https://pkg.go.dev/path#Match",
      "description": "PathMatch is an autogenerated function. func Match(pattern string, name string) (matched bool, err error) Match reports whether name matches the shell pattern. The pattern syntax is:\npattern: { term } term: '*'         matches any sequence of non-/ characters '?'         matches any single non-/ character '[' [ '^' ] { character-range } ']' character class (must be non-empty) c           matches character c (c != '*', '?', '\\\\', '[') '\\\\' c      matches character c\ncharacter-range: c           matches character c (c != '\\\\', '-', ']') '\\\\' c      matches character c lo '-' hi   matches character c for lo <= c <= hi\nMatch requires pattern to match all of name, not just a substring. The only possible returned error is [ErrBadPattern], when pattern is malformed.",
      "signature": "func(pattern str, name str) bool"
    },
    "golang/path/filepath.abs": {
      "name": "PathfilepathAbs",
      "package": "golang/path/filepath",
      "func": "abs",
      "file": "https://pkg.go.dev/path/filepath#Abs",
      "description": "PathfilepathAbs is an autogenerated function. func Abs(path string) (string, error) Abs returns an absolute representation of path. If the path is not absolute it will be joined with the current working directory to turn it into an absolute path. The absolute path name for a given file is not guaranteed to be unique. Abs calls [Clean] on the result.",
      "signature": "func(path str) str"
    },
    "golang/path/filepath.base": {
      "name": "PathfilepathBase",
      "package": "golang/path/filepath",
      "func": "base",
      "file": "https://pkg.go.dev/path/filepath#Base",
      "description": "PathfilepathBase is an autogenerated function. func Base(path string) string Base returns the last element of path. Trailing path separators are removed before extracting the last element. If the path is empty, Base returns \".\". If the path consists entirely of separators, Base returns a single separator.",
      "signature": "func(path str) str"
    },
    "golang/path/filepath.clean": {
      "name": "PathfilepathClean",
      "package": "golang/path/filepath",
      "func": "clean",
      "file": "https://pkg.go.dev/path/filepath#Clean",
      "description": "PathfilepathClean is an autogenerated function. func Clean(path string) string Clean returns the shortest path name equivalent to path by purely lexical processing. It applies the following rules iteratively until no further processing can be done:\n1. Replace multiple [Separator] elements with a single one. 2. Eliminate each . path name element (the current directory). 3. Eliminate each inner .. path name element (the parent directory) along with the non-.. element that precedes it. 4. Eliminate .. elements that begin a rooted path: that is, replace \"/..\" by \"/\" at the beginning of a path, assuming Separator is '/'.\nThe returned path ends in a slash only if it represents a root directory, such as \"/\" on Unix or `C:\\` on Windows.\nFinally, any occurrences of slash are replaced by Separator.\nIf the result of this process is an empty string, Clean returns the string \".\".\nOn Windows, Clean does not modify the volume name other than to replace occurrences of \"/\" with `\\`. For example, Clean(\"//host/share/../x\") returns `\\\\host\\share\\x`.\nSee also Rob Pike, “Lexical File Names in Plan 9 or Getting Dot-Dot Right,” https://9p.io/sys/doc/lexnames.html",
      "signature": "func(path str) str"
    },
    "golang/path/filepath.dir": {
      "name": "PathfilepathDir",
      "package": "golang/path/filepath",
      "func": "dir",
      "file": "https://pkg.go.dev/path/filepath#Dir",
      "description": "PathfilepathDir is an autogenerated function. func Dir(path string) string Dir returns all but the last element of path, typically the path's directory. After dropping the final element, Dir calls [Clean] on the path and trailing slashes are removed. If the path is empty, Dir returns \".\". If the path consists entirely of separators, Dir returns a single separator. The returned path does not end in a separator unless it is the root directory.",
      "signature": "func(path str) str"
    },
    "golang/path/filepath.eval_symlinks": {
      "name": "PathfilepathEvalSymlinks",
      "package": "golang/path/filepath",
      "func": "eval_symlinks",
      "file": "https://pkg.go.dev/path/filepath#EvalSymlinks",
      "description": "PathfilepathEvalSymlinks is an autogenerated function. func EvalSymlinks(path string) (string, error) EvalSymlinks returns the path name after the evaluation of any symbolic links. If path is relative the result will be relative to the current directory, unless one of the components is an absolute symbolic link. EvalSymlinks calls [Clean] on the result.",
      "signature": "func(path str) str"
    },
    "golang/path/filepath.ext": {
      "name": "PathfilepathExt",
      "package": "golang/path/filepath",
      "func": "ext",
      "file": "https://pkg.go.dev/path/filepath#Ext",
      "description": "PathfilepathExt is an autogenerated function. func Ext(path string) string Ext returns the file name extension used by path. The extension is the suffix beginning at the final dot in the final element of path; it is empty if there is no dot.",
      "signature": "func(path str) str"
    },
    "golang/path/filepath.from_slash": {
      "name": "PathfilepathFromSlash",
      "package": "golang/path/filepath",
      "func": "from_slash",
      "file": "https://pkg.go.dev/path/filepath#FromSlash",
      "description": "PathfilepathFromSlash is an autogenerated function. func FromSlash(path string) string FromSlash returns the result of replacing each slash ('/') character in path with a separator character. Multiple slashes are replaced by multiple separators.\nSee also the Localize function, which converts a slash-separated path as used by the io/fs package to an operating system path.",
      "signature": "func(path str) str"
    },
    "golang/path/filepath.has_prefix": {
      "name": "PathfilepathHasPrefix",
      "package": "golang/path/filepath",
      "func": "has_prefix",
      "file": "https://pkg.go.dev/path/filepath#HasPrefix",
      "description": "PathfilepathHasPrefix is an autogenerated function. func HasPrefix(p string, prefix string) bool HasPrefix exists for historical compatibility and should not be used.\nDeprecated: HasPrefix does not respect path boundaries and does not ignore case when required.",
      "signature": "func(p str, prefix str) bool"
    },
    "golang/path/filepath.is_abs": {
      "name": "PathfilepathIsAbs",
      "package": "golang/path/filepath",
      "func": "is_abs",
      "file": "https://pkg.go.dev/path/filepath#IsAbs",
      "description": "PathfilepathIsAbs is an autogenerated function. func IsAbs(path string) bool IsAbs reports whether the path is absolute.",
      "signature": "func(path str) bool"
    },
    "golang/path/filepath.is_local": {
      "name": "PathfilepathIsLocal",
      "package": "golang/path/filepath",
      "func": "is_local",
      "file": "https://pkg.go.dev/path/filepath#IsLocal",
      "description": "PathfilepathIsLocal is an autogenerated function. func IsLocal(path string) bool IsLocal reports whether path, using lexical analysis only, has all of these properties:\n- is within the subtree rooted at the directory in which path is evaluated - is not an absolute path - is not empty - on Windows, is not a reserved name such as \"NUL\"\nIf IsLocal(path) returns true, then Join(base, path) will always produce a path contained within base and Clean(path) will always produce an unrooted path with no \"..\" path elements.\nIsLocal is a purely lexical operation. In particular, it does not account for the effect of any symbolic links that may exist in the filesystem.",
      "signature": "func(path str) bool"
    },
    "golang/path/filepath.join": {
      "name": "PathfilepathJoin",
      "package": "golang/path/filepath",
      "func": "join",
      "file": "https://pkg.go.dev/path/filepath#Join",
      "description": "PathfilepathJoin is an autogenerated function. func Join(elem ...string) string Join joins any number of path elements into a single path, separating them with an OS specific [Separator]. Empty elements are ignored. The result is Cleaned. However, if the argument list is empty or all its elements are empty, Join returns an empty string. On Windows, the result will only be a UNC path if the first non-empty element is a UNC path.",
      "signature": "func(elem []str) str"
    },
    "golang/path/filepath.localize": {
      "name": "PathfilepathLocalize",
      "package": "golang/path/filepath",
      "func": "localize",
      "file": "https://pkg.go.dev/path/filepath#Localize",
      "description": "PathfilepathLocalize is an autogenerated function. func Localize(path string) (string, error) Localize converts a slash-separated path into an operating system path. The input path must be a valid path as reported by [io/fs.ValidPath].\nLocalize returns an error if the path cannot be represented by the operating system. For example, the path a\\b is rejected on Windows, on which \\ is a separator character and cannot be part of a filename.\nThe path returned by Localize will always be local, as reported by IsLocal.",
      "signature": "func(path str) str"
    },
    "golang/path/filepath.match": {
      "name": "PathfilepathMatch",
      "package": "golang/path/filepath",
      "func": "match",
      "file": "https://pkg.go.dev/path/filepath#Match",
      "description": "PathfilepathMatch is an autogenerated function. func Match(pattern string, name string) (matched bool, err error) Match reports whether name matches the shell file name pattern. The pattern syntax is:\npattern: { term } term: '*'         matches any sequence of non-Separator characters '?'         matches any single non-Separator character '[' [ '^' ] { character-range } ']' character class (must be non-empty) c           matches character c (c != '*', '?', '\\\\', '[') '\\\\' c      matches character c\ncharacter-range: c           matches character c (c != '\\\\', '-', ']') '\\\\' c      matches character c lo '-' hi   matches character c for lo <= c <= hi\nMatch requires pattern to match all of name, not just a substring. The only possible returned error is [ErrBadPattern], when pattern is malformed.\nOn Windows, escaping is disabled. Instead, '\\\\' is treated as path separator.",
      "signature": "func(pattern str, name str) bool"
    },
    "golang/path/filepath.rel": {
      "name": "PathfilepathRel",
      "package": "golang/path/filepath",
      "func": "rel",
      "file": "https://pkg.go.dev/path/filepath#Rel",
      "description": "PathfilepathRel is an autogenerated function. func Rel(basepath string, targpath string) (string, error) Rel returns a relative path that is lexically equivalent to targpath when joined to basepath with an intervening separator. That is, [Join](basepath, Rel(basepath, targpath)) is equivalent to targpath itself. On success, the returned path will always be relative to basepath, even if basepath and targpath share no elements. An error is returned if targpath can't be made relative to basepath or if knowing the current working directory would be necessary to compute it. Rel calls [Clean] on the result.",
      "signature": "func(basepath str, targpath str) str"
    },
    "golang/path/filepath.to_slash": {
      "name": "PathfilepathToSlash",
      "package": "golang/path/filepath",
      "func": "to_slash",
      "file": "https://pkg.go.dev/path/filepath#ToSlash",
      "description": "PathfilepathToSlash is an autogenerated function. func ToSlash(path string) string ToSlash returns the result of replacing each separator character in path with a slash ('/') character. Multiple separators are replaced by multiple slashes.",
      "signature": "func(path str) str"
    },
    "golang/path/filepath.volume_name": {
      "name": "PathfilepathVolumeName",
      "package": "golang/path/filepath",
      "func": "volume_name",
      "file": "https://pkg.go.dev/path/filepath#VolumeName",
      "description": "PathfilepathVolumeName is an autogenerated function. func VolumeName(path string) string VolumeName returns leading volume name. Given \"C:\\foo\\bar\" it returns \"C:\" on Windows. Given \"\\\\host\\share\\foo\" it returns \"\\\\host\\share\". On other platforms it returns \"\".",
      "signature": "func(path str) str"
    },
    "golang/runtime.cpu_profile": {
      "name": "RuntimeCPUProfile",
      "package": "golang/runtime",
      "func": "cpu_profile",
      "file": "https://pkg.go.dev/runtime#CPUProfile",
      "description": "RuntimeCPUProfile is an autogenerated function. func CPUProfile() []byte CPUProfile panics. It formerly provided raw access to chunks of a pprof-format profile generated by the runtime. The details of generating that format have changed, so this functionality has been removed.\nDeprecated: Use the [runtime/pprof] package, or the handlers in the [net/http/pprof] package, or the [testing] package's -test.cpuprofile flag instead.",
      "signature": "func() str"
    },
    "golang/runtime.gomaxprocs": {
      "name": "RuntimeGOMAXPROCS",
      "package": "golang/runtime",
      "func": "gomaxprocs",
      "file": "https://pkg.go.dev/runtime#GOMAXPROCS",
      "description": "RuntimeGOMAXPROCS is an autogenerated function. func GOMAXPROCS(n int) int GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting. It defaults to the value of [runtime.NumCPU]. If n < 1, it does not change the current setting. This call will go away when the scheduler improves.",
      "signature": "func(n int) int"
    },
    "golang/runtime.goroot": {
      "name": "RuntimeGOROOT",
      "package": "golang/runtime",
      "func": "goroot",
      "file": "https://pkg.go.dev/runtime#GOROOT",
      "description": "RuntimeGOROOT is an autogenerated function. func GOROOT() string GOROOT returns the root of the Go tree. It uses the GOROOT environment variable, if set at process start, or else the root used during the Go build.\nDeprecated: The root used during the Go build will not be meaningful if the binary is copied to another machine. Use the system path to locate the “go” binary, and use “go env GOROOT” to find its GOROOT.",
      "signature": "func() str"
    },
    "golang/runtime.num_cgo_call": {
      "name": "RuntimeNumCgoCall",
      "package": "golang/runtime",
      "func": "num_cgo_call",
      "file": "https://pkg.go.dev/runtime#NumCgoCall",
      "description": "RuntimeNumCgoCall is an autogenerated function. func NumCgoCall() int64 NumCgoCall returns the number of cgo calls made by the current process.",
      "signature": "func() int"
    },
    "golang/runtime.num_cpu": {
      "name": "RuntimeNumCPU",
      "package": "golang/runtime",
      "func": "num_cpu",
      "file": "https://pkg.go.dev/runtime#NumCPU",
      "description": "RuntimeNumCPU is an autogenerated function. func NumCPU() int NumCPU returns the number of logical CPUs usable by the current process.\nThe set of available CPUs is checked by querying the operating system at process startup. Changes to operating system CPU allocation after process startup are not reflected.",
      "signature": "func() int"
    },
    "golang/runtime.num_goroutine": {
      "name": "RuntimeNumGoroutine",
      "package": "golang/runtime",
      "func": "num_goroutine",
      "file": "https://pkg.go.dev/runtime#NumGoroutine",
      "description": "RuntimeNumGoroutine is an autogenerated function. func NumGoroutine() int NumGoroutine returns the number of goroutines that currently exist.",
      "signature": "func() int"
    },
    "golang/runtime.read_trace": {
      "name": "RuntimeReadTrace",
      "package": "golang/runtime",
      "func": "read_trace",
      "file": "https://pkg.go.dev/runtime#ReadTrace",
      "description": "RuntimeReadTrace is an autogenerated function. func ReadTrace() []byte ReadTrace returns the next chunk of binary tracing data, blocking until data is available. If tracing is turned off and all the data accumulated while it was on has been returned, ReadTrace returns nil. The caller must copy the returned data before calling ReadTrace again. ReadTrace must be called from one goroutine at a time.",
      "signature": "func() str"
    },
    "golang/runtime.set_mutex_profile_fraction": {
      "name": "RuntimeSetMutexProfileFraction",
      "package": "golang/runtime",
      "func": "set_mutex_profile_fraction",
      "file": "https://pkg.go.dev/runtime#SetMutexProfileFraction",
      "description": "RuntimeSetMutexProfileFraction is an autogenerated function. func SetMutexProfileFraction(rate int) int SetMutexProfileFraction controls the fraction of mutex contention events that are reported in the mutex profile. On average 1/rate events are reported. The previous rate is returned.\nTo turn off profiling entirely, pass rate 0. To just read the current rate, pass rate < 0. (For n>1 the details of sampling may change.)",
      "signature": "func(rate int) int"
    },
    "golang/runtime.stack": {
      "name": "RuntimeStack",
      "package": "golang/runtime",
      "func": "stack",
      "file": "https://pkg.go.dev/runtime#Stack",
      "description": "RuntimeStack is an autogenerated function. func Stack(buf []byte, all bool) int Stack formats a stack trace of the calling goroutine into buf and returns the number of bytes written to buf. If all is true, Stack formats stack traces of all other goroutines into buf after the trace for the current goroutine.",
      "signature": "func(buf str, all bool) int"
    },
    "golang/runtime.version": {
      "name": "RuntimeVersion",
      "package": "golang/runtime",
      "func": "version",
      "file": "https://pkg.go.dev/runtime#Version",
      "description": "RuntimeVersion is an autogenerated function. func Version() string Version returns the Go tree's version string. It is either the commit hash and date at the time of the build or, when possible, a release tag like \"go1.3\".",
      "signature": "func() str"
    },
    "golang/strconv.append_bool": {
      "name": "StrconvAppendBool",
      "package": "golang/strconv",
      "func": "append_bool",
      "file": "https://pkg.go.dev/strconv#AppendBool",
      "description": "StrconvAppendBool is an autogenerated function. func AppendBool(dst []byte, b bool) []byte AppendBool appends \"true\" or \"false\", according to the value of b, to dst and returns the extended buffer.",
      "signature": "func(dst str, b bool) str"
    },
    "golang/strconv.append_int": {
      "name": "StrconvAppendInt",
      "package": "golang/strconv",
      "func": "append_int",
      "file": "https://pkg.go.dev/strconv#AppendInt",
      "description": "StrconvAppendInt is an autogenerated function. func AppendInt(dst []byte, i int64, base int) []byte AppendInt appends the string form of the integer i, as generated by [FormatInt], to dst and returns the extended buffer.",
      "signature": "func(dst str, i int, base int) str"
    },
    "golang/strconv.append_quote": {
      "name": "StrconvAppendQuote",
      "package": "golang/strconv",
      "func": "append_quote",
      "file": "https://pkg.go.dev/strconv#AppendQuote",
      "description": "StrconvAppendQuote is an autogenerated function. func AppendQuote(dst []byte, s string) []byte AppendQuote appends a double-quoted Go string literal representing s, as generated by [Quote], to dst and returns the extended buffer.",
      "signature": "func(dst str, s str) str"
    },
    "golang/strconv.append_quote_to_ascii": {
      "name": "StrconvAppendQuoteToASCII",
      "package": "golang/strconv",
      "func": "append_quote_to_ascii",
      "file": "https://pkg.go.dev/strconv#AppendQuoteToASCII",
      "description": "StrconvAppendQuoteToASCII is an autogenerated function. func AppendQuoteToASCII(dst []byte, s string) []byte AppendQuoteToASCII appends a double-quoted Go string literal representing s, as generated by [QuoteToASCII], to dst and returns the extended buffer.",
      "signature": "func(dst str, s str) str"
    },
    "golang/strconv.append_quote_to_graphic": {
      "name": "StrconvAppendQuoteToGraphic",
      "package": "golang/strconv",
      "func": "append_quote_to_graphic",
      "file": "https://pkg.go.dev/strconv#AppendQuoteToGraphic",
      "description": "StrconvAppendQuoteToGraphic is an autogenerated function. func AppendQuoteToGraphic(dst []byte, s string) []byte AppendQuoteToGraphic appends a double-quoted Go string literal representing s, as generated by [QuoteToGraphic], to dst and returns the extended buffer.",
      "signature": "func(dst str, s str) str"
    },
    "golang/strconv.atoi": {
      "name": "StrconvAtoi",
      "package": "golang/strconv",
      "func": "atoi",
      "file": "https://pkg.go.dev/strconv#Atoi",
      "description": "StrconvAtoi is an autogenerated function. func Atoi(s string) (int, error) Atoi is equivalent to ParseInt(s, 10, 0), converted to type int.",
      "signature": "func(s str) int"
    },
    "golang/strconv.can_backquote": {
      "name": "StrconvCanBackquote",
      "package": "golang/strconv",
      "func": "can_backquote",
      "file": "https://pkg.go.dev/strconv#CanBackquote",
      "description": "StrconvCanBackquote is an autogenerated function. func CanBackquote(s string) bool CanBackquote reports whether the string s can be represented unchanged as a single-line backquoted string without control characters other than tab.",
      "signature": "func(s str) bool"
    },
    "golang/strconv.format_bool": {
      "name": "StrconvFormatBool",
      "package": "golang/strconv",
      "func": "format_bool",
      "file": "https://pkg.go.dev/strconv#FormatBool",
      "description": "StrconvFormatBool is an autogenerated function. func FormatBool(b bool) string FormatBool returns \"true\" or \"false\" according to the value of b.",
      "signature": "func(b bool) str"
    },
    "golang/strconv.format_int": {
      "name": "StrconvFormatInt",
      "package": "golang/strconv",
      "func": "format_int",
      "file": "https://pkg.go.dev/strconv#FormatInt",
      "description": "StrconvFormatInt is an autogenerated function. func FormatInt(i int64, base int) string FormatInt returns the string representation of i in the given base, for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z' for digit values >= 10.",
      "signature": "func(i int, base int) str"
    },
    "golang/strconv.itoa": {
      "name": "StrconvItoa",
      "package": "golang/strconv",
      "func": "itoa",
      "file": "https://pkg.go.dev/strconv#Itoa",
      "description": "StrconvItoa is an autogenerated function. func Itoa(i int) string Itoa is equivalent to [FormatInt](int64(i), 10).",
      "signature": "func(i int) str"
    },
    "golang/strconv.parse_bool": {
      "name": "StrconvParseBool",
      "package": "golang/strconv",
      "func": "parse_bool",
      "file": "https://pkg.go.dev/strconv#ParseBool",
      "description": "StrconvParseBool is an autogenerated function. func ParseBool(str string) (bool, error) ParseBool returns the boolean value represented by the string. It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False. Any other value returns an error.",
      "signature": "func(str str) bool"
    },
    "golang/strconv.parse_float": {
      "name": "StrconvParseFloat",
      "package": "golang/strconv",
      "func": "parse_float",
      "file": "https://pkg.go.dev/strconv#ParseFloat",
      "description": "StrconvParseFloat is an autogenerated function. func ParseFloat(s string, bitSize int) (float64, error) ParseFloat converts the string s to a floating-point number with the precision specified by bitSize: 32 for float32, or 64 for float64. When bitSize=32, the result still has type float64, but it will be convertible to float32 without changing its value.\nParseFloat accepts decimal and hexadecimal floating-point numbers as defined by the Go syntax for [floating-point literals]. If s is well-formed and near a valid floating-point number, ParseFloat returns the nearest floating-point number rounded using IEEE754 unbiased rounding. (Parsing a hexadecimal floating-point value only rounds when there are more bits in the hexadecimal representation than will fit in the mantissa.)\nThe errors that ParseFloat returns have concrete type *NumError and include err.Num = s.\nIf s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax.\nIf s is syntactically well-formed but is more than 1/2 ULP away from the largest floating point number of the given size, ParseFloat returns f = ±Inf, err.Err = ErrRange.\nParseFloat recognizes the string \"NaN\", and the (possibly signed) strings \"Inf\" and \"Infinity\" as their respective special floating point values. It ignores case when matching.\n[floating-point literals]: https://go.dev/ref/spec#Floating-point_literals",
      "signature": "func(s str, bitSize int) float"
    },
    "golang/strconv.parse_int": {
      "name": "StrconvParseInt",
      "package": "golang/strconv",
      "func": "parse_int",
      "file": "https://pkg.go.dev/strconv#ParseInt",
      "description": "StrconvParseInt is an autogenerated function. func ParseInt(s string, base int, bitSize int) (i int64, err error) ParseInt interprets a string s in the given base (0, 2 to 36) and bit size (0 to 64) and returns the corresponding value i.\nThe string may begin with a leading sign: \"+\" or \"-\".\nIf the base argument is 0, the true base is implied by the string's prefix following the sign (if present): 2 for \"0b\", 8 for \"0\" or \"0o\", 16 for \"0x\", and 10 otherwise. Also, for argument base 0 only, underscore characters are permitted as defined by the Go syntax for [integer literals].\nThe bitSize argument specifies the integer type that the result must fit into. Bit sizes 0, 8, 16, 32, and 64 correspond to int, int8, int16, int32, and int64. If bitSize is below 0 or above 64, an error is returned.\nThe errors that ParseInt returns have concrete type [*NumError] and include err.Num = s. If s is empty or contains invalid digits, err.Err = [ErrSyntax] and the returned value is 0; if the value corresponding to s cannot be represented by a signed integer of the given size, err.Err = [ErrRange] and the returned value is the maximum magnitude integer of the appropriate bitSize and sign.\n[integer literals]: https://go.dev/ref/spec#Integer_literals",
      "signature": "func(s str, base int, bitSize int) int"
    },
    "golang/strconv.quote": {
      "name": "StrconvQuote",
      "package": "golang/strconv",
      "func": "quote",
      "file": "https://pkg.go.dev/strconv#Quote",
      "description": "StrconvQuote is an autogenerated function. func Quote(s string) string Quote returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for control characters and non-printable characters as defined by [IsPrint].",
      "signature": "func(s str) str"
    },
    "golang/strconv.quote_to_ascii": {
      "name": "StrconvQuoteToASCII",
      "package": "golang/strconv",
      "func": "quote_to_ascii",
      "file": "https://pkg.go.dev/strconv#QuoteToASCII",
      "description": "StrconvQuoteToASCII is an autogenerated function. func QuoteToASCII(s string) string QuoteToASCII returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for non-ASCII characters and non-printable characters as defined by [IsPrint].",
      "signature": "func(s str) str"
    },
    "golang/strconv.quote_to_graphic": {
      "name": "StrconvQuoteToGraphic",
      "package": "golang/strconv",
      "func": "quote_to_graphic",
      "file": "https://pkg.go.dev/strconv#QuoteToGraphic",
      "description": "StrconvQuoteToGraphic is an autogenerated function. func QuoteToGraphic(s string) string QuoteToGraphic returns a double-quoted Go string literal representing s. The returned string leaves Unicode graphic characters, as defined by [IsGraphic], unchanged and uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for non-graphic characters.",
      "signature": "func(s str) str"
    },
    "golang/strconv.quoted_prefix": {
      "name": "StrconvQuotedPrefix",
      "package": "golang/strconv",
      "func": "quoted_prefix",
      "file": "https://pkg.go.dev/strconv#QuotedPrefix",
      "description": "StrconvQuotedPrefix is an autogenerated function. func QuotedPrefix(s string) (string, error) QuotedPrefix returns the quoted string (as understood by [Unquote]) at the prefix of s. If s does not start with a valid quoted string, QuotedPrefix returns an error.",
      "signature": "func(s str) str"
    },
    "golang/strconv.unquote": {
      "name": "StrconvUnquote",
      "package": "golang/strconv",
      "func": "unquote",
      "file": "https://pkg.go.dev/strconv#Unquote",
      "description": "StrconvUnquote is an autogenerated function. func Unquote(s string) (string, error) Unquote interprets s as a single-quoted, double-quoted, or backquoted Go string literal, returning the string value that s quotes.  (If s is single-quoted, it would be a Go character literal; Unquote returns the corresponding one-character string. For an empty character literal Unquote returns the empty string.)",
      "signature": "func(s str) str"
    },
    "golang/strings.clone": {
      "name": "StringsClone",
      "package": "golang/strings",
      "func": "clone",
      "file": "https://pkg.go.dev/strings#Clone",
      "description": "StringsClone is an autogenerated function. func Clone(s string) string Clone returns a fresh copy of s. It guarantees to make a copy of s into a new allocation, which can be important when retaining only a small substring of a much larger string. Using Clone can help such programs use less memory. Of course, since using Clone makes a copy, overuse of Clone can make programs use more memory. Clone should typically be used only rarely, and only when profiling indicates that it is needed. For strings of length zero the string \"\" will be returned and no allocation is made.",
      "signature": "func(s str) str"
    },
    "golang/strings.compare": {
      "name": "StringsCompare",
      "package": "golang/strings",
      "func": "compare",
      "file": "https://pkg.go.dev/strings#Compare",
      "description": "StringsCompare is an autogenerated function. func Compare(a string, b string) int Compare returns an integer comparing two strings lexicographically. The result will be 0 if a == b, -1 if a < b, and +1 if a > b.\nUse Compare when you need to perform a three-way comparison (with [slices.SortFunc], for example). It is usually clearer and always faster to use the built-in string comparison operators ==, <, >, and so on.",
      "signature": "func(a str, b str) int"
    },
    "golang/strings.contains": {
      "name": "StringsContains",
      "package": "golang/strings",
      "func": "contains",
      "file": "https://pkg.go.dev/strings#Contains",
      "description": "StringsContains is an autogenerated function. func Contains(s string, substr string) bool Contains reports whether substr is within s.",
      "signature": "func(s str, substr str) bool"
    },
    "golang/strings.contains_any": {
      "name": "StringsContainsAny",
      "package": "golang/strings",
      "func": "contains_any",
      "file": "https://pkg.go.dev/strings#ContainsAny",
      "description": "StringsContainsAny is an autogenerated function. func ContainsAny(s string, chars string) bool ContainsAny reports whether any Unicode code points in chars are within s.",
      "signature": "func(s str, chars str) bool"
    },
    "golang/strings.count": {
      "name": "StringsCount",
      "package": "golang/strings",
      "func": "count",
      "file": "https://pkg.go.dev/strings#Count",
      "description": "StringsCount is an autogenerated function. func Count(s string, substr string) int Count counts the number of non-overlapping instances of substr in s. If substr is an empty string, Count returns 1 + the number of Unicode code points in s.",
      "signature": "func(s str, substr str) int"
    },
    "golang/strings.equal_fold": {
      "name": "StringsEqualFold",
      "package": "golang/strings",
      "func": "equal_fold",
      "file": "https://pkg.go.dev/strings#EqualFold",
      "description": "StringsEqualFold is an autogenerated function. func EqualFold(s string, t string) bool EqualFold reports whether s and t, interpreted as UTF-8 strings, are equal under simple Unicode case-folding, which is a more general form of case-insensitivity.",
      "signature": "func(s str, t str) bool"
    },
    "golang/strings.has_prefix": {
      "name": "StringsHasPrefix",
      "package": "golang/strings",
      "func": "has_prefix",
      "file": "https://pkg.go.dev/strings#HasPrefix",
      "description": "StringsHasPrefix is an autogenerated function. func HasPrefix(s string, prefix string) bool HasPrefix reports whether the string s begins with prefix.",
      "signature": "func(s str, prefix str) bool"
    },
    "golang/strings.has_suffix": {
      "name": "StringsHasSuffix",
      "package": "golang/strings",
      "func": "has_suffix",
      "file": "https://pkg.go.dev/strings#HasSuffix",
      "description": "StringsHasSuffix is an autogenerated function. func HasSuffix(s string, suffix string) bool HasSuffix reports whether the string s ends with suffix.",
      "signature": "func(s str, suffix str) bool"
    },
    "golang/strings.index": {
      "name": "StringsIndex",
      "package": "golang/strings",
      "func": "index",
      "file": "https://pkg.go.dev/strings#Index",
      "description": "StringsIndex is an autogenerated function. func Index(s string, substr string) int Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.",
      "signature": "func(s str, substr str) int"
    },
    "golang/strings.index_any": {
      "name": "StringsIndexAny",
      "package": "golang/strings",
      "func": "index_any",
      "file": "https://pkg.go.dev/strings#IndexAny",
      "description": "StringsIndexAny is an autogenerated function. func IndexAny(s string, chars string) int IndexAny returns the index of the first instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s.",
      "signature": "func(s str, chars str) int"
    },
    "golang/strings.join": {
      "name": "StringsJoin",
      "package": "golang/strings",
      "func": "join",
      "file": "https://pkg.go.dev/strings#Join",
      "description": "StringsJoin is an autogenerated function. func Join(elems []string, sep string) string Join concatenates the elements of its first argument to create a single string. The separator string sep is placed between elements in the resulting string.",
      "signature": "func(elems []str, sep str) str"
    },
    "golang/strings.last_index": {
      "name": "StringsLastIndex",
      "package": "golang/strings",
      "func": "last_index",
      "file": "https://pkg.go.dev/strings#LastIndex",
      "description": "StringsLastIndex is an autogenerated function. func LastIndex(s string, substr string) int LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.",
      "signature": "func(s str, substr str) int"
    },
    "golang/strings.last_index_any": {
      "name": "StringsLastIndexAny",
      "package": "golang/strings",
      "func": "last_index_any",
      "file": "https://pkg.go.dev/strings#LastIndexAny",
      "description": "StringsLastIndexAny is an autogenerated function. func LastIndexAny(s string, chars string) int LastIndexAny returns the index of the last instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s.",
      "signature": "func(s str, chars str) int"
    },
    "golang/strings.repeat": {
      "name": "StringsRepeat",
      "package": "golang/strings",
      "func": "repeat",
      "file": "https://pkg.go.dev/strings#Repeat",
      "description": "StringsRepeat is an autogenerated function. func Repeat(s string, count int) string Repeat returns a new string consisting of count copies of the string s.\nIt panics if count is negative or if the result of (len(s) * count) overflows.",
      "signature": "func(s str, count int) str"
    },
    "golang/strings.replace": {
      "name": "StringsReplace",
      "package": "golang/strings",
      "func": "replace",
      "file": "https://pkg.go.dev/strings#Replace",
      "description": "StringsReplace is an autogenerated function. func Replace(s string, old string, new string, n int) string Replace returns a copy of the string s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string. If n < 0, there is no limit on the number of replacements.",
      "signature": "func(s str, old str, new str, n int) str"
    },
    "golang/strings.replace_all": {
      "name": "StringsReplaceAll",
      "package": "golang/strings",
      "func": "replace_all",
      "file": "https://pkg.go.dev/strings#ReplaceAll",
      "description": "StringsReplaceAll is an autogenerated function. func ReplaceAll(s string, old string, new string) string ReplaceAll returns a copy of the string s with all non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string.",
      "signature": "func(s str, old str, new str) str"
    },
    "golang/strings.title": {
      "name": "StringsTitle",
      "package": "golang/strings",
      "func": "title",
      "file": "https://pkg.go.dev/strings#Title",
      "description": "StringsTitle is an autogenerated function. func Title(s string) string Title returns a copy of the string s with all Unicode letters that begin words mapped to their Unicode title case.\nDeprecated: The rule Title uses for word boundaries does not handle Unicode punctuation properly. Use golang.org/x/text/cases instead.",
      "signature": "func(s str) str"
    },
    "golang/strings.to_lower": {
      "name": "StringsToLower",
      "package": "golang/strings",
      "func": "to_lower",
      "file": "https://pkg.go.dev/strings#ToLower",
      "description": "StringsToLower is an autogenerated function. func ToLower(s string) string ToLower returns s with all Unicode letters mapped to their lower case.",
      "signature": "func(s str) str"
    },
    "golang/strings.to_title": {
      "name": "StringsToTitle",
      "package": "golang/strings",
      "func": "to_title",
      "file": "https://pkg.go.dev/strings#ToTitle",
      "description": "StringsToTitle is an autogenerated function. func ToTitle(s string) string ToTitle returns a copy of the string s with all Unicode letters mapped to their Unicode title case.",
      "signature": "func(s str) str"
    },
    "golang/strings.to_upper": {
      "name": "StringsToUpper",
      "package": "golang/strings",
      "func": "to_upper",
      "file": "https://pkg.go.dev/strings#ToUpper",
      "description": "StringsToUpper is an autogenerated function. func ToUpper(s string) string ToUpper returns s with all Unicode letters mapped to their upper case.",
      "signature": "func(s str) str"
    },
    "golang/strings.to_valid_utf_8": {
      "name": "StringsToValidUTF8",
      "package": "golang/strings",
      "func": "to_valid_utf_8",
      "file": "https://pkg.go.dev/strings#ToValidUTF8",
      "description": "StringsToValidUTF8 is an autogenerated function. func ToValidUTF8(s string, replacement string) string ToValidUTF8 returns a copy of the string s with each run of invalid UTF-8 byte sequences replaced by the replacement string, which may be empty.",
      "signature": "func(s str, replacement str) str"
    },
    "golang/strings.trim": {
      "name": "StringsTrim",
      "package": "golang/strings",
      "func": "trim",
      "file": "https://pkg.go.dev/strings#Trim",
      "description": "StringsTrim is an autogenerated function. func Trim(s string, cutset string) string Trim returns a slice of the string s with all leading and trailing Unicode code points contained in cutset removed.",
      "signature": "func(s str, cutset str) str"
    },
    "golang/strings.trim_left": {
      "name": "StringsTrimLeft",
      "package": "golang/strings",
      "func": "trim_left",
      "file": "https://pkg.go.dev/strings#TrimLeft",
      "description": "StringsTrimLeft is an autogenerated function. func TrimLeft(s string, cutset string) string TrimLeft returns a slice of the string s with all leading Unicode code points contained in cutset removed.\nTo remove a prefix, use [TrimPrefix] instead.",
      "signature": "func(s str, cutset str) str"
    },
    "golang/strings.trim_prefix": {
      "name": "StringsTrimPrefix",
      "package": "golang/strings",
      "func": "trim_prefix",
      "file": "https://pkg.go.dev/strings#TrimPrefix",
      "description": "StringsTrimPrefix is an autogenerated function. func TrimPrefix(s string, prefix string) string TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged.",
      "signature": "func(s str, prefix str) str"
    },
    "golang/strings.trim_right": {
      "name": "StringsTrimRight",
      "package": "golang/strings",
      "func": "trim_right",
      "file": "https://pkg.go.dev/strings#TrimRight",
      "description": "StringsTrimRight is an autogenerated function. func TrimRight(s string, cutset string) string TrimRight returns a slice of the string s, with all trailing Unicode code points contained in cutset removed.\nTo remove a suffix, use [TrimSuffix] instead.",
      "signature": "func(s str, cutset str) str"
    },
    "golang/strings.trim_space": {
      "name": "StringsTrimSpace",
      "package": "golang/strings",
      "func": "trim_space",
      "file": "https://pkg.go.dev/strings#TrimSpace",
      "description": "StringsTrimSpace is an autogenerated function. func TrimSpace(s string) string TrimSpace returns a slice of the string s, with all leading and trailing white space removed, as defined by Unicode.",
      "signature": "func(s str) str"
    },
    "golang/strings.trim_suffix": {
      "name": "StringsTrimSuffix",
      "package": "golang/strings",
      "func": "trim_suffix",
      "file": "https://pkg.go.dev/strings#TrimSuffix",
      "description": "StringsTrimSuffix is an autogenerated function. func TrimSuffix(s string, suffix string) string TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged.",
      "signature": "func(s str, suffix str) str"
    },
    "history": {
      "name": "HistoryFunc",
      "package": "",
      "func": "history",
      "file": "history.go",
      "description": "HistoryFunc is special function which returns the value N milliseconds ago. It must store up incoming values until it gets enough to return the desired one. If it doesn't yet have a value, it will initially return the oldest value it can. A restart of the program, will expunge the stored state. This obviously takes more memory, the further back you wish to index. A change in the index var is generally not useful, but it is permitted. Moving it to a smaller value will cause older index values to be expunged. If this is undesirable, a max count could be added. This was not implemented with efficiency in mind. This implements a *time* based hysteresis, since previously this only looked at the last N changed values. Since some functions might not send out un-changed values, it might make more sense this way. This time based hysteresis should tick every precision-width, and store whatever the latest value at that time is. This is implemented wrong, because we can't guarantee the sampling interval is constant, and it's also wasteful. We should implement a better version that keeps track of the time, so that we can pick the closest one and also not need to store duplicates. get a new value in obj.Call instead of having a ticker.",
      "signature": "func(value ?1, index int) ?1"
    },
    "iter.filter": {
      "name": "FilterFunc",
      "package": "iter",
      "func": "filter",
      "file": "iter/filter.go",
      "description": "FilterFunc is the standard filter iterator function that runs a function on each element in a list. That function must return true to keep the element, or false otherwise. The function then returns a list with the subset of kept elements from the input list. This implements the signature: `func(inputs []?1, function func(?1) bool) []?1` instead of the alternate with the two input args swapped, because while the latter is more common with languages that support partial function application, the former variant that we implemented is much more readable when using an inline lambda.",
      "signature": "func(inputs []?1, function func(name-which-can-vary-over-time ?1) bool) []?1"
    },
    "iter.map": {
      "name": "MapFunc",
      "package": "iter",
      "func": "map",
      "file": "iter/map.go",
      "description": "MapFunc is the standard map iterator function that applies a function to each element in a list. It returns a list with the same number of elements as the input list. There is no requirement that the element output type be the same as the input element type. This implements the signature: `func(inputs []?1, function func(?1) ?2) []?2` instead of the alternate with the two input args swapped, because while the latter is more common with languages that support partial function application, the former variant that we implemented is much more readable when using an inline lambda. should that be a different function? I think a different function is best.",
      "signature": "func(inputs []?1, function func(name-which-can-vary-over-time ?1) ?2) []?2"
    },
    "iter.range": {
      "name": "RangeFunc",
      "package": "iter",
      "func": "range",
      "file": "iter/range.go",
      "description": "RangeFunc is a function that ranges over elements on a list according to three possible inputs: start, stop, and step. At least one input is needed, and in that case it's mapped to be the stop argument. Start is used for the function to build lists which start from a chosen number, and step to filter its contents to a subset of all the numbers between start and stop. This function only takes ints as inputs, and outputs a list of ints."
    },
    "len": {
      "name": "Len",
      "package": "",
      "func": "len",
      "file": "len.go",
      "description": "Len returns the number of elements in a list or the number of key pairs in a map. It can operate on either of these types.",
      "signature": "func(0 ?1) int"
    },
    "list.concat": {
      "name": "ListConcatFunc",
      "package": "list",
      "func": "concat",
      "file": "list/list_concat.go",
      "description": "ListConcatFunc is a function which combines a number of lists into one list. It can take one or more arguments. It combines them in argument order."
    },
    "list.lookup": {
      "name": "ListLookupFunc",
      "package": "list",
      "func": "lookup",
      "file": "list/list_lookup.go",
      "description": "ListLookupFunc is a list index lookup function. It can take either two or three arguments. The first argument is the list to lookup a value in. The second is the integer index. If you specify a third argument, then this value will be returned if the list index is not present. If the third argument is omitted, then this function errors if the list index is not present. Passing a negative index will always result in an error."
    },
    "list_lookup": {
      "name": "ListLookup",
      "package": "",
      "func": "list_lookup",
      "file": "list_lookup.go",
      "description": "ListLookup returns the value corresponding to the input index in the list.",
      "signature": "func(list []?1, index int) ?1"
    },
    "list_lookup_default": {
      "name": "ListLookupDefault",
      "package": "",
      "func": "list_lookup_default",
      "file": "list_lookup_default.go",
      "description": "ListLookupDefault returns the value corresponding to the input index in the list. If the value is not present, it returns the default value supplied.",
      "signature": "func(list []?1, index int, default ?1) ?1"
    },
    "local.pool": {
      "name": "PoolFunc",
      "package": "local",
      "func": "pool",
      "file": "local/pool.go",
      "description": "PoolFunc is a function that returns a unique integer from a pool of numbers. Within a given namespace, it returns the same integer for a given name. It is a simple mechanism to allocate numbers to different inputs when we don't have a hashing alternative. It does not allocate zero.",
      "signature": "func(namespace str, uid str) int"
    },
    "local.vardir": {
      "name": "VarDirFunc",
      "package": "local",
      "func": "vardir",
      "file": "local/vardir.go",
      "description": "VarDirFunc is a function that returns the absolute, full path in the deploy from an input path that is relative to the calling file. If you pass it an empty string, you'll just get the absolute deploy directory path that you're in.",
      "signature": "func(path str) str"
    },
    "map.keys": {
      "name": "MapKeys",
      "package": "map",
      "func": "keys",
      "file": "map/map_keys.go",
      "description": "MapKeys returns a list of keys from the map.",
      "signature": "func(x map{?1: ?2}) []?1"
    },
    "map.lookup": {
      "name": "MapLookupFunc",
      "package": "map",
      "func": "lookup",
      "file": "map/map_lookup.go",
      "description": "MapLookupFunc is a key map lookup function. It can take either two or three arguments. The first argument is the map to lookup a value by key in. The second is the key to use. If you specify a third argument, then this value will be returned if the map key is not present. If the third argument is omitted, then this function errors if the map key is not present."
    },
    "map.values": {
      "name": "MapValues",
      "package": "map",
      "func": "values",
      "file": "map/map_values.go",
      "description": "MapValues returns a list of values from the map.",
      "signature": "func(x map{?1: ?2}) []?2"
    },
    "map_lookup": {
      "name": "MapLookup",
      "package": "",
      "func": "map_lookup",
      "file": "map_lookup.go",
      "description": "MapLookup returns the value corresponding to the input key in the map.",
      "signature": "func(map map{?1: ?2}, key ?1) ?2"
    },
    "map_lookup_default": {
      "name": "MapLookupDefault",
      "package": "",
      "func": "map_lookup_default",
      "file": "map_lookup_default.go",
      "description": "MapLookupDefault returns the value corresponding to the input key in the map. If the value is not present, it returns the default value supplied.",
      "signature": "func(map map{?1: ?2}, key ?1, default ?2) ?2"
    },
    "math.fortytwo": {
      "name": "FortyTwo",
      "package": "math",
      "func": "fortytwo",
      "file": "math/fortytwo.go",
      "description": "FortyTwo returns 42 as either an int or a float. This is not especially useful, but was built for a fun test case of a simple poly function with two different return types, but no input args.",
      "signature": "func() ?1"
    },
    "math.minus1": {
      "name": "Minus1",
      "package": "math",
      "func": "minus1",
      "file": "math/minus1.go",
      "description": "Minus1 takes an int and subtracts one from it.",
      "signature": "func(x int) int"
    },
    "math.mod": {
      "name": "Mod",
      "package": "math",
      "func": "mod",
      "file": "math/mod.go",
      "description": "Mod returns mod(x, y), the remainder of x/y. The two values must be either both of KindInt or both of KindFloat, and it will return the same kind. If you pass in a divisor of zero, this will error, eg: mod(x, 0) = NaN.",
      "signature": "func(0 ?1, 1 ?1) ?1"
    },
    "math.pow": {
      "name": "Pow",
      "package": "math",
      "func": "pow",
      "file": "math/pow.go",
      "description": "Pow returns x ^ y, the base-x exponential of y.",
      "signature": "func(x float, y float) float"
    },
    "math.sqrt": {
      "name": "Sqrt",
      "package": "math",
      "func": "sqrt",
      "file": "math/sqrt.go",
      "description": "Sqrt returns sqrt(x), the square root of x.",
      "signature": "func(x float) float"
    },
    "net.cidr_to_first": {
      "name": "CidrToFirst",
      "package": "net",
      "func": "cidr_to_first",
      "file": "net/cidr_to_ip.go",
      "description": "CidrToFirst returns the first usable IP from a CIDR address.",
      "signature": "func(a str) str"
    },
    "net.cidr_to_ip": {
      "name": "CidrToIP",
      "package": "net",
      "func": "cidr_to_ip",
      "file": "net/cidr_to_ip.go",
      "description": "CidrToIP returns the IP from a CIDR address.",
      "signature": "func(a str) str"
    },
    "net.cidr_to_last": {
      "name": "CidrToLast",
      "package": "net",
      "func": "cidr_to_last",
      "file": "net/cidr_to_ip.go",
      "description": "CidrToLast returns the last IP from a CIDR address. It's often used as the \"broadcast\" ip.",
      "signature": "func(a str) str"
    },
    "net.cidr_to_mask": {
      "name": "CidrToMask",
      "package": "net",
      "func": "cidr_to_mask",
      "file": "net/cidr_to_ip.go",
      "description": "CidrToMask returns the subnet mask from a CIDR address.",
      "signature": "func(a str) str"
    },
    "net.cidr_to_network": {
      "name": "CidrToNetwork",
      "package": "net",
      "func": "cidr_to_network",
      "file": "net/cidr_to_ip.go",
      "description": "CidrToNetwork returns the network CIDR from a CIDR address.",
      "signature": "func(a str) str"
    },
    "net.cidr_to_prefix": {
      "name": "CidrToPrefix",
      "package": "net",
      "func": "cidr_to_prefix",
      "file": "net/cidr_to_ip.go",
      "description": "CidrToPrefix returns the prefix from a CIDR address. For example, if you give us 192.0.2.0/24 then we will return \"24\" as a string.",
      "signature": "func(a str) str"
    },
    "net.is_mac": {
      "name": "IsMac",
      "package": "net",
      "func": "is_mac",
      "file": "net/macfmt.go",
      "description": "IsMac takes a string and returns true if it's a mac in the standard format.",
      "signature": "func(a str) bool"
    },
    "net.macfmt": {
      "name": "MacFmt",
      "package": "net",
      "func": "macfmt",
      "file": "net/macfmt.go",
      "description": "MacFmt takes a MAC address with hyphens and converts it to a format with colons.",
      "signature": "func(a str) str"
    },
    "net.macs": {
      "name": "Macs",
      "package": "net",
      "func": "macs",
      "file": "net/macs.go",
      "description": "Macs returns the list of mac addresses that are seen on the machine.\n",
      "signature": "func() []str"
    },
    "net.oldmacfmt": {
      "name": "OldMacFmt",
      "package": "net",
      "func": "oldmacfmt",
      "file": "net/macfmt.go",
      "description": "OldMacFmt takes a MAC address with colons and converts it to a format with hyphens. This is the old deprecated style that nobody likes.",
      "signature": "func(a str) str"
    },
    "net.url_parser": {
      "name": "URLParser",
      "package": "net",
      "func": "url_parser",
      "file": "net/url_parser.go",
      "description": "URLParser takes a URL as a string, and extracts the different components of the URL: scheme, host, path, and query. The function will error out if the given URL doesn't contain a valid URL, as this is a requirement of the underlying net/url library. Note that additional fields may be added to the output in the future.",
      "signature": "func(0 str) struct{scheme str; host str; path str; raw_query str}"
    },
    "os.args": {
      "name": "Args",
      "package": "os",
      "func": "args",
      "file": "os/args.go",
      "description": "Args returns the `argv` of the current process. Keep in mind that this will return different values depending on how this is deployed, so don't expect a result on your deploy client to behave the same as a server receiving code.",
      "signature": "func() []str"
    },
    "os.expand_home": {
      "name": "ExpandHome",
      "package": "os",
      "func": "expand_home",
      "file": "os/expand_home.go",
      "description": "ExpandHome expands any tilde patterns in the input path according to the currently running user. While most of the time its likely this is `root`, there is no reason the program is necessarily running as root!",
      "signature": "func(0 str) str"
    },
    "os.family": {
      "name": "Family",
      "package": "os",
      "func": "family",
      "file": "os/family.go",
      "description": "Family returns the distro family.",
      "signature": "func() str"
    },
    "os.is_family_archlinux": {
      "name": "IsFamilyArchLinux",
      "package": "os",
      "func": "is_family_archlinux",
      "file": "os/family.go",
      "description": "IsFamilyArchLinux detects if the os family is archlinux.",
      "signature": "func() bool"
    },
    "os.is_family_debian": {
      "name": "IsFamilyDebian",
      "package": "os",
      "func": "is_family_debian",
      "file": "os/family.go",
      "description": "IsFamilyDebian detects if the os family is debian.",
      "signature": "func() bool"
    },
    "os.is_family_redhat": {
      "name": "IsFamilyRedHat",
      "package": "os",
      "func": "is_family_redhat",
      "file": "os/family.go",
      "description": "IsFamilyRedHat detects if the os family is redhat.",
      "signature": "func() bool"
    },
    "os.is_virtual": {
      "name": "IsVirtual",
      "package": "os",
      "func": "is_virtual",
      "file": "os/is_virtual.go",
      "description": "IsVirtual is a function that executes two types of checks: first, it checks whether we're running on Linux. If that's the case, we run checks related with the presence of virtualization platforms. If any of those checks returns true, then so does this function. Otherwise, it's assumed that it's not a virtualized environment.",
      "signature": "func() bool"
    },
    "os.modinfo_loaded": {
      "name": "ModinfoLoadedFunc",
      "package": "os",
      "func": "modinfo_loaded",
      "file": "os/modinfo.go",
      "description": "ModinfoLoadedFunc is a function that determines if a linux module exists and is loaded. This is similar to what you can determine from the `lsmod` command. If the module does not even exist, this also returns false.",
      "signature": "func(module str) bool"
    },
    "os.parse_distro_uid": {
      "name": "ParseDistroUID",
      "package": "os",
      "func": "parse_distro_uid",
      "file": "os/distro.go",
      "description": "ParseDistroUID parses a distro UID into its component values. If it cannot parse correctly, all the struct fields have the zero values. NOTE: The UID pattern is subject to change.",
      "signature": "func(0 str) struct{distro str; version str; arch str}"
    },
    "os.readfile": {
      "name": "ReadFileFunc",
      "package": "os",
      "func": "readfile",
      "file": "os/readfile.go",
      "description": "ReadFileFunc is a function that reads the full contents from a local file. If the file contents change or the file path changes, a new string will be sent. Please note that this is different from the readfile function in the deploy package.",
      "signature": "func(filename str) str"
    },
    "os.readfilewait": {
      "name": "ReadFileWaitFunc",
      "package": "os",
      "func": "readfilewait",
      "file": "os/readfilewait.go",
      "description": "ReadFileWaitFunc is a function that reads the full contents from a local file. If the file contents change or the file path changes, a new string will be sent. This is different from the normal readfile in that if will not error if the file doesn't exist. If the file is not found, it returns the empty string. If the file re-appears, it returns those new contents. This function will eventually be deprecated when the function graph error system is stable.",
      "signature": "func(filename str) str"
    },
    "os.system": {
      "name": "SystemFunc",
      "package": "os",
      "func": "system",
      "file": "os/system.go",
      "description": "SystemFunc runs a string as a shell command, then produces each line from stdout. If the input string changes, then the commands are executed one after the other and the concatenation of their outputs is produced line by line.\nNote that in the likely case in which the process emits several lines one after the other, the downstream resources might not run for every line unless the \"Meta:realize\" metaparam is set to true.\nFurthermore, there is no guarantee that every intermediate line will be seen, particularly if there is no delay between them. Only the last line is guaranteed. As a result, it is not recommend to use this for timing or coordination. If you are using this for an intermediate value, or a non-declarative system, then it's likely you are using this wrong.",
      "signature": "func(cmd str) str"
    },
    "panic": {
      "name": "Panic",
      "package": "",
      "func": "panic",
      "file": "panic.go",
      "description": "Panic returns an error when it receives a non-empty string or a true boolean. The error should cause the function engine to shutdown. If there's no error, it returns false.",
      "signature": "func(x ?1) bool"
    },
    "random1": {
      "name": "Random1Func",
      "package": "",
      "func": "random1",
      "file": "random1.go",
      "description": "Random1Func returns one random string of a certain length. If you change the length, then it will produce a new random value.",
      "signature": "func(length int) str"
    },
    "regexp.match": {
      "name": "Match",
      "package": "regexp",
      "func": "match",
      "file": "regexp/match.go",
      "description": "Match matches whether a string matches the regexp pattern.",
      "signature": "func(pattern str, s str) bool"
    },
    "strings.join_nonempty": {
      "name": "JoinNonempty",
      "package": "strings",
      "func": "join_nonempty",
      "file": "strings/join_nonempty.go",
      "description": "JoinNonempty behaves exactly like the regular string join, except it filters out empty elements first. Since this behaviour is commonly useful when writing scripts, we include it as a built-in primitive, since it is also cheaper than running the graph changing, filter function. function as previously described, and replace it with this implementation.",
      "signature": "func(s []str, sep str) str"
    },
    "strings.left_pad": {
      "name": "LeftPad",
      "package": "strings",
      "func": "left_pad",
      "file": "strings/pad.go",
      "description": "LeftPad adds multiples of the pad string to the left of the input string until it reaches a minimum length. If the padding string is not an integer multiple of the missing length to pad, then this will overshoot. It is better to overshoot than to undershoot because if you need a string of a precise length, then it's easier to truncate the result, rather than having to pad even more. Most scenarios pad with a single char meaning this is not even an issue.",
      "signature": "func(s str, pad str, len int) str"
    },
    "strings.right_pad": {
      "name": "RightPad",
      "package": "strings",
      "func": "right_pad",
      "file": "strings/pad.go",
      "description": "RightPad adds multiples of the pad string to the right of the input string until it reaches a minimum length. If the padding string is not an integer multiple of the missing length to pad, then this will overshoot. It is better to overshoot than to undershoot because if you need a string of a precise length, then it's easier to truncate the result, rather than having to pad even more. Most scenarios pad with a single char meaning this is not even an issue.",
      "signature": "func(s str, pad str, len int) str"
    },
    "strings.split": {
      "name": "Split",
      "package": "strings",
      "func": "split",
      "file": "strings/split.go",
      "description": "Split splits the input string using the separator and returns the segments as a list.",
      "signature": "func(a str, b str) []str"
    },
    "strings.substr": {
      "name": "SubStr",
      "package": "strings",
      "func": "substr",
      "file": "strings/substring.go",
      "description": "SubStr returns a substring of the input string from low to high.",
      "signature": "func(s str, low int, high int) str"
    },
    "strings.to_lower": {
      "name": "ToLower",
      "package": "strings",
      "func": "to_lower",
      "file": "strings/to_lower.go",
      "description": "ToLower turns a string to lowercase.",
      "signature": "func(a str) str"
    },
    "sys.cpu_count": {
      "name": "CPUCount",
      "package": "sys",
      "func": "cpu_count",
      "file": "sys/cpucount.go",
      "description": "CPUCount is a fact that returns the current CPU count.",
      "signature": "func() int"
    },
    "sys.defaultenv": {
      "name": "DefaultEnv",
      "package": "sys",
      "func": "defaultenv",
      "file": "sys/env.go",
      "description": "DefaultEnv gets environment variable by name or returns default if non existing.",
      "signature": "func(0 str, 1 str) str"
    },
    "sys.env": {
      "name": "Env",
      "package": "sys",
      "func": "env",
      "file": "sys/env.go",
      "description": "Env returns a map of all keys and their values.",
      "signature": "func() map{str: str}"
    },
    "sys.getenv": {
      "name": "GetEnv",
      "package": "sys",
      "func": "getenv",
      "file": "sys/env.go",
      "description": "GetEnv gets environment variable by name or returns empty string if non existing.",
      "signature": "func(0 str) str"
    },
    "sys.hasenv": {
      "name": "HasEnv",
      "package": "sys",
      "func": "hasenv",
      "file": "sys/env.go",
      "description": "HasEnv returns true if environment variable exists.",
      "signature": "func(0 str) bool"
    },
    "sys.hostname": {
      "name": "Hostname",
      "package": "sys",
      "func": "hostname",
      "file": "sys/hostname.go",
      "description": "Hostname is a function that returns the hostname.",
      "signature": "func() str"
    },
    "sys.load": {
      "name": "Load",
      "package": "sys",
      "func": "load",
      "file": "sys/load.go",
      "description": "Load is a fact which returns the current system load.",
      "signature": "func() struct{x1 float; x5 float; x15 float}"
    },
    "sys.uptime": {
      "name": "Uptime",
      "package": "sys",
      "func": "uptime",
      "file": "sys/uptime.go",
      "description": "Uptime is a fact which returns the current uptime of your system.",
      "signature": "func() int"
    },
    "test.fastcount": {
      "name": "FastCount",
      "package": "test",
      "func": "fastcount",
      "file": "test/fastcount.go",
      "description": "FastCount is a fact that counts up as fast as possible from zero forever.",
      "signature": "func() int"
    },
    "test.one_instance_a": {
      "name": "OneInstance",
      "package": "test",
      "func": "one_instance_a",
      "file": "test/oneinstance.go",
      "description": "OneInstance is a fact which flips a bool repeatedly. This is an example fact and is not meant for serious computing. This would be better served by a flip function which you could specify an interval for.",
      "signature": "func() str"
    },
    "test.one_instance_b": {
      "name": "OneInstance",
      "package": "test",
      "func": "one_instance_b",
      "file": "test/oneinstance.go",
      "description": "OneInstance is a fact which flips a bool repeatedly. This is an example fact and is not meant for serious computing. This would be better served by a flip function which you could specify an interval for.",
      "signature": "func() str"
    },
    "test.one_instance_c": {
      "name": "OneInstance",
      "package": "test",
      "func": "one_instance_c",
      "file": "test/oneinstance.go",
      "description": "OneInstance is a fact which flips a bool repeatedly. This is an example fact and is not meant for serious computing. This would be better served by a flip function which you could specify an interval for.",
      "signature": "func() str"
    },
    "test.one_instance_d": {
      "name": "OneInstance",
      "package": "test",
      "func": "one_instance_d",
      "file": "test/oneinstance.go",
      "description": "OneInstance is a fact which flips a bool repeatedly. This is an example fact and is not meant for serious computing. This would be better served by a flip function which you could specify an interval for.",
      "signature": "func() str"
    },
    "test.one_instance_e": {
      "name": "OneInstance",
      "package": "test",
      "func": "one_instance_e",
      "file": "test/oneinstance.go",
      "description": "OneInstance is a fact which flips a bool repeatedly. This is an example fact and is not meant for serious computing. This would be better served by a flip function which you could specify an interval for.",
      "signature": "func() str"
    },
    "test.one_instance_f": {
      "name": "OneInstance",
      "package": "test",
      "func": "one_instance_f",
      "file": "test/oneinstance.go",
      "description": "OneInstance is a fact which flips a bool repeatedly. This is an example fact and is not meant for serious computing. This would be better served by a flip function which you could specify an interval for.",
      "signature": "func() str"
    },
    "test.one_instance_g": {
      "name": "OneInstance",
      "package": "test",
      "func": "one_instance_g",
      "file": "test/oneinstance.go",
      "description": "OneInstance is a fact which flips a bool repeatedly. This is an example fact and is not meant for serious computing. This would be better served by a flip function which you could specify an interval for.",
      "signature": "func() str"
    },
    "test.one_instance_h": {
      "name": "OneInstance",
      "package": "test",
      "func": "one_instance_h",
      "file": "test/oneinstance.go",
      "description": "OneInstance is a fact which flips a bool repeatedly. This is an example fact and is not meant for serious computing. This would be better served by a flip function which you could specify an interval for.",
      "signature": "func() str"
    },
    "util.hostname_mapper": {
      "name": "HostnameMapper",
      "package": "util",
      "func": "hostname_mapper",
      "file": "util/hostname_mapper.go",
      "description": "HostnameMapper takes a map from mac address to hostname, and finds a hostname that corresponds to one of the mac addresses on this machine. If it cannot find a match, it returns the empty string. If it's ambiguous, it errors. This is useful for bootstrapping the hostname setup on hosts.\n",
      "signature": "func(0 map{str: str}) str"
    },
    "value.get": {
      "name": "GetFunc",
      "package": "value",
      "func": "get",
      "file": "value/get.go",
      "description": "GetFunc is special function which looks up the stored `Any` field in the value resource that it gets it from. If it is initialized with a fixed Type field, then it becomes a statically typed version that can only return keys of that type. It is instead recommended to use the Get* functions that are more strictly typed."
    },
    "value.get_bool": {
      "name": "GetFunc",
      "package": "value",
      "func": "get_bool",
      "file": "value/get.go",
      "description": "GetFunc is special function which looks up the stored `Any` field in the value resource that it gets it from. If it is initialized with a fixed Type field, then it becomes a statically typed version that can only return keys of that type. It is instead recommended to use the Get* functions that are more strictly typed.",
      "signature": "func(key str) struct{value bool; ready bool}"
    },
    "value.get_float": {
      "name": "GetFunc",
      "package": "value",
      "func": "get_float",
      "file": "value/get.go",
      "description": "GetFunc is special function which looks up the stored `Any` field in the value resource that it gets it from. If it is initialized with a fixed Type field, then it becomes a statically typed version that can only return keys of that type. It is instead recommended to use the Get* functions that are more strictly typed.",
      "signature": "func(key str) struct{value float; ready bool}"
    },
    "value.get_int": {
      "name": "GetFunc",
      "package": "value",
      "func": "get_int",
      "file": "value/get.go",
      "description": "GetFunc is special function which looks up the stored `Any` field in the value resource that it gets it from. If it is initialized with a fixed Type field, then it becomes a statically typed version that can only return keys of that type. It is instead recommended to use the Get* functions that are more strictly typed.",
      "signature": "func(key str) struct{value int; ready bool}"
    },
    "value.get_str": {
      "name": "GetFunc",
      "package": "value",
      "func": "get_str",
      "file": "value/get.go",
      "description": "GetFunc is special function which looks up the stored `Any` field in the value resource that it gets it from. If it is initialized with a fixed Type field, then it becomes a statically typed version that can only return keys of that type. It is instead recommended to use the Get* functions that are more strictly typed.",
      "signature": "func(key str) struct{value str; ready bool}"
    },
    "world.getval": {
      "name": "GetValFunc",
      "package": "world",
      "func": "getval",
      "file": "world/getval.go",
      "description": "GetValFunc is special function which returns the value of a given key in the exposed world.",
      "signature": "func(key str) struct{value str; exists bool}"
    },
    "world.kvlookup": {
      "name": "KVLookupFunc",
      "package": "world",
      "func": "kvlookup",
      "file": "world/kvlookup.go",
      "description": "KVLookupFunc is special function which returns all the values of a given key in the exposed world. It is similar to exchange, but it does not set a key. Since exchange has been deprecated, you will want to use this in conjunction with a resource to set the desired value.",
      "signature": "func(namespace str) map{str: str}"
    },
    "world.schedule": {
      "name": "ScheduleFunc",
      "package": "world",
      "func": "schedule",
      "file": "world/schedule.go",
      "description": "ScheduleFunc is special function which determines where code should run in the cluster.",
      "signature": "func(namespace str) []str"
    },
    "world/collect.res": {
      "name": "ResFunc",
      "package": "world/collect",
      "func": "res",
      "file": "world/collect/res.go",
      "description": "ResFunc is a special function which returns information about available resource collection data. You specify the kind, and it tells you which of those are available and from which hosts.\nThis function is a simplified version of the internal _collect function.\nfilter as a second or third arg to attempt to reduce the amount of raw data that we have to filter out in mcl.",
      "signature": "func(kind str) []struct{name str; host str}"
    }
  }
}
