{"resources":{"augeas":{"name":"AugeasRes","kind":"augeas","description":"AugeasRes is a resource that enables you to use the augeas resource.\nCurrently only allows you to change simple files (e.g sshd_config).\n","fields":{"file":{"name":"File","type":"str","description":"File is the path to the file targeted by this resource.\n"},"lens":{"name":"Lens","type":"str","description":"Lens is the lens used by this resource. If specified, mgmt\nwill lower the augeas overhead by only loading that lens.\n"},"sets":{"name":"Sets","type":"[]struct{path str; value str}","description":"Sets is a list of changes that will be applied to the file, in the\nform of [\"path\", \"value\"]. mgmt will run augeas.Get() before\naugeas.Set(), to prevent changing the file when it is not needed.\n"}}},"aws:ec2":{"name":"AwsEc2Res","kind":"aws:ec2","description":"AwsEc2Res is an AWS EC2 resource. In order to create a client session, your\nAWS credentials must be present in ~/.aws - For detailed instructions see\nhttp://docs.aws.amazon.com/cli/latest/userguide/cli-config-files.html\n","fields":{"erroronmalformedpost":{"name":"ErrorOnMalformedPost","type":"bool","description":"ErrorOnMalformedPost controls whether or not malformed HTTP post\nrequests, that cause JSON decoder errors, will also make the engine\nshut down. If ErrorOnMalformedPost set to true and an error occurs,\nWatch() will return the error and the engine will shut down.\n"},"imageid":{"name":"ImageID","type":"str","description":"ImageID to use, and note that it must be available on the chosen\nregion.\n"},"region":{"name":"Region","type":"str","description":"Region must match one of the AwsRegions. This list is static at the\nmoment.\n"},"state":{"name":"State","type":"str","description":"State must be running, stopped, or terminated.\n"},"type":{"name":"Type","type":"str","description":"Type of ec2 instance, eg: t2.micro for example.\n"},"userdata":{"name":"UserData","type":"str","description":"UserData is used to run bash and cloud-init commands on first launch.\nSee http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html\nfor documantation and examples.\n"},"watchendpoint":{"name":"WatchEndpoint","type":"str","description":"WatchEndpoint is the public url of the sns endpoint, eg:\nhttp://server:12345/ for example.\n"},"watchlistenaddr":{"name":"WatchListenAddr","type":"str","description":"WatchListenAddr is the local address or port that the sns listens on,\neg: 10.0.0.0:23456 or 23456.\n"}}},"config:etcd":{"name":"ConfigEtcdRes","kind":"config:etcd","description":"ConfigEtcdRes is a resource that sets mgmt's etcd configuration.\n","fields":{"allow_size_shutdown":{"name":"AllowSizeShutdown","type":"bool","description":"AllowSizeShutdown is a required safety flag that you must set to true\nif you want to allow causing a cluster shutdown by setting\nIdealClusterSize to zero.\n"},"idealclustersize":{"name":"IdealClusterSize","type":"int","description":"IdealClusterSize is the requested minimum size of the cluster. If you\nset this to zero, it will cause a cluster wide shutdown if\nAllowSizeShutdown is true. If it's not true, then it will cause a\nvalidation error.\n"}}},"consul:kv":{"name":"ConsulKVRes","kind":"consul:kv","description":"ConsulKVRes is a resource that writes a value into a Consul datastore. The\nname of the resource can either be the key name, or the concatenation of the\nserver address and the key name: http://127.0.0.1:8500/my-key. If the param\nkeys are specified, then those are used. If the Name cannot be properly\nparsed by url.Parse, then it will be considered as the Key's value. If the\nKey is specified explicitly, then we won't use anything from the Name.\n","fields":{"address":{"name":"Address","type":"str","description":"Address is the address of the Consul server. Default: 127.0.0.1:8500.\n"},"key":{"name":"Key","type":"str","description":"Key is the name of the key. Defaults to the name of the resource.\n"},"scheme":{"name":"Scheme","type":"str","description":"Scheme is the URI scheme for the Consul server. Default: http.\n"},"token":{"name":"Token","type":"str","description":"Token is used to provide an ACL token to use for this resource.\n"},"value":{"name":"Value","type":"str","description":"Value is the value for the key.\n"}}},"cron":{"name":"CronRes","kind":"cron","description":"CronRes is a systemd-timer cron resource.\nTODO: If we want to have an actual `crond` resource, name it LegacyCron.\n","fields":{"accuracysec":{"name":"AccuracySec","type":"str","description":"AccuracySec is the accuracy of the timer in systemd-time time span\nformat. It defaults to one minute.\n"},"persistent":{"name":"Persistent","type":"bool","description":"Persistent, if true, means the time when the service unit was last\ntriggered is stored on disk. When the timer is activated, the service\nunit is triggered immediately if it would have been triggered at\nleast once during the time when the timer was inactive. It defaults\nto false.\n"},"randomizeddelaysec":{"name":"RandomizedDelaySec","type":"str","description":"RandomizedDelaySec delays the timer by a randomly selected, evenly\ndistributed amount of time between 0 and the specified time value.\nThe value must be a valid systemd-time time span.\n"},"remainafterelapse":{"name":"RemainAfterElapse","type":"bool","description":"RemainAfterElapse, if true, means an elapsed timer will stay loaded,\nand its state remains queriable. If false, an elapsed timer unit that\ncannot elapse anymore is unloaded. It defaults to true.\n"},"session":{"name":"Session","type":"bool","description":"Session, if true, creates the timer as the current user, rather than\nroot. The service it points to must also be a user unit. It defaults\nto false.\n"},"state":{"name":"State","type":"str","description":"State must be 'exists' or 'absent'.\n"},"time":{"name":"Time","type":"str","description":"Time must be used with all triggers. For 'OnCalendar', it must be in\nthe format defined in 'man systemd-time' under the heading 'Calendar\nEvents'. For all other triggers, time should be a valid time span as\ndefined in 'man systemd-time'\n"},"trigger":{"name":"Trigger","type":"str","description":"Trigger is the type of timer. Valid types are 'OnCalendar',\n'OnActiveSec'. 'OnBootSec'. 'OnStartupSec'. 'OnUnitActiveSec', and\n'OnUnitInactiveSec'. For more information see 'man systemd.timer'.\n"},"unit":{"name":"Unit","type":"str","description":"Unit is the name of the systemd service unit. It is only necessary to\nset if you want to specify a service with a different name than the\nresource.\n"},"wakesystem":{"name":"WakeSystem","type":"bool","description":"WakeSystem, if true, will cause the system to resume from suspend,\nshould it be suspended and if the system supports this. It defaults\nto false.\n"}}},"deploy:tar":{"name":"DeployTar","kind":"deploy:tar","description":"DeployTar is a resource that archives a deploy filesystem using tar, thus\ncombining them into a single file. The name of the resource is the path to\nthe resultant archive file. The input comes from the current deploy. This\nuses hashes to determine if something was changed, so as a result, this may\nnot be suitable if you can create a sha256 hash collision.\nTODO: support send/recv to send the output instead of writing to a file?\nTODO: This resource is very similar to the tar resource. Update that one if\nthis changes, or consider porting this to use that as a composite resource.\nTODO: consider using a `deploy.get_archive()` function to make a .tar, and a\nfile resource to store those contents on disk with whatever mode we want...\n","fields":{"format":{"name":"Format","type":"int","description":"Format is the header format to use. If you change this, then the\nfile will get rearchived. The strange thing is that it seems the\nheader format is stored for each individual file. The available\nvalues are: const.res.tar.format.unknown, const.res.tar.format.ustar,\nconst.res.tar.format.pax, and const.res.tar.format.gnu which have\nvalues of 0, 2, 4, and 8 respectively.\n"},"path":{"name":"Path","type":"str","description":"Path, which defaults to the name if not specified, represents the\ndestination path for the compressed file being created. It must be an\nabsolute path, and as a result must start with a slash. Since it is a\nfile, it must not end with a slash.\n"}}},"dhcp:host":{"name":"DHCPHostRes","kind":"dhcp:host","description":"DHCPHostRes is a representation of a static host assignment in DHCP.\n","fields":{"ip":{"name":"IP","type":"str","description":"IP is the IPv4 address with the CIDR suffix. The suffix is required\nbecause it specifies the netmask to be used in the DHCPv4 protocol.\nFor example, you might specify 192.0.2.42/24 which represents a mask\nof 255.255.255.0 that will be sent.\n"},"mac":{"name":"Mac","type":"str","description":"Mac is the mac address of the host in lower case and separated with\ncolons.\n"},"nbp":{"name":"NBP","type":"str","description":"NBP is the network boot program URL. This is used for the tftp server\nname and the boot file name. For example, you might use:\ntftp://192.0.2.13/pxelinux.0 for a common bios, pxe boot setup. Note\nthat the \"scheme\" prefix is required, and that it's impossible to\nspecify a file that doesn't begin with a leading slash. If you wish\nto specify a \"root less\" file (common for legacy tftp setups) then\nyou can use this feature in conjunction with the NBPPath parameter.\nFor DHCPv4, the scheme must be \"tftp\".\n"},"nbp_path":{"name":"NBPPath","type":"str","description":"NBPPath overrides the path that is sent for the nbp protocols. By\ndefault it is taken from parsing a URL in NBP, but this can override\nthat. This is useful if you require a path that doesn't start with a\nslash. This is sometimes desirable for legacy tftp setups.\n"},"server":{"name":"Server","type":"str","description":"Server is the name of the dhcp server resource to group this into. If\nit is omitted, and there is only a single dhcp resource, then it will\nbe grouped into it automatically. If there is more than one main dhcp\nresource being used, then the grouping behaviour is *undefined* when\nthis is not specified, and it is not recommended to leave this blank!\n"}}},"dhcp:range":{"name":"DHCPRangeRes","kind":"dhcp:range","description":"DHCPRangeRes is a representation of a range allocator in DHCP. To declare a\nrange you must specify either the `network` field or the `from` and `to`\nfields as ip with cidr's, or `from` and `to` fields without cidr's but with\nthe `mask` field as either a dotted netmask or a `/number` field. If you\nspecify none of these, then the resource name will be interpreted the same\nway that the `network` field os. The last ip in the range (which is often\nused as a broadcast address) is never allocated.\nTODO: Add a setting to determine if we should allocate the last address.\n","fields":{"from":{"name":"From","type":"str","description":"From is the start address in the range inclusive. If it is specified\nin cidr notation, then the `mask` field must not be used. Otherwise\nit must be used. In both situations the cidr or mask must be\nconsistent with the `to` field. If this field is used, you must not\nuse the `network` field.\n"},"mask":{"name":"Mask","type":"str","description":"Mask is the cidr or netmask of ip addresses in the specified range.\nThis field must only be used if both `from` and `to` are specified,\nand if neither of them specify a cidr suffix. If neither do, then the\nmask here can be in either dotted format or, preferably, in cidr\nformat by starting with a slash.\n"},"nbp":{"name":"NBP","type":"str","description":"NBP is the network boot program URL. This is used for the tftp server\nname and the boot file name. For example, you might use:\ntftp://192.0.2.13/pxelinux.0 for a common bios, pxe boot setup. Note\nthat the \"scheme\" prefix is required, and that it's impossible to\nspecify a file that doesn't begin with a leading slash. If you wish\nto specify a \"root less\" file (common for legacy tftp setups) then\nyou can use this feature in conjunction with the NBPPath parameter.\nFor DHCPv4, the scheme must be \"tftp\".\n"},"nbp_path":{"name":"NBPPath","type":"str","description":"NBPPath overrides the path that is sent for the nbp protocols. By\ndefault it is taken from parsing a URL in NBP, but this can override\nthat. This is useful if you require a path that doesn't start with a\nslash. This is sometimes desirable for legacy tftp setups.\n"},"network":{"name":"Network","type":"str","description":"Network is the network number and cidr to determine the range. For\nexample, the common network range of 192.168.42.1 to 192.168.42.255\nshould have a network field here of 192.168.42.0/24. You can either\nspecify this field or `from` and `to`, but not a different\ncombination. If you don't specify any of these fields, then the\nresource name will be parsed as if it was used here.\n"},"persist":{"name":"Persist","type":"bool","description":"Persist should be true if you want to persist the lease information\nto disk so that a new (or changed) invocation of this resource with\nthe same name, will regain that existing initial state at startup.\nTODO: Add a new param to persist the data to etcd in the world API so\nthat we could have redundant dhcp servers which share the same state.\nThis would require having a distributed allocator through etcd too!\nTODO: Consider adding a new param to erase the persisted record\ndatabase if any field param changes, as opposed to just looking at\nthe name field alone.\nXXX: This is currently not implemented.\n"},"server":{"name":"Server","type":"str","description":"Server is the name of the dhcp server resource to group this into. If\nit is omitted, and there is only a single dhcp resource, then it will\nbe grouped into it automatically. If there is more than one main dhcp\nresource being used, then the grouping behaviour is *undefined* when\nthis is not specified, and it is not recommended to leave this blank!\n"},"skip":{"name":"Skip","type":"[]str","description":"Skip is a list ip's in either cidr or standalone representation which\nwill be skipped and not allocated.\n"},"to":{"name":"To","type":"str","description":"To is the end address in the range inclusive. If it is specified in\ncidr notation, then the `mask` field must not be used. Otherwise it\nmust be used. In both situations the cidr or mask must be consistent\nwith the `from` field. If this field is used, you must not use the\n`network` field.\n"}}},"dhcp:server":{"name":"DHCPServerRes","kind":"dhcp:server","description":"DHCPServerRes is a simple dhcp server resource. It responds to dhcp client\nrequests, but does not actually apply any state. The name is used as the\naddress to listen on, unless the Address field is specified, and in that case\nit is used instead. The resource can offer up dhcp client leases from any\nnumber of dhcp:host resources which will get autogrouped into this resource\nat runtime.\n\nThis server is not meant as a featureful replacement for the venerable dhcpd,\nbut rather as a simple, dynamic, integrated alternative for bootstrapping new\nmachines and clusters in an elegant way.\n\nTODO: Add autoedges between the Interface and any identically named NetRes.\n","fields":{"address":{"name":"Address","type":"str","description":"Address is the listen address to use for the dhcp server. It is\ncommon to use `:67` (the standard) to listen on UDP port 67 on all\naddresses.\n"},"dns":{"name":"DNS","type":"[]str","description":"DNS represents a list of DNS servers to offer to the DHCP client.\nXXX: Is it mandatory? https://github.com/insomniacslk/dhcp/issues/359\n"},"interface":{"name":"Interface","type":"str","description":"Interface is interface to bind to. For example `eth0` for the common\ncase. You may leave this field blank to not run any specific binding.\nXXX: You need to actually specify an interface here at the moment. :(\nBUG: https://github.com/insomniacslk/dhcp/issues/372\n"},"leasetime":{"name":"LeaseTime","type":"str","description":"LeaseTime is the default lease duration in a format that is parseable\nby the golang time.ParseDuration function, for example \"60s\" or \"10m\"\nor \"1h42m13s\". If it is unspecified, then a default will be used. If\nthe empty string is specified, then no lease time will be set in the\nDHCP protocol, and your DHCP server might not work as you intend.\n"},"nbp":{"name":"NBP","type":"str","description":"NBP is the network boot program URL. This is used for the tftp server\nname and the boot file name. For example, you might use:\ntftp://192.0.2.13/pxelinux.0 for a common bios, pxe boot setup. Note\nthat the \"scheme\" prefix is required, and that it's impossible to\nspecify a file that doesn't begin with a leading slash. If you wish\nto specify a \"root less\" file (common for legacy tftp setups) then\nyou can use this feature in conjunction with the NBPPath parameter.\nFor DHCPv4, the scheme must be \"tftp\". This values is used as the\ndefault for all dhcp:host resources. You can specify this here, and\nthe NBPPath per-resource and they will successfully combine.\n"},"routers":{"name":"Routers","type":"[]str","description":"Routers represents a list of routers to offer to the DHCP client. It\nis most common to only specify one unless you know what you're doing.\n"},"serverid":{"name":"ServerID","type":"str","description":"ServerID is a unique IPv4 identifier for this server as specified in\nthe DHCPv4 protocol. It is almost always the IP address of the DHCP\nserver. If you don't specify this, then we will attempt to determine\nit from the specified interface. If it is set to the empty string,\nthen this won't be set in the DHCP protocol, and your DHCP server\nmight not work as you intend. Otherwise, if a valid value is\nspecified, then this will be used as long as it validates correctly.\nPlease note that if you attempt to automatically determine this from\nthe specified interface, then this only happens at runtime when the\nfirst DHCP request needs this or during CheckApply, either of which\ncould fail if for some reason it is not available.\n"}}},"docker:container":{"name":"DockerContainerRes","kind":"docker:container","description":"DockerContainerRes is a docker container resource.\n","fields":{"apiversion":{"name":"APIVersion","type":"str","description":"APIVersion allows you to override the host's default client API\nversion.\n"},"cmd":{"name":"Cmd","type":"[]str","description":"Cmd is a command, or list of commands to run on the container.\n"},"env":{"name":"Env","type":"[]str","description":"Env is a list of environment variables. E.g. [\"VAR=val\",].\n"},"force":{"name":"Force","type":"bool","description":"Force, if true, this will destroy and redeploy the container if the\nimage is incorrect.\n"},"image":{"name":"Image","type":"str","description":"Image is a docker image, or image:tag.\n"},"ports":{"name":"Ports","type":"map{str: map{int: int}}","description":"Ports is a map of port bindings. E.g. {\"tcp\" =\u003e {80 =\u003e 8080},}.\n"},"state":{"name":"State","type":"str","description":"State of the container must be running, stopped, or removed.\n"}}},"docker:image":{"name":"DockerImageRes","kind":"docker:image","description":"DockerImageRes is a docker image resource. The resource's name must be a\ndocker image in any supported format (url, image, or image:tag).\n","fields":{"apiversion":{"name":"APIVersion","type":"str","description":"APIVersion allows you to override the host's default client API\nversion.\n"},"state":{"name":"State","type":"str","description":"State of the image must be exists or absent.\n"}}},"exec":{"name":"ExecRes","kind":"exec","description":"ExecRes is an exec resource for running commands.\n","fields":{"args":{"name":"Args","type":"[]str","description":"Args is a list of args to pass to Cmd. This can be used *instead* of\npassing the full command and args as a single string to Cmd. It can\nonly be used when a Shell is *not* specified. The advantage of this\nis that you don't have to worry about escape characters.\n"},"cmd":{"name":"Cmd","type":"str","description":"Cmd is the command to run. If this is not specified, we use the name.\nRemember that if you're not using `Shell` (the default) then adding\nsingle quotes around args make them part of the actual values. IOW,\nif your command is: \"touch '/tmp/foo'\", then (1) it probably won't be\nable to find the \"touch\" command (use /usr/bin/touch instead) and (2)\nthe file won't be in the /tmp/ directory, it will be an oddly named\nfile that contains two single quotes, and it will likely error since\nthe dir path doesn't exist. In general, it's best to use the `Args`\nfield instead of including them here.\nXXX: if not using shell, don't allow args here, force them to args!\n"},"creates":{"name":"Creates","type":"str","description":"Creates is the absolute file path to check for before running the\nmain cmd. If this path exists, then the cmd will not run. More\nprecisely we attempt to `stat` the file, so it must succeed for a\nskip. This also adds a watch on this path which re-checks things when\nit changes.\n"},"cwd":{"name":"Cwd","type":"str","description":"Cwd is the dir to run the command in. If empty, then this will use\nthe working directory of the calling process. (This process is mgmt,\nnot the process being run here.) Keep in mind that if you're running\nthis command as a user that does not have perms to the current\ndirectory, you may wish to set this to `/` to avoid hitting an error\nsuch as: `could not change directory to \"/root\": Permission denied`.\n"},"donecmd":{"name":"DoneCmd","type":"str","description":"DoneCmd is the command that runs after the regular Cmd runs\nsuccessfully. This is a useful pattern to avoid the shelling out to\nbash simply to do `$cmd \u0026\u0026 echo done \u003e /tmp/donefile`. If this\ncommand errors, it behaves as if the normal Cmd had errored.\n"},"donecwd":{"name":"DoneCwd","type":"str","description":"DoneCwd is the Cwd for the DoneCmd. See the docs for Cwd.\n"},"doneshell":{"name":"DoneShell","type":"str","description":"DoneShell is the Shell for the DoneCmd. See the docs for Shell.\n"},"env":{"name":"Env","type":"map{str: str}","description":"Env allows the user to specify environment variables for script\nexecution. These are taken using a map of format of VAR_NAME -\u003e value.\n"},"group":{"name":"Group","type":"str","description":"Group is the (optional) group to use to execute the command. It is\nused for any command being run.\n"},"ifcmd":{"name":"IfCmd","type":"str","description":"IfCmd is the command that runs to guard against running the Cmd. If\nthis command succeeds, then Cmd *will* be run. If this command\nreturns a non-zero result, then the Cmd will not be run. Any error\nscenario or timeout will cause the resource to error.\n"},"ifcwd":{"name":"IfCwd","type":"str","description":"IfCwd is the Cwd for the IfCmd. See the docs for Cwd.\n"},"ifshell":{"name":"IfShell","type":"str","description":"IfShell is the Shell for the IfCmd. See the docs for Shell.\n"},"shell":{"name":"Shell","type":"str","description":"Shell is the (optional) shell to use to run the cmd. If you specify\nthis, then you can't use the Args parameter.\n"},"timeout":{"name":"Timeout","type":"int","description":"Timeout is the number of seconds to wait before sending a Kill to the\nrunning command. If the Kill is received before the process exits,\nthen this be treated as an error.\n"},"user":{"name":"User","type":"str","description":"User is the (optional) user to use to execute the command. It is used\nfor any command being run.\n"},"watchcmd":{"name":"WatchCmd","type":"str","description":"WatchCmd is the command to run to detect event changes. Each line of\noutput from this command is treated as an event.\n"},"watchcwd":{"name":"WatchCwd","type":"str","description":"WatchCwd is the Cwd for the WatchCmd. See the docs for Cwd.\n"},"watchshell":{"name":"WatchShell","type":"str","description":"WatchShell is the Shell for the WatchCmd. See the docs for Shell.\n"}}},"file":{"name":"FileRes","kind":"file","description":"FileRes is a file and directory resource. Dirs are defined by names ending in\na slash.\n","fields":{"basename":{"name":"Basename","type":"str","description":"Basename is used to override the path basename. (The file portion.)\n"},"content":{"name":"Content","type":"str","description":"Content specifies the file contents to use. If this is nil, they are\nleft undefined. It cannot be combined with the Source or Fragments\nparameters.\n"},"dirname":{"name":"Dirname","type":"str","description":"Dirname is used to override the path dirname. (The directory\nportion.)\n"},"force":{"name":"Force","type":"bool","description":"Force must be set if we want to perform an unusual operation, such as\nchanging a file into a directory or vice-versa.\n"},"fragments":{"name":"Fragments","type":"[]str","description":"Fragments specifies that the file is built from a list of individual\nfiles. If one of the files is a directory, then the list of files in\nthat directory are the fragments to combine. Multiple of these can be\nused together, although most simple cases will probably only either\ninvolve a single directory path or a fixed list of individual files.\nAll paths are absolute and as a result must start with a slash. The\ndirectories (if any) must end with a slash as well. This cannot be\ncombined with the Content or Source parameters. If a file with param\nis reversed, the reversed file is one that has `Content` set instead.\nAutomatic edges will be added from these fragments. This currently\nisn't recursive in that if a fragment is a directory, this only\nsearches one level deep at the moment.\n"},"group":{"name":"Group","type":"str","description":"Group specifies the file group. You can specify either the string\nname, or a string representation of the group integer gid.\n"},"mode":{"name":"Mode","type":"str","description":"Mode is the mode of the file as a string representation of the octal\nform or symbolic form.\n"},"owner":{"name":"Owner","type":"str","description":"Owner specifies the file owner. You can specify either the string\nname, or a string representation of the owner integer uid.\n"},"path":{"name":"Path","type":"str","description":"Path, which defaults to the name if not specified, represents the\ndestination path for the file or directory being managed. It must be\nan absolute path, and as a result must start with a slash.\n"},"purge":{"name":"Purge","type":"bool","description":"Purge specifies that when true, any unmanaged file in this file\ndirectory will be removed. As a result, this file resource must be a\ndirectory. This isn't particularly meaningful if you don't also set\nRecurse to true. This doesn't work with Content or Fragments.\n"},"recurse":{"name":"Recurse","type":"bool","description":"Recurse specifies if you want to work recursively on the resource. It\nis used when copying a source directory, or to determine if a watch\nshould be recursive or not. When making a directory, this is required\nif you'd need the parent directories to be made as well. (Analogous\nto the `mkdir -p` option.)\nFIXME: There are some unimplemented cases where we should look at it.\n"},"source":{"name":"Source","type":"str","description":"Source specifies the source contents for the file resource. It cannot\nbe combined with the Content or Fragments parameters. It must be an\nabsolute path, and it can point to a file or a directory. If it\npoints to a file, then that will will be copied throuh directly. If\nit points to a directory, then it will copy the directory \"rsync\nstyle\" onto the file destination. As a result, if this is a file,\nthen the main file res must be a file, and if it is a directory, then\nthis must be a directory. To meaningfully copy a full directory, you\nalso need to specify the Recurse parameter, which is currently\nrequired. If you want an existing dir to be turned into a file (or\nvice-versa) instead of erroring, then you'll also need to specify the\nForce parameter. If source is undefined and the file path is a\ndirectory, then a directory will be created. If left undefined, and\ncombined with the Purge option too, then any unmanaged file in this\ndir will be removed.\n"},"state":{"name":"State","type":"str","description":"State specifies the desired state of the file. It can be either\n`exists` or `absent`. If you do not specify this, we will not be able\nto create or remove a file if it might be logical for another\nparam to require that. Instead it will error. This means that this\nfield is not implied by specifying some content or a mode.\n"}}},"firewalld":{"name":"FirewalldRes","kind":"firewalld","description":"FirewalldRes is a simple resource to interact with the firewalld service. It\nis not a replacement for a modern, robust tool like `shorewall`, but it has\nits uses such as for small, desktop use cases. The API of this resource might\nchange to either add new features, split this into multiple resources, or to\noptimize the execution if it turns out to be too expensive to run large\namounts of these as-is. The name variable currently has no useful purpose.\nKeep in mind that this resource requires root permissions to be able change\nthe firewall settings and to monitor for changes. The change detection uses\nthe nftables monitor facility.\n","fields":{"ports":{"name":"Ports","type":"[]str","description":"Ports are the list of port/protocol combinations to manage to the\ndesired state. These are strings of port number (slash) protocol like\n`4280/tcp` and `38/udp`.\n"},"services":{"name":"Services","type":"[]str","description":"Services are the list of services to manage to the desired state.\nThese are single lower case strings like `dhcp`, and `tftp`.\n"},"state":{"name":"State","type":"str","description":"State is the desired state.\n"},"zone":{"name":"Zone","type":"str","description":"Zone is the name of the zone to manage. If unspecified, we will\nattempt to get the default zone automatically. In this situation, it\nis possible that this default changes over time if it is acted upon\nby external tools that use firewalld.\n"}}},"group":{"name":"GroupRes","kind":"group","description":"GroupRes is a user group resource.\n","fields":{"gid":{"name":"GID","type":"int","description":"GID is the group's gid.\n"},"state":{"name":"State","type":"str","description":"State is `exists` or `absent`.\n"}}},"gzip":{"name":"GzipRes","kind":"gzip","description":"GzipRes is a resource that compresses a path or some raw data using gzip. The\nname of the resource is the path to the resultant compressed file. The input\ncan either come from a file path if specified with Input or it looks at the\nContent field for raw data. It uses hashes to determine if something was\nchanged, so as a result, this may not be suitable if you can create a sha256\nhash collision.\nTODO: support send/recv to send the output instead of writing to a file?\n","fields":{"content":{"name":"Content","type":"str","description":"Content is the raw data to compress. If Input is not specified, then\nwe use this parameter. If you forget to specify both of these, then\nyou will compress zero-length data!\nTODO: If this is also empty should we just error at Validate?\nFIXME: Do we need []byte here? Do we need a binary type?\n"},"input":{"name":"Input","type":"str","description":"Input represents the input file to be compressed. It must be an\nabsolute path, and as a result must start with a slash. Since it is a\nfile, it must not end with a slash. If this is specified, we use it,\notherwise we use the Content parameter.\n"},"level":{"name":"Level","type":"int","description":"Level is the compression level to use. If you change this, then the\nfile will get recompressed. The available values are:\nconst.res.gzip.level.no_compression, const.res.gzip.level.best_speed,\nconst.res.gzip.level.best_compression,\nconst.res.gzip.level.default_compression, and\nconst.res.gzip.level.huffman_only.\n"},"path":{"name":"Path","type":"str","description":"Path, which defaults to the name if not specified, represents the\ndestination path for the compressed file being created. It must be an\nabsolute path, and as a result must start with a slash. Since it is a\nfile, it must not end with a slash.\n"}}},"hetzner:vm":{"name":"HetznerVMRes","kind":"hetzner:vm","description":"HetznerVMRes is a Hetzner cloud resource (1). It connects with the cloud API\nusing the hcloud-go package provided by Hetzner. The API token for a new\nproject must be generated manually, via the cloud console (2), before this\nresource can establish a connection with the API. One Hetzner resource\nrepresents one server instance, and multiple instances can be registered\nunder the same project. A resource in the \"absent\" state only exists as a\nlocal mcl struct, and does not exist as server instance on Hetzner's side.\nNOTE: the Hetzner cloud console must be used to create a new project,\ngenerate the corresponding API token, and initialize the desired SSH keys.\nAll registered SSH keys are used when creating a server, and a subset of\nthose can be enabled for rescue mode via the \"serverrescuekeys\" param.\nNOTE: complete and up-to-date serverconfig options must be requested from the\nHetzner API, but hcloud-go-getopts (3) provides a static reference.\nNOTE: this resources requires polling, via the \"Meta:poll\" param. The Hetzner\nAPI imposes a maximum rate of 3600 requests per hour that must be taken into\naccount for intensive and/or long term operations. When running N hetzner:vm\nresources under the same Hetzner project, it is recommended to use a polling\ninterval of at least N seconds. High rates of change to other params will\nrequire additional API requests at CheckApply. When frequent param updates\nare expected for long term operations, it is reommended to increase the\npolling interval again to prevent rate limit errors.\nNOTE: running multiple concurrent mcl scripts on the same resource might\ncause unexpected behavior in the API or the resource state. Use with care.\nTODO: build tests for hetzner:vm? But hcloud-go has no mocking package.\n1) https://docs.hetzner.cloud/\n2) https://console.hetzner.cloud/\n3) https://github.com/jefmasereel/hcloud-go-getopts\n","fields":{"allowrebuild":{"name":"AllowRebuild","type":"str","description":"AllowRebuild provides flexible protection against unexpected server\nrebuilds. Any changes to the \"servertype\", \"datacenter\" or \"image\" params\nrequire a destructive rebuild, which deletes all data on that server.\nThe user must explicitly allow these operations with AllowRebuild.\nChoose from three options: \"ifneeded\" allows all rebuilds that are needed\nby CheckApply to meet the specified params. \"ignore\" disables these\nrebuilds, but continues without error. The default option (\"\") disables\nalways returns an error when CheckApply requests a rebuild.\nNOTE: Soft updates related to power and rescue mode are always allowed,\nbecause they are only required for explicit changes to resource fields.\nTODO: add AllowReboot if any indirect poweroffs are ever implemented.\n"},"apitoken":{"name":"APIToken","type":"str","description":"APIToken specifies the unique API token corresponding to a Hetzner\nproject. Keep this token private! It provides full access to this\nproject, so a leaked token will be vulnerable to abuse. Read it from\na local file or the mgmt deploy, or provide it directly as a string.\nNOTE: It must be generated manually via https://console.hetzner.cloud/.\nNOTE: This token is usually a 64 character alphanumeric string.\n"},"datacenter":{"name":"Datacenter","type":"str","description":"Datacenter determines where the resource is hosted.  A complete and\nup-to-date list of options must be requested from the Hetzner API, but\nhcloud-go-getopts (url) provides a static reference. The datacenter\noptions include \"nbg1-dc3\", \"fsn1-dc14\", \"hel1-dc2\" etc.\nhttps://github.com/JefMasereel/hcloud-go-getopts/\n"},"image":{"name":"Image","type":"str","description":"Image determines the operating system to be installed. A complete and\nup-to-date list of options must be requested from the Hetzner API, but\nhcloud-go-getopts (url) provides a static reference. The image type\noptions include \"centos-7\", \"ubuntu-18.04\", \"debian-10\" etc.\nhttps://github.com/JefMasereel/hcloud-go-getopts/\n"},"serverrescuekeys":{"name":"ServerRescueSSHKeys","type":"[]str","description":"ServerRescueSSHKeys can be used to select a subset of keys that should be\nenabled for rescue mode operations over SSH. From all SSH keys known to\nthe project client, choose a subset of keys by name, as an array of\nstrings. New keys must first be added manually via the cloud console.\nAn error is thrown if a given keyname is not recognized by the client.\nNOTE: live changes to this keylist while rescue mode is already enabled\nare not (yet) detected or applied by CheckApply.\nTODO: improve ssh key handling at checkApplyRescueMode and serverRebuild.\n"},"serverrescuemode":{"name":"ServerRescueMode","type":"str","description":"ServerRescueMode specifies the image type used when enabling rescue mode.\nThe supported image types are \"linux32\", \"linux64\" and \"freebsd64\".\nAlternatively, leave this string empty to disable rescue mode (default).\nOther input values will not pass Validate and result in an error.\nNOTE: rescue mode can not be enabled if the server is absent.\nNOTE: Rescue mode can be used to log into the server over SSH and access\nthe disks when the normal OS has trouble booting on its own.\n"},"servertype":{"name":"ServerType","type":"str","description":"ServerType determines the machine type as defined by Hetzner. A complete\nand up-to-date list of options must be requested from the Hetzner API,\nbut hcloud-go-getopts (url) provides a static reference. Basic servertype\noptions include \"cx11\", \"cx21\", \"cx31\" etc.\nNOTE: make sure to check the price of the selected servertype! The listed\nexamples are usually very cheap, but never free. Price and availability\ncan also be dependent on the selected datacenter.\nhttps://github.com/JefMasereel/hcloud-go-getopts/\nTODO: set some kind of cost-based protection policy?\n"},"state":{"name":"State","type":"str","description":"State specifies the desired state of the server instance. The supported\noptions are \"\" (undefined), \"absent\", \"exists\", \"off\" and \"running\".\nHetznerStateUndefined (\"\") leaves the state undefined by default.\nHetznerStateExists (\"exists\") indicates that the server must exist.\nHetznerStateAbsent (\"absent\") indicates that the server must not exist.\nHetznerStateRunning (\"running\") tells the server it must be powered on.\nHetznerStateOff (\"off\") tells the server it must be powered off.\nNOTE: any other inputs will not pass Validate and result in an error.\nNOTE: setting the state of a live server to \"absent\" will delete all data\nand services that are located on that instance! Use with caution.\n"},"userdata":{"name":"UserData","type":"str","description":"UserData can be used to run commands on the server instance at creation.\nhttps://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html.\n"},"waitinterval":{"name":"WaitInterval","type":"int","description":"WaitInterval is the interval in seconds that is used when waiting for\ntransient states to converge between intermediate operations. A zero\nvalue causes the waiter to run without delays (burst requests). Although\nsuch burst requests are allowed, it is recommended to use a wait interval\nthat keeps the total request rate under 3600 requests per hour. Take\nthese factors into account: polling rate \"Meta:poll\", number of active\nresources under the same Hetzner project, and the expected rate of param\nupdates. This will help to prevent rate limit errors.\n"},"waittimeout":{"name":"WaitTimeout","type":"int","description":"WaitTimeout will cancel wait loops if they do not exit cleanly before\nthe expected time in seconds, in order to detect defective loops and\navoid unnecessary consumption of computational resources.\n"}}},"hostname":{"name":"HostnameRes","kind":"hostname","description":"HostnameRes is a resource that allows setting and watching the hostname. If\nyou don't specify any parameters, the Name is used. The Hostname field is\nused if none of the other parameters are used. If the parameters are set to\nthe empty string, then those variants are not managed by the resource.\n","fields":{"hostname":{"name":"Hostname","type":"str","description":"Hostname specifies the hostname we want to set in all of the places\nthat it's possible. This is the fallback value for all the three\nfields below. If only this Hostname field is specified, this will set\nall tree fields (PrettyHostname, StaticHostname, TransientHostname)\nto this value.\n"},"pretty_hostname":{"name":"PrettyHostname","type":"str","description":"PrettyHostname is a free-form UTF8 host name for presentation to the\nuser.\n"},"static_hostname":{"name":"StaticHostname","type":"str","description":"StaticHostname is the one configured in /etc/hostname or a similar\nfile. It is chosen by the local user. It is not always in sync with\nthe current host name as returned by the gethostname() system call.\n"},"transient_hostname":{"name":"TransientHostname","type":"str","description":"TransientHostname is the one configured via the kernel's\nsethostbyname(). It can be different from the static hostname in case\nDHCP or mDNS have been configured to change the name based on network\ninformation.\n"}}},"http:file":{"name":"HTTPFileRes","kind":"http:file","description":"HTTPFileRes is a file that exists within an http server. The name is used as\nthe public path of the file, unless the filename field is specified, and in\nthat case it is used instead. The way this works is that it autogroups at\nruntime with an existing http resource, and in doing so makes the file\nassociated with this resource available for serving from that http server.\n","fields":{"data":{"name":"Data","type":"str","description":"Data is the file content that should be used as the source for this\nfile resource. It must not be combined with the path field.\nTODO: should this be []byte instead?\n"},"filename":{"name":"Filename","type":"str","description":"Filename is the name of the file this data should appear as on the\nhttp server.\n"},"path":{"name":"Path","type":"str","description":"Path is the absolute path to a file that should be used as the source\nfor this file resource. It must not be combined with the data field.\nIf this corresponds to a directory, then it will used as a root dir\nthat will be served as long as the resource name or Filename are also\na directory ending with a slash.\n"},"server":{"name":"Server","type":"str","description":"Server is the name of the http server resource to group this into. If\nit is omitted, and there is only a single http resource, then it will\nbe grouped into it automatically. If there is more than one main http\nresource being used, then the grouping behaviour is *undefined* when\nthis is not specified, and it is not recommended to leave this blank!\n"}}},"http:flag":{"name":"HTTPFlagRes","kind":"http:flag","description":"HTTPFlagRes is a special path that exists within an http server. The name is\nused as the public path of the flag, unless the path field is specified, and\nin that case it is used instead. The way this works is that it autogroups at\nruntime with an existing http resource, and in doing so makes the flag\nassociated with this resource available to cause actions when it receives a\nrequest on that http server. If you create a flag which responds to the same\ntype of request as an http:file resource or any other kind of resource, it is\nundefined behaviour which will answer the request. The most common clash will\nhappen if both are present at the same path.\n","fields":{"key":{"name":"Key","type":"str","description":"Key is the querystring name that is used to capture a value as.\n"},"path":{"name":"Path","type":"str","description":"Path is the path that this will present as on the http server.\n"},"server":{"name":"Server","type":"str","description":"Server is the name of the http server resource to group this into. If\nit is omitted, and there is only a single http resource, then it will\nbe grouped into it automatically. If there is more than one main http\nresource being used, then the grouping behaviour is *undefined* when\nthis is not specified, and it is not recommended to leave this blank!\n"}}},"http:proxy":{"name":"HTTPProxyRes","kind":"http:proxy","description":"HTTPProxyRes is a resource representing a special path that exists within an\nhttp server. The name is used as the public path of the endpoint, unless the\npath field is specified, and in that case it is used instead. The way this\nworks is that it autogroups at runtime with an existing http resource, and in\ndoing so makes the path associated with this resource available when serving\nfiles. When something under the path is accessed, this is pulled from the\nbacking http server, which makes an http client connection if needed to pull\nthe authoritative file down, saves it locally for future use, and then\nreturns it to the original http client caller. On a subsequent call, if the\ncache was not invalidated, the file doesn't need to be fetched from the\nnetwork. In effect, this works as a caching http proxy. If you create this as\na resource which responds to the same type of request as an http:file\nresource or any other kind of resource, it is undefined behaviour which will\nanswer the request. The most common clash will happen if both are present at\nthe same path. This particular implementation stores some file data in memory\nas a convenience instead of streaming directly to clients. This makes locking\nmuch easier, but is wasteful. If you plan on using this for huge files and on\nsystems with low amounts of memory, you might want to optimize this. The\nresultant proxy path is determined by subtracting the `Sub` field from the\n`Path` (and request path) and then appending the result to the `Head` field.\n","fields":{"cache":{"name":"Cache","type":"str","description":"Cache is an absolute path to a location on disk where cached files\ncan be stored. If this is empty then we will not cache any files.\nTODO: We could add future in-memory stores, a checksum feature, etc\n"},"head":{"name":"Head","type":"str","description":"Head is the string to add on as a prefix to the new URL we are\nbuilding for the proxy. If this is empty, the proxy can't work, and\nwe can only rely on what is available in our local cache. This is\ntypically the protocol and hostname for the backing server.\n"},"path":{"name":"Path","type":"str","description":"Path is the path that this presents as on the grouped http server. It\noverrides the Name var if specified.\n"},"server":{"name":"Server","type":"str","description":"Server is the name of the http server resource to group this into. If\nit is omitted, and there is only a single http resource, then it will\nbe grouped into it automatically. If there is more than one main http\nresource being used, then the grouping behaviour is *undefined* when\nthis is not specified, and it is not recommended to leave this blank!\n"},"sub":{"name":"Sub","type":"str","description":"Sub is the string to remove from the start of the request, the path\nof which is looking at the Name/Path field to see if it matches. If\nit matches, it then translates to the destination server by removing\nthis `Sub` string from the start of the path request, and then\nprepending on the `Head` field to get to the resultant proxy URL. If\nthis is empty, then nothing is subtracted.\n"}}},"http:server":{"name":"HTTPServerRes","kind":"http:server","description":"HTTPServerRes is an http server resource. It serves files, but does not\nactually apply any state. The name is used as the address to listen on,\nunless the Address field is specified, and in that case it is used instead.\nThis resource can offer up files for serving that are specified either inline\nin this resource by specifying an http root, or as http:file resources which\nwill get autogrouped into this resource at runtime. The two methods can be\ncombined as well.\n\nThis server also supports autogrouping some more magical resources into it.\nFor example, the http:flag and http:ui resources add in magic endpoints.\n\nThis server is not meant as a featureful replacement for the venerable and\nmodern httpd servers out there, but rather as a simple, dynamic, integrated\nalternative for bootstrapping new machines and clusters in an elegant way.\n\nTODO: add support for TLS\nXXX: Add an http:flag resource that lets an http client set a flag somewhere!\nXXX: Add a http:ui resource that functions can read data from!\nXXX: The http:ui resource can also take in values from those functions!\n","fields":{"address":{"name":"Address","type":"str","description":"Address is the listen address to use for the http server. It is\ncommon to use `:80` (the standard) to listen on TCP port 80 on all\naddresses.\n"},"read_timeout":{"name":"ReadTimeout","type":"int","description":"ReadTimeout is the maximum duration in seconds for reading during the\nhttp request. If it is zero, then there is no timeout. If this is\nunspecified, then the value of Timeout is used instead if it is set.\nFor more information, see the golang net/http Server documentation.\n"},"root":{"name":"Root","type":"str","description":"Root is the root directory that we should serve files from. If it is\nnot specified, then it is not used. Any http file resources will have\nprecedence over anything in here, in case the same path exists twice.\nTODO: should we have a flag to determine the precedence rules here?\n"},"shutdown_timeout":{"name":"ShutdownTimeout","type":"int","description":"ShutdownTimeout is the maximum duration in seconds to wait for the\nserver to shutdown gracefully before calling Close. By default it is\nnice to let client connections terminate gracefully, however it might\ntake longer than we are willing to wait, particularly if one is long\npolling or running a very long download. As a result, you can set a\ntimeout here. The default is zero which means it will wait\nindefinitely. The shutdown process can also be cancelled by the\ninterrupt handler which this resource supports. If this is\nunspecified, then the value of Timeout is used instead if it is set.\n"},"timeout":{"name":"Timeout","type":"int","description":"Timeout is the maximum duration in seconds to use for unspecified\ntimeouts. In other words, when this value is specified, it is used as\nthe value for the other *Timeout values when they aren't used. Put\nanother way, this makes it easy to set all the different timeouts\nwith a single parameter.\n"},"write_timeout":{"name":"WriteTimeout","type":"int","description":"WriteTimeout is the maximum duration in seconds for writing during\nthe http request. If it is zero, then there is no timeout. If this is\nunspecified, then the value of Timeout is used instead if it is set.\nFor more information, see the golang net/http Server documentation.\n"}}},"kv":{"name":"KVRes","kind":"kv","description":"KVRes is a resource which writes a key/value pair into cluster wide storage.\nIt will ensure that the key is set to the requested value. The one exception\nis that if you use the SkipLessThan parameter, then it will only replace the\nstored value with the requested value if it is greater than that stored one.\nThis allows the KV resource to be used in fast acting, finite state machines\nwhich have monotonically increasing state values that represent progression.\nThe one exception is that when this resource receives a refresh signal, then\nit will set the value to be the exact one if they are not identical already.\n","fields":{"key":{"name":"Key","type":"str","description":"Key represents the key to set. If it is not specified, the Name value\nis used instead.\n"},"skipcmpstyle":{"name":"SkipCmpStyle","type":"int","description":"SkipCmpStyle is the type of compare function used when determining if\nthe value is greater when using the SkipLessThan parameter.\n"},"skiplessthan":{"name":"SkipLessThan","type":"bool","description":"SkipLessThan causes the value to be updated as long as it is greater.\n"},"value":{"name":"Value","type":"str","description":"Value represents the string value to set. If this value is nil or,\nundefined, then this will delete that key.\n"}}},"mount":{"name":"MountRes","kind":"mount","description":"MountRes is a systemd mount resource that adds/removes entries from\n/etc/fstab, and makes sure the defined device is mounted or unmounted\naccordingly. The mount point is set according to the resource's name.\n","fields":{"device":{"name":"Device","type":"str","description":"Device is the location of the device or image.\n"},"freq":{"name":"Freq","type":"int","description":"Freq is the dump frequency.\n"},"options":{"name":"Options","type":"map{str: str}","description":"Options are mount options.\n"},"passno":{"name":"PassNo","type":"int","description":"PassNo is the verification order.\n"},"state":{"name":"State","type":"str","description":"State must be exists or absent. If absent, remaining fields are\nignored.\n"},"type":{"name":"Type","type":"str","description":"Type of the filesystem.\n"}}},"msg":{"name":"MsgRes","kind":"msg","description":"MsgRes is a resource that writes messages to logs.\n","fields":{"journal":{"name":"Journal","type":"bool","description":"Journal should be true to enable systemd journaled (journald) output.\n"},"syslog":{"name":"Syslog","type":"bool","description":"Syslog should be true to enable traditional syslog output. This is\nprobably going to somewhere in `/var/log/` on your filesystem.\n"}}},"net":{"name":"NetRes","kind":"net","description":"NetRes is a network interface resource based on netlink. It manages the state\nof a network link. Configuration is also stored in a networkd configuration\nfile, so the network is available upon reboot. The name of the resource is\nthe string representing the network interface name. This could be \"eth0\" for\nexample. It supports flipping the state if you ask for it to be reversible.\n","fields":{"addrs":{"name":"Addrs","type":"[]str","description":"Addrs is the list of addresses to set on the interface. They must\neach be in CIDR notation such as: 192.0.2.42/24 for example.\n"},"gateway":{"name":"Gateway","type":"str","description":"Gateway represents the default route to set for the interface.\n"},"ip_forward":{"name":"IPForward","type":"bool","description":"IPForward is a boolean that sets whether we should forward incoming\npackets onward when this is set. It default to unspecified, which\ndownstream (in the systemd-networkd configuration) defaults to false.\nXXX: this could also be \"ipv4\" or \"ipv6\", add those as a second option?\n"},"state":{"name":"State","type":"str","description":"State is the desired state of the interface. It can be \"up\", \"down\",\nor the empty string to leave that unspecified.\n"}}},"noop":{"name":"NoopRes","kind":"noop","description":"NoopRes is a no-op resource that does nothing. Here is more XXX blah and more\nand more!\n","fields":{"comment":{"name":"Comment","type":"str","description":"Comment is some random text comment which you may use.\n"}}},"nspawn":{"name":"NspawnRes","kind":"nspawn","description":"NspawnRes is an nspawn container resource.\n","fields":{"state":{"name":"State","type":"str","description":"State specifies the desired state for this resource. This must be\neither `running` or `stopped`.\n"}}},"password":{"name":"PasswordRes","kind":"password","description":"PasswordRes is a no-op resource that returns a random password string.\n","fields":{"check_recovery":{"name":"CheckRecovery","type":"bool","description":"CheckRecovery specifies that we should recover from, regenerate, and\ncarry on casually without erroring the resource if the \"check\"\nfacility fails. This can happen when loading a saved password from\ndisk which is not of the expected length. In this case, we'd discard\nthe old saved password and create a new one without erroring.\n"},"length":{"name":"Length","type":"int","description":"Length is the number of characters to return.\nFIXME: is uint16 too big?\n"},"saved":{"name":"Saved","type":"bool","description":"Saved caches the password in the clear locally.\n"}}},"pippet":{"name":"PippetRes","kind":"pippet","description":"PippetRes is a wrapper resource for puppet. It implements the functional\nequivalent of an exec resource that calls \"puppet resource \u003ctype\u003e \u003ctitle\u003e\n\u003cparams\u003e\", but offers superior performance through a long-running Puppet\nprocess that receives resources through a pipe (hence the name).\n","fields":{"params":{"name":"Params","type":"str","description":"Params is expected to be a hash in YAML format, pairing resource\nparameter names with their respective values, e.g. { ensure: present\n}\n"},"title":{"name":"Title","type":"str","description":"Title is used by Puppet as the resource title. Puppet will often\nassign special meaning to the title, e.g. use it as the path for a\nfile resource, or the name of a package.\n"},"type":{"name":"Type","type":"str","description":"Type is the exact name of the wrapped Puppet resource type, e.g.\n\"file\", \"mount\". This needs not be a core type. It can be a type\nfrom a module. The Puppet installation local to the mgmt agent\nmachine must be able recognize it. It has to be a native type though,\nas opposed to defined types from your Puppet manifest code.\n"}}},"pkg":{"name":"PkgRes","kind":"pkg","description":"PkgRes is a package resource for packagekit.\n","fields":{"allownonfree":{"name":"AllowNonFree","type":"bool","description":"AllowNonFree specifies if we want to allow nonfree packages to be\nfound? Please see the PackageKit documentation for more information.\n"},"allowunsupported":{"name":"AllowUnsupported","type":"bool","description":"AllowUnsupported specifies if we want to unsupported packages to be\nfound? Please see the PackageKit documentation for more information.\n"},"allowuntrusted":{"name":"AllowUntrusted","type":"bool","description":"AllowUntrusted specifies if we want to allow untrusted packages to be\ninstalled. Please see the PackageKit documentation for more\ninformation.\n"},"state":{"name":"State","type":"str","description":"State determines if we want to install or uninstall the package, and\nwhat version we want to pin if any. Valid values include: installed,\nuninstalled, newest, and `version`, where you just put the raw\nversion string desired.\n"}}},"print":{"name":"PrintRes","kind":"print","description":"PrintRes is a resource that is useful for printing a message to the screen.\nIt will also display a message when it receives a notification. It supports\nautomatic grouping.\n","fields":{"refresh_only":{"name":"RefreshOnly","type":"bool","description":"RefreshOnly is an option that causes the message to be printed only\nwhen notified by another resource. When set to true, this resource\ncannot be autogrouped.\n"}}},"svc":{"name":"SvcRes","kind":"svc","description":"SvcRes is a service resource for systemd units.\n","fields":{"session":{"name":"Session","type":"bool","description":"Session specifies if this is for a system service (false) or a user\nsession specific service (true).\n"},"startup":{"name":"Startup","type":"str","description":"Startup specifies what should happen on startup. Values can be:\nenabled, disabled, and undefined (empty string).\n"},"state":{"name":"State","type":"str","description":"State is the desired state for this resource. Valid values include:\nrunning, stopped, and undefined (empty string).\n"}}},"sysctl":{"name":"SysctlRes","kind":"sysctl","description":"SysctlRes is a resource for setting kernel parameters.\nTODO: Add a sysctl:clean resource that removes any unmanaged files from\n/etc/sysctl.d/ and optionally blanks out the stock /etc/sysctl.conf file too.\n","fields":{"path":{"name":"Filename","type":"str","description":"Filename is the full path for the persistence file which is usually\nread on boot. We usually use entries in the /etc/sysctl.d/ directory.\nBy convention, they end in .conf and start with a numeric prefix and\na dash. For example: /etc/sysctl.d/10-dmesg.conf for example. If this\nis omitted, the filename will be chosen automatically.\n"},"persist":{"name":"Persist","type":"bool","description":"Persist specifies whether this value should be stored on disk where\nit will persist across reboots. It defaults to true. Keep in mind,\nthat if this is not used, but `Runtime` is true, then the value will\nbe restored anyways if `mgmt` runs on boot, which may be what you\nwant anyways.\n"},"runtime":{"name":"Runtime","type":"bool","description":"Runtime specifies whether this value should be set immediately. It\ndefaults to true. If this is not set, then the value must be set in a\nfile and the machine will have to reboot for the setting to take\neffect.\n"},"value":{"name":"Value","type":"str","description":"Value is the string value to set. Make sure you specify it in the\nsame format that the kernel parses it as to avoid automation\n\"flapping\". You can test this by writing a value to the correct\n/proc/sys/ path entry with `echo foo \u003e` and then reading it back out\nand seeing what the \"parsed\" correct format is. You must not include\nthe trailing newline which is present in the readback for all values.\n"}}},"tar":{"name":"TarRes","kind":"tar","description":"TarRes is a resource that archives a number of paths using tar, thus\ncombining them into a single file. The name of the resource is the path to\nthe resultant archive file. The input comes from a list of paths which can be\neither files or directories or both. Directories are added recursively of\ncourse. This uses hashes to determine if something was changed, so as a\nresult, this may not be suitable if you can create a sha256 hash collision.\nTODO: support send/recv to send the output instead of writing to a file?\n","fields":{"format":{"name":"Format","type":"int","description":"Format is the header format to use. If you change this, then the\nfile will get rearchived. The strange thing is that it seems the\nheader format is stored for each individual file. The available\nvalues are: const.res.tar.format.unknown, const.res.tar.format.ustar,\nconst.res.tar.format.pax, and const.res.tar.format.gnu which have\nvalues of 0, 2, 4, and 8 respectively.\n"},"inputs":{"name":"Inputs","type":"[]str","description":"Inputs represents the list of files to be compressed. They must each\nbe absolute paths of either single files or directories, and as a\nresult, each must start with a slash. Directories must end with a\nslash and files must not.\n"},"path":{"name":"Path","type":"str","description":"Path, which defaults to the name if not specified, represents the\ndestination path for the compressed file being created. It must be an\nabsolute path, and as a result must start with a slash. Since it is a\nfile, it must not end with a slash.\n"}}},"test":{"name":"TestRes","kind":"test","description":"TestRes is a resource that is mostly harmless and is used for internal tests.\n","fields":{"byte":{"name":"Byte","type":"int","description":"Uintptr uintptr `lang:\"uintptr\" yaml:\"uintptr\"`\n"},"func1":{"name":"Func1","type":"func(0 int) str","description":"Func1 passes the value 42 to the input and returns a string.\n"},"int8ptrptrptr":{"name":"Int8PtrPtrPtr","type":"int","description":"probably makes no sense, but is legal\n"}}},"tftp:file":{"name":"TFTPFileRes","kind":"tftp:file","description":"TFTPFileRes is a file that exists within a tftp server. The name is used as\nthe public path of the file, unless the filename field is specified, and in\nthat case it is used instead. The way this works is that it autogroups at\nruntime with an existing tftp resource, and in doing so makes the file\nassociated with this resource available for serving from that tftp server.\n","fields":{"data":{"name":"Data","type":"str","description":"Data is the file content that should be used as the source for this\nfile resource. It must not be combined with the path field.\nTODO: should this be []byte instead?\n"},"filename":{"name":"Filename","type":"str","description":"Filename is the name of the file this data should appear as on the\ntftp server.\n"},"path":{"name":"Path","type":"str","description":"Path is the absolute path to a file that should be used as the source\nfor this file resource. It must not be combined with the data field.\n"},"server":{"name":"Server","type":"str","description":"Server is the name of the tftp server resource to group this into. If\nit is omitted, and there is only a single tftp resource, then it will\nbe grouped into it automatically. If there is more than one main tftp\nresource being used, then the grouping behaviour is *undefined* when\nthis is not specified, and it is not recommended to leave this blank!\n"}}},"tftp:server":{"name":"TFTPServerRes","kind":"tftp:server","description":"TFTPServerRes is a tftp server resource. It serves files, but does not\nactually apply any state. The name is used as the address to listen on,\nunless the Address field is specified, and in that case it is used instead.\nThis resource can offer up files for serving that are specified either inline\nin this resource by specifying a tftp root, or as tftp:file resources which\nwill get autogrouped into this resource at runtime. The two methods can be\ncombined as well.\n","fields":{"address":{"name":"Address","type":"str","description":"Address is the listen address to use for the tftp server. It is\ncommon to use `:69` (the standard) to listen on UDP port 69 on all\naddresses.\n"},"root":{"name":"Root","type":"str","description":"Root is the root directory that we should serve files from. If it is\nnot specified, then it is not used. Any tftp file resources will have\nprecedence over anything in here, in case the same path exists twice.\nTODO: should we have a flag to determine the precedence rules here?\n"},"timeout":{"name":"Timeout","type":"int","description":"Timeout is the timeout in seconds to use for server connections.\n"}}},"timer":{"name":"TimerRes","kind":"timer","description":"TimerRes is a timer resource for time based events. It outputs an event every\ninterval seconds.\n","fields":{"interval":{"name":"Interval","type":"int","description":"Interval between runs in seconds.\n"}}},"user":{"name":"UserRes","kind":"user","description":"UserRes is a user account resource.\n","fields":{"allowduplicateuid":{"name":"AllowDuplicateUID","type":"bool","description":"AllowDuplicateUID is needed for a UID to be non-unique. This is rare\nbut happens if you want more than one username to access the\nresources of the same UID. See the --non-unique flag in `useradd`.\n"},"gid":{"name":"GID","type":"int","description":"GID of the user's primary group.\n"},"group":{"name":"Group","type":"str","description":"Group is the name of the user's primary group.\n"},"groups":{"name":"Groups","type":"[]str","description":"Groups are a list of supplemental groups.\n"},"homedir":{"name":"HomeDir","type":"str","description":"HomeDir is the path to the user's home directory.\n"},"state":{"name":"State","type":"str","description":"State is either exists or absent.\n"},"uid":{"name":"UID","type":"int","description":"UID specifies the usually unique user ID. It must be unique unless\nAllowDuplicateUID is true.\n"}}},"value":{"name":"ValueRes","kind":"value","description":"ValueRes is a no-op resource that accepts a value normally or via send/recv\nand it sends it via send/recv as well.\n\nXXX: intermediate chained values being used for send/recv must have a\ntemporary placeholder value set or we'll get an invalid value error. This can\nbe fixed eventually when we expand the resource API. See the Default method\nof this resource for more information.\n","fields":{"any":{"name":"Any","type":"variant","description":"Any is an arbitrary value to store in this resource. It can also be\nsent via send/recv and received by the same mechanism as well. The\nreceived value overwrites this value for the lifetime of the\nresource. It is interface{} because it can hold any type. It has\npointer because it is only set if an actual value exists.\n"}}},"virt":{"name":"VirtRes","kind":"virt","description":"VirtRes is a libvirt resource. A transient virt resource, which has its state\nset to `shutoff` is one which does not exist. The parallel equivalent is a\nfile resource which removes a particular path.\nTODO: some values inside here should be enum's!\n","fields":{"auth":{"name":"Auth","type":"struct{username str; password str}","description":"Auth points to the libvirt credentials to use if any are necessary.\n"},"boot":{"name":"Boot","type":"[]str","description":"Boot is the boot order. Values are `fd`, `hd`, `cdrom` and `network`.\n"},"cdrom":{"name":"CDRom","type":"[]struct{source str; type str}","description":"CdRom is the list of cdrom devices to include.\n"},"cpus":{"name":"CPUs","type":"int","description":"CPUs is the desired cpu count of the machine.\n"},"disk":{"name":"Disk","type":"[]struct{source str; type str}","description":"Disk is the list of disk devices to include.\n"},"filesystem":{"name":"Filesystem","type":"[]struct{access str; source str; target str; read_only bool}","description":"Filesystem is the list of file system devices to include.\n"},"hotcpus":{"name":"HotCPUs","type":"bool","description":"HotCPUs specifies whether we can hot plug and unplug cpus.\n"},"maxcpus":{"name":"MaxCPUs","type":"int","description":"MaxCPUs is the maximum number of cpus allowed in the machine. You\nneed to set this so that on boot the `hardware` knows how many cpu\n`slots` it might need to make room for.\n"},"memory":{"name":"Memory","type":"int","description":"Memory is the size in KBytes of memory to include in the machine.\n"},"network":{"name":"Network","type":"[]struct{name str; mac str}","description":"Network is the list of network devices to include.\n"},"osinit":{"name":"OSInit","type":"str","description":"OSInit is the init used by lxc.\n"},"restartondiverge":{"name":"RestartOnDiverge","type":"str","description":"RestartOnDiverge is the restart policy, and can be: `ignore`,\n`ifneeded` or `error`.\n"},"restartonrefresh":{"name":"RestartOnRefresh","type":"bool","description":"RestartOnRefresh specifies if we restart on refresh signal.\n"},"state":{"name":"State","type":"str","description":"State is the desired vm state. Possible values include: `running`,\n`paused` and `shutoff`.\n"},"transient":{"name":"Transient","type":"bool","description":"Transient is whether the vm is defined (false) or undefined (true).\n"},"uri":{"name":"URI","type":"str","description":"URI is the libvirt connection URI, eg: `qemu:///session`.\n"}}},"virt:builder":{"name":"VirtBuilderRes","kind":"virt:builder","description":"VirtBuilderRes is a resource for building virtual machine images. It is based\non the amazing virt-builder tool which is part of the guestfs suite of tools.\nTODO: Add autoedges with the virt resource disk path!\n","fields":{"arch":{"name":"Arch","type":"str","description":"Arch specifies the CPU architecture to use for this machine. You will\nneed to pick from the output of `virt-builder --list`. Note that not\nall OSVersion+Arch combinations may exist.\n"},"bootstrap":{"name":"Bootstrap","type":"bool","description":"Bootstrap can be set to false to disable any automatic bootstrapping\nof running the mgmt binary on first boot. If this is set, we will\nattempt to copy the mgmt binary in, and then run it. This also adds\nadditional packages to install which are needed to bootstrap mgmt.\nThis defaults to true.\nTODO: This does not yet support multi or cross arch.\nFIXME: This doesn't kick off mgmt runs yet.\n"},"format":{"name":"Format","type":"str","description":"Format is the disk image format. You likely want \"raw\" or \"qcow2\".\n"},"hostname":{"name":"Hostname","type":"str","description":"Hostname for the new machine.\n"},"log_output":{"name":"LogOutput","type":"bool","description":"LogOutput logs the output of running this command to a file in the\nspecial $vardir directory. It defaults to true. Keep in mind that if\nyou let virt-builder choose the password randomly, it will be output\nin these logs in cleartext!\n"},"no_setup":{"name":"NoSetup","type":"bool","description":"NoSetup can be set to true to disable trying to install the package\nfor the virt-builder binary.\n"},"os_version":{"name":"OSVersion","type":"str","description":"OSVersion specifies which distro and version to use for installation.\nYou will need to pick from the output of `virt-builder --list`.\n"},"output":{"name":"Output","type":"str","description":"Output is the full absolute file path where the image will be\ncreated. If this file exists, then no action will be performed.\nTODO: Consider adding a \"overwrite\" type mechanism in the future,\nwhen we can find a safe way to do so.\n"},"packages":{"name":"Packages","type":"[]str","description":"Packages is the list of packages to install. If Bootstrap is true,\nthen it will add additional packages that we install if needed.\n"},"root_ssh_inject":{"name":"RootSSHInject","type":"bool","description":"RootSSHInject disables installing the root ssh key into the new vm.\nIf one is not present, then nothing is done.\tThis defaults to true.\n"},"selinux_relabel":{"name":"SelinuxRelabel","type":"bool","description":"SelinuxRelabel specifies that we should do an selinux relabel on the\nfinal image. This defaults to true.\n"},"size":{"name":"Size","type":"int","description":"Size is the disk size of the new virtual machine in bytes.\n"},"ssh_keys":{"name":"SSHKeys","type":"[]struct{user str; type str; key str; comment str}","description":"SSHKeys is a list of additional keys to add to the machine. This is\nnot a map because you may wish to add more than one to that user\naccount.\n"},"update":{"name":"Update","type":"bool","description":"Update specifies that we should update the installed packages during\nimage build. This defaults to true.\n"}}}},"functions":{"concat":{"package":"","name":"concat","signature":"func(a str, b str) str","description":""},"contains":{"package":"","name":"contains","signature":"func(needle ?1, haystack []?1) bool","description":""},"convert.format_bool":{"package":"convert","name":"format_bool","signature":"func(a bool) str","description":""},"convert.int_to_str":{"package":"convert","name":"int_to_str","signature":"func(a int) str","description":""},"convert.parse_bool":{"package":"convert","name":"parse_bool","signature":"func(a str) bool","description":""},"convert.to_float":{"package":"convert","name":"to_float","signature":"func(a int) float","description":""},"convert.to_int":{"package":"convert","name":"to_int","signature":"func(a float) int","description":""},"datetime.format":{"package":"datetime","name":"format","signature":"func(a int, b str) str","description":""},"datetime.hour":{"package":"datetime","name":"hour","signature":"func(a int) int","description":""},"datetime.now":{"package":"datetime","name":"now","signature":"func() int","description":""},"datetime.print":{"package":"datetime","name":"print","signature":"func(a int) str","description":""},"datetime.weekday":{"package":"datetime","name":"weekday","signature":"func(a int) str","description":""},"deploy.abspath":{"package":"deploy","name":"abspath","signature":"func(path str) str","description":""},"deploy.binary_path":{"package":"deploy","name":"binary_path","signature":"func() str","description":""},"deploy.bootstrap_packages":{"package":"deploy","name":"bootstrap_packages","signature":"func(0 str) []str","description":""},"deploy.get_archive":{"package":"deploy","name":"get_archive","signature":"func() str","description":""},"deploy.readfile":{"package":"deploy","name":"readfile","signature":"func(filename str) str","description":""},"deploy.readfileabs":{"package":"deploy","name":"readfileabs","signature":"func(filename str) str","description":""},"embedded/provisioner.cli_arch":{"package":"embedded/provisioner","name":"cli_arch","signature":"func() str","description":""},"embedded/provisioner.cli_bios":{"package":"embedded/provisioner","name":"cli_bios","signature":"func() bool","description":""},"embedded/provisioner.cli_distro":{"package":"embedded/provisioner","name":"cli_distro","signature":"func() str","description":""},"embedded/provisioner.cli_dns":{"package":"embedded/provisioner","name":"cli_dns","signature":"func() []str","description":""},"embedded/provisioner.cli_firewalld":{"package":"embedded/provisioner","name":"cli_firewalld","signature":"func() bool","description":""},"embedded/provisioner.cli_flavour":{"package":"embedded/provisioner","name":"cli_flavour","signature":"func() str","description":""},"embedded/provisioner.cli_handoff_code":{"package":"embedded/provisioner","name":"cli_handoff_code","signature":"func() str","description":""},"embedded/provisioner.cli_interface":{"package":"embedded/provisioner","name":"cli_interface","signature":"func() str","description":""},"embedded/provisioner.cli_ip":{"package":"embedded/provisioner","name":"cli_ip","signature":"func() str","description":""},"embedded/provisioner.cli_mac":{"package":"embedded/provisioner","name":"cli_mac","signature":"func() str","description":""},"embedded/provisioner.cli_mirror":{"package":"embedded/provisioner","name":"cli_mirror","signature":"func() str","description":""},"embedded/provisioner.cli_network":{"package":"embedded/provisioner","name":"cli_network","signature":"func() str","description":""},"embedded/provisioner.cli_packages":{"package":"embedded/provisioner","name":"cli_packages","signature":"func() []str","description":""},"embedded/provisioner.cli_part":{"package":"embedded/provisioner","name":"cli_part","signature":"func() str","description":""},"embedded/provisioner.cli_password":{"package":"embedded/provisioner","name":"cli_password","signature":"func() str","description":""},"embedded/provisioner.cli_prefix":{"package":"embedded/provisioner","name":"cli_prefix","signature":"func() str","description":""},"embedded/provisioner.cli_router":{"package":"embedded/provisioner","name":"cli_router","signature":"func() str","description":""},"embedded/provisioner.cli_rsync":{"package":"embedded/provisioner","name":"cli_rsync","signature":"func() str","description":""},"embedded/provisioner.cli_version":{"package":"embedded/provisioner","name":"cli_version","signature":"func() str","description":""},"embedded/provisioner.onlyunify":{"package":"embedded/provisioner","name":"onlyunify","signature":"func() bool","description":""},"example.answer":{"package":"example","name":"answer","signature":"func() int","description":""},"example.errorbool":{"package":"example","name":"errorbool","signature":"func(a bool) str","description":""},"example.flipflop":{"package":"example","name":"flipflop","signature":"func() bool","description":""},"example.int2str":{"package":"example","name":"int2str","signature":"func(a int) str","description":""},"example.plus":{"package":"example","name":"plus","signature":"func(y str, z str) str","description":""},"example.str2int":{"package":"example","name":"str2int","signature":"func(a str) int","description":""},"example.vumeter":{"package":"example","name":"vumeter","signature":"func(symbol str, multiplier int, peak float) str","description":""},"example/nested.hello":{"package":"example/nested","name":"hello","signature":"func() str","description":""},"fmt.printf":{"package":"fmt","name":"printf","description":""},"golang.template":{"package":"golang","name":"template","description":""},"golang/html.escape_string":{"package":"golang/html","name":"escape_string","signature":"func(s str) str","description":""},"golang/html.unescape_string":{"package":"golang/html","name":"unescape_string","signature":"func(s str) str","description":""},"golang/math.abs":{"package":"golang/math","name":"abs","signature":"func(x float) float","description":""},"golang/math.acos":{"package":"golang/math","name":"acos","signature":"func(x float) float","description":""},"golang/math.acosh":{"package":"golang/math","name":"acosh","signature":"func(x float) float","description":""},"golang/math.asin":{"package":"golang/math","name":"asin","signature":"func(x float) float","description":""},"golang/math.asinh":{"package":"golang/math","name":"asinh","signature":"func(x float) float","description":""},"golang/math.atan":{"package":"golang/math","name":"atan","signature":"func(x float) float","description":""},"golang/math.atan_2":{"package":"golang/math","name":"atan_2","signature":"func(y float, x float) float","description":""},"golang/math.atanh":{"package":"golang/math","name":"atanh","signature":"func(x float) float","description":""},"golang/math.cbrt":{"package":"golang/math","name":"cbrt","signature":"func(x float) float","description":""},"golang/math.ceil":{"package":"golang/math","name":"ceil","signature":"func(x float) float","description":""},"golang/math.copysign":{"package":"golang/math","name":"copysign","signature":"func(f float, sign float) float","description":""},"golang/math.cos":{"package":"golang/math","name":"cos","signature":"func(x float) float","description":""},"golang/math.cosh":{"package":"golang/math","name":"cosh","signature":"func(x float) float","description":""},"golang/math.dim":{"package":"golang/math","name":"dim","signature":"func(x float, y float) float","description":""},"golang/math.erf":{"package":"golang/math","name":"erf","signature":"func(x float) float","description":""},"golang/math.erfc":{"package":"golang/math","name":"erfc","signature":"func(x float) float","description":""},"golang/math.erfcinv":{"package":"golang/math","name":"erfcinv","signature":"func(x float) float","description":""},"golang/math.erfinv":{"package":"golang/math","name":"erfinv","signature":"func(x float) float","description":""},"golang/math.exp":{"package":"golang/math","name":"exp","signature":"func(x float) float","description":""},"golang/math.exp_2":{"package":"golang/math","name":"exp_2","signature":"func(x float) float","description":""},"golang/math.expm_1":{"package":"golang/math","name":"expm_1","signature":"func(x float) float","description":""},"golang/math.floor":{"package":"golang/math","name":"floor","signature":"func(x float) float","description":""},"golang/math.fma":{"package":"golang/math","name":"fma","signature":"func(x float, y float, z float) float","description":""},"golang/math.gamma":{"package":"golang/math","name":"gamma","signature":"func(x float) float","description":""},"golang/math.hypot":{"package":"golang/math","name":"hypot","signature":"func(p float, q float) float","description":""},"golang/math.ilogb":{"package":"golang/math","name":"ilogb","signature":"func(x float) int","description":""},"golang/math.inf":{"package":"golang/math","name":"inf","signature":"func(sign int) float","description":""},"golang/math.is_inf":{"package":"golang/math","name":"is_inf","signature":"func(f float, sign int) bool","description":""},"golang/math.j_0":{"package":"golang/math","name":"j_0","signature":"func(x float) float","description":""},"golang/math.j_1":{"package":"golang/math","name":"j_1","signature":"func(x float) float","description":""},"golang/math.jn":{"package":"golang/math","name":"jn","signature":"func(n int, x float) float","description":""},"golang/math.ldexp":{"package":"golang/math","name":"ldexp","signature":"func(frac float, exp int) float","description":""},"golang/math.log":{"package":"golang/math","name":"log","signature":"func(x float) float","description":""},"golang/math.log_10":{"package":"golang/math","name":"log_10","signature":"func(x float) float","description":""},"golang/math.log_1_p":{"package":"golang/math","name":"log_1_p","signature":"func(x float) float","description":""},"golang/math.log_2":{"package":"golang/math","name":"log_2","signature":"func(x float) float","description":""},"golang/math.logb":{"package":"golang/math","name":"logb","signature":"func(x float) float","description":""},"golang/math.max":{"package":"golang/math","name":"max","signature":"func(x float, y float) float","description":""},"golang/math.min":{"package":"golang/math","name":"min","signature":"func(x float, y float) float","description":""},"golang/math.mod":{"package":"golang/math","name":"mod","signature":"func(x float, y float) float","description":""},"golang/math.na_n":{"package":"golang/math","name":"na_n","signature":"func() float","description":""},"golang/math.pow":{"package":"golang/math","name":"pow","signature":"func(x float, y float) float","description":""},"golang/math.pow_10":{"package":"golang/math","name":"pow_10","signature":"func(n int) float","description":""},"golang/math.remainder":{"package":"golang/math","name":"remainder","signature":"func(x float, y float) float","description":""},"golang/math.round":{"package":"golang/math","name":"round","signature":"func(x float) float","description":""},"golang/math.round_to_even":{"package":"golang/math","name":"round_to_even","signature":"func(x float) float","description":""},"golang/math.signbit":{"package":"golang/math","name":"signbit","signature":"func(x float) bool","description":""},"golang/math.sin":{"package":"golang/math","name":"sin","signature":"func(x float) float","description":""},"golang/math.sinh":{"package":"golang/math","name":"sinh","signature":"func(x float) float","description":""},"golang/math.sqrt":{"package":"golang/math","name":"sqrt","signature":"func(x float) float","description":""},"golang/math.tan":{"package":"golang/math","name":"tan","signature":"func(x float) float","description":""},"golang/math.tanh":{"package":"golang/math","name":"tanh","signature":"func(x float) float","description":""},"golang/math.trunc":{"package":"golang/math","name":"trunc","signature":"func(x float) float","description":""},"golang/math.y_0":{"package":"golang/math","name":"y_0","signature":"func(x float) float","description":""},"golang/math.y_1":{"package":"golang/math","name":"y_1","signature":"func(x float) float","description":""},"golang/math.yn":{"package":"golang/math","name":"yn","signature":"func(n int, x float) float","description":""},"golang/math/rand.exp_float_64":{"package":"golang/math/rand","name":"exp_float_64","signature":"func() float","description":""},"golang/math/rand.float_64":{"package":"golang/math/rand","name":"float_64","signature":"func() float","description":""},"golang/math/rand.int":{"package":"golang/math/rand","name":"int","signature":"func() int","description":""},"golang/math/rand.int_63":{"package":"golang/math/rand","name":"int_63","signature":"func() int","description":""},"golang/math/rand.int_63_n":{"package":"golang/math/rand","name":"int_63_n","signature":"func(n int) int","description":""},"golang/math/rand.intn":{"package":"golang/math/rand","name":"intn","signature":"func(n int) int","description":""},"golang/math/rand.norm_float_64":{"package":"golang/math/rand","name":"norm_float_64","signature":"func() float","description":""},"golang/os.executable":{"package":"golang/os","name":"executable","signature":"func() str","description":""},"golang/os.expand_env":{"package":"golang/os","name":"expand_env","signature":"func(s str) str","description":""},"golang/os.getegid":{"package":"golang/os","name":"getegid","signature":"func() int","description":""},"golang/os.getenv":{"package":"golang/os","name":"getenv","signature":"func(key str) str","description":""},"golang/os.geteuid":{"package":"golang/os","name":"geteuid","signature":"func() int","description":""},"golang/os.getgid":{"package":"golang/os","name":"getgid","signature":"func() int","description":""},"golang/os.getpagesize":{"package":"golang/os","name":"getpagesize","signature":"func() int","description":""},"golang/os.getpid":{"package":"golang/os","name":"getpid","signature":"func() int","description":""},"golang/os.getppid":{"package":"golang/os","name":"getppid","signature":"func() int","description":""},"golang/os.getuid":{"package":"golang/os","name":"getuid","signature":"func() int","description":""},"golang/os.mkdir_temp":{"package":"golang/os","name":"mkdir_temp","signature":"func(dir str, pattern str) str","description":""},"golang/os.read_file":{"package":"golang/os","name":"read_file","signature":"func(name str) str","description":""},"golang/os.readlink":{"package":"golang/os","name":"readlink","signature":"func(name str) str","description":""},"golang/os.temp_dir":{"package":"golang/os","name":"temp_dir","signature":"func() str","description":""},"golang/os.user_cache_dir":{"package":"golang/os","name":"user_cache_dir","signature":"func() str","description":""},"golang/os.user_config_dir":{"package":"golang/os","name":"user_config_dir","signature":"func() str","description":""},"golang/os.user_home_dir":{"package":"golang/os","name":"user_home_dir","signature":"func() str","description":""},"golang/os/exec.look_path":{"package":"golang/os/exec","name":"look_path","signature":"func(file str) str","description":""},"golang/path.base":{"package":"golang/path","name":"base","signature":"func(path str) str","description":""},"golang/path.clean":{"package":"golang/path","name":"clean","signature":"func(path str) str","description":""},"golang/path.dir":{"package":"golang/path","name":"dir","signature":"func(path str) str","description":""},"golang/path.ext":{"package":"golang/path","name":"ext","signature":"func(path str) str","description":""},"golang/path.is_abs":{"package":"golang/path","name":"is_abs","signature":"func(path str) bool","description":""},"golang/path/filepath.abs":{"package":"golang/path/filepath","name":"abs","signature":"func(path str) str","description":""},"golang/path/filepath.base":{"package":"golang/path/filepath","name":"base","signature":"func(path str) str","description":""},"golang/path/filepath.clean":{"package":"golang/path/filepath","name":"clean","signature":"func(path str) str","description":""},"golang/path/filepath.dir":{"package":"golang/path/filepath","name":"dir","signature":"func(path str) str","description":""},"golang/path/filepath.eval_symlinks":{"package":"golang/path/filepath","name":"eval_symlinks","signature":"func(path str) str","description":""},"golang/path/filepath.ext":{"package":"golang/path/filepath","name":"ext","signature":"func(path str) str","description":""},"golang/path/filepath.from_slash":{"package":"golang/path/filepath","name":"from_slash","signature":"func(path str) str","description":""},"golang/path/filepath.has_prefix":{"package":"golang/path/filepath","name":"has_prefix","signature":"func(p str, prefix str) bool","description":""},"golang/path/filepath.is_abs":{"package":"golang/path/filepath","name":"is_abs","signature":"func(path str) bool","description":""},"golang/path/filepath.is_local":{"package":"golang/path/filepath","name":"is_local","signature":"func(path str) bool","description":""},"golang/path/filepath.rel":{"package":"golang/path/filepath","name":"rel","signature":"func(basepath str, targpath str) str","description":""},"golang/path/filepath.to_slash":{"package":"golang/path/filepath","name":"to_slash","signature":"func(path str) str","description":""},"golang/path/filepath.volume_name":{"package":"golang/path/filepath","name":"volume_name","signature":"func(path str) str","description":""},"golang/runtime.cpu_profile":{"package":"golang/runtime","name":"cpu_profile","signature":"func() str","description":""},"golang/runtime.gomaxprocs":{"package":"golang/runtime","name":"gomaxprocs","signature":"func(n int) int","description":""},"golang/runtime.goroot":{"package":"golang/runtime","name":"goroot","signature":"func() str","description":""},"golang/runtime.num_cgo_call":{"package":"golang/runtime","name":"num_cgo_call","signature":"func() int","description":""},"golang/runtime.num_cpu":{"package":"golang/runtime","name":"num_cpu","signature":"func() int","description":""},"golang/runtime.num_goroutine":{"package":"golang/runtime","name":"num_goroutine","signature":"func() int","description":""},"golang/runtime.read_trace":{"package":"golang/runtime","name":"read_trace","signature":"func() str","description":""},"golang/runtime.set_mutex_profile_fraction":{"package":"golang/runtime","name":"set_mutex_profile_fraction","signature":"func(rate int) int","description":""},"golang/runtime.stack":{"package":"golang/runtime","name":"stack","signature":"func(buf str, all bool) int","description":""},"golang/runtime.version":{"package":"golang/runtime","name":"version","signature":"func() str","description":""},"golang/strconv.append_bool":{"package":"golang/strconv","name":"append_bool","signature":"func(dst str, b bool) str","description":""},"golang/strconv.append_int":{"package":"golang/strconv","name":"append_int","signature":"func(dst str, i int, base int) str","description":""},"golang/strconv.append_quote":{"package":"golang/strconv","name":"append_quote","signature":"func(dst str, s str) str","description":""},"golang/strconv.append_quote_to_ascii":{"package":"golang/strconv","name":"append_quote_to_ascii","signature":"func(dst str, s str) str","description":""},"golang/strconv.append_quote_to_graphic":{"package":"golang/strconv","name":"append_quote_to_graphic","signature":"func(dst str, s str) str","description":""},"golang/strconv.atoi":{"package":"golang/strconv","name":"atoi","signature":"func(s str) int","description":""},"golang/strconv.can_backquote":{"package":"golang/strconv","name":"can_backquote","signature":"func(s str) bool","description":""},"golang/strconv.format_bool":{"package":"golang/strconv","name":"format_bool","signature":"func(b bool) str","description":""},"golang/strconv.format_int":{"package":"golang/strconv","name":"format_int","signature":"func(i int, base int) str","description":""},"golang/strconv.itoa":{"package":"golang/strconv","name":"itoa","signature":"func(i int) str","description":""},"golang/strconv.parse_bool":{"package":"golang/strconv","name":"parse_bool","signature":"func(str str) bool","description":""},"golang/strconv.parse_float":{"package":"golang/strconv","name":"parse_float","signature":"func(s str, bitSize int) float","description":""},"golang/strconv.quote":{"package":"golang/strconv","name":"quote","signature":"func(s str) str","description":""},"golang/strconv.quote_to_ascii":{"package":"golang/strconv","name":"quote_to_ascii","signature":"func(s str) str","description":""},"golang/strconv.quote_to_graphic":{"package":"golang/strconv","name":"quote_to_graphic","signature":"func(s str) str","description":""},"golang/strconv.quoted_prefix":{"package":"golang/strconv","name":"quoted_prefix","signature":"func(s str) str","description":""},"golang/strconv.unquote":{"package":"golang/strconv","name":"unquote","signature":"func(s str) str","description":""},"golang/strings.clone":{"package":"golang/strings","name":"clone","signature":"func(s str) str","description":""},"golang/strings.compare":{"package":"golang/strings","name":"compare","signature":"func(a str, b str) int","description":""},"golang/strings.contains":{"package":"golang/strings","name":"contains","signature":"func(s str, substr str) bool","description":""},"golang/strings.contains_any":{"package":"golang/strings","name":"contains_any","signature":"func(s str, chars str) bool","description":""},"golang/strings.count":{"package":"golang/strings","name":"count","signature":"func(s str, substr str) int","description":""},"golang/strings.equal_fold":{"package":"golang/strings","name":"equal_fold","signature":"func(s str, t str) bool","description":""},"golang/strings.has_prefix":{"package":"golang/strings","name":"has_prefix","signature":"func(s str, prefix str) bool","description":""},"golang/strings.has_suffix":{"package":"golang/strings","name":"has_suffix","signature":"func(s str, suffix str) bool","description":""},"golang/strings.index":{"package":"golang/strings","name":"index","signature":"func(s str, substr str) int","description":""},"golang/strings.index_any":{"package":"golang/strings","name":"index_any","signature":"func(s str, chars str) int","description":""},"golang/strings.join":{"package":"golang/strings","name":"join","signature":"func(elems []str, sep str) str","description":""},"golang/strings.last_index":{"package":"golang/strings","name":"last_index","signature":"func(s str, substr str) int","description":""},"golang/strings.last_index_any":{"package":"golang/strings","name":"last_index_any","signature":"func(s str, chars str) int","description":""},"golang/strings.repeat":{"package":"golang/strings","name":"repeat","signature":"func(s str, count int) str","description":""},"golang/strings.replace":{"package":"golang/strings","name":"replace","signature":"func(s str, old str, new str, n int) str","description":""},"golang/strings.replace_all":{"package":"golang/strings","name":"replace_all","signature":"func(s str, old str, new str) str","description":""},"golang/strings.title":{"package":"golang/strings","name":"title","signature":"func(s str) str","description":""},"golang/strings.to_lower":{"package":"golang/strings","name":"to_lower","signature":"func(s str) str","description":""},"golang/strings.to_title":{"package":"golang/strings","name":"to_title","signature":"func(s str) str","description":""},"golang/strings.to_upper":{"package":"golang/strings","name":"to_upper","signature":"func(s str) str","description":""},"golang/strings.to_valid_utf_8":{"package":"golang/strings","name":"to_valid_utf_8","signature":"func(s str, replacement str) str","description":""},"golang/strings.trim":{"package":"golang/strings","name":"trim","signature":"func(s str, cutset str) str","description":""},"golang/strings.trim_left":{"package":"golang/strings","name":"trim_left","signature":"func(s str, cutset str) str","description":""},"golang/strings.trim_prefix":{"package":"golang/strings","name":"trim_prefix","signature":"func(s str, prefix str) str","description":""},"golang/strings.trim_right":{"package":"golang/strings","name":"trim_right","signature":"func(s str, cutset str) str","description":""},"golang/strings.trim_space":{"package":"golang/strings","name":"trim_space","signature":"func(s str) str","description":""},"golang/strings.trim_suffix":{"package":"golang/strings","name":"trim_suffix","signature":"func(s str, suffix str) str","description":""},"history":{"package":"","name":"history","signature":"func(value ?1, index int) ?1","description":""},"iter.filter":{"package":"iter","name":"filter","signature":"func(inputs []?1, function func(name-which-can-vary-over-time ?1) bool) []?1","description":""},"iter.map":{"package":"iter","name":"map","signature":"func(inputs []?1, function func(name-which-can-vary-over-time ?1) ?2) []?2","description":""},"len":{"package":"","name":"len","signature":"func(0 ?1) int","description":""},"list.concat":{"package":"list","name":"concat","description":""},"list.intersection":{"package":"list","name":"intersection","signature":"func(a []?1, b []?1) []?1","description":""},"list.lookup":{"package":"list","name":"lookup","description":""},"list_lookup":{"package":"","name":"list_lookup","signature":"func(list []?1, index int) ?1","description":""},"list_lookup_default":{"package":"","name":"list_lookup_default","signature":"func(list []?1, index int, default ?1) ?1","description":""},"local.pool":{"package":"local","name":"pool","signature":"func(namespace str, uid str) int","description":""},"local.vardir":{"package":"local","name":"vardir","signature":"func(path str) str","description":""},"map.keys":{"package":"map","name":"keys","signature":"func(x map{?1: ?2}) []?1","description":""},"map.lookup":{"package":"map","name":"lookup","description":""},"map.values":{"package":"map","name":"values","signature":"func(x map{?1: ?2}) []?2","description":""},"map_lookup":{"package":"","name":"map_lookup","signature":"func(map map{?1: ?2}, key ?1) ?2","description":""},"map_lookup_default":{"package":"","name":"map_lookup_default","signature":"func(map map{?1: ?2}, key ?1, default ?2) ?2","description":""},"math.fortytwo":{"package":"math","name":"fortytwo","signature":"func() ?1","description":""},"math.minus1":{"package":"math","name":"minus1","signature":"func(x int) int","description":""},"math.mod":{"package":"math","name":"mod","signature":"func(0 ?1, 1 ?1) ?1","description":""},"math.pow":{"package":"math","name":"pow","signature":"func(x float, y float) float","description":""},"math.sqrt":{"package":"math","name":"sqrt","signature":"func(x float) float","description":""},"net.cidr_to_ip":{"package":"net","name":"cidr_to_ip","signature":"func(a str) str","description":""},"net.cidr_to_mask":{"package":"net","name":"cidr_to_mask","signature":"func(a str) str","description":""},"net.cidr_to_prefix":{"package":"net","name":"cidr_to_prefix","signature":"func(a str) str","description":""},"net.is_mac":{"package":"net","name":"is_mac","signature":"func(a str) bool","description":""},"net.macfmt":{"package":"net","name":"macfmt","signature":"func(a str) str","description":""},"net.macs":{"package":"net","name":"macs","signature":"func() []str","description":""},"net.oldmacfmt":{"package":"net","name":"oldmacfmt","signature":"func(a str) str","description":""},"os.args":{"package":"os","name":"args","signature":"func() []str","description":""},"os.expand_home":{"package":"os","name":"expand_home","signature":"func(0 str) str","description":""},"os.family":{"package":"os","name":"family","signature":"func() str","description":""},"os.is_family_archlinux":{"package":"os","name":"is_family_archlinux","signature":"func() bool","description":""},"os.is_family_debian":{"package":"os","name":"is_family_debian","signature":"func() bool","description":""},"os.is_family_redhat":{"package":"os","name":"is_family_redhat","signature":"func() bool","description":""},"os.parse_distro_uid":{"package":"os","name":"parse_distro_uid","signature":"func(0 str) struct{distro str; version str; arch str}","description":""},"os.readfile":{"package":"os","name":"readfile","signature":"func(filename str) str","description":""},"os.system":{"package":"os","name":"system","signature":"func(cmd str) str","description":""},"panic":{"package":"","name":"panic","signature":"func(x ?1) bool","description":""},"random1":{"package":"","name":"random1","signature":"func(length int) str","description":""},"regexp.match":{"package":"regexp","name":"match","signature":"func(pattern str, s str) bool","description":""},"strings.left_pad":{"package":"strings","name":"left_pad","signature":"func(s str, pad str, len int) str","description":""},"strings.right_pad":{"package":"strings","name":"right_pad","signature":"func(s str, pad str, len int) str","description":""},"strings.split":{"package":"strings","name":"split","signature":"func(a str, b str) []str","description":""},"strings.substr":{"package":"strings","name":"substr","signature":"func(s str, low int, high int) str","description":""},"strings.to_lower":{"package":"strings","name":"to_lower","signature":"func(a str) str","description":""},"sys.cpu_count":{"package":"sys","name":"cpu_count","signature":"func() int","description":""},"sys.defaultenv":{"package":"sys","name":"defaultenv","signature":"func(0 str, 1 str) str","description":""},"sys.env":{"package":"sys","name":"env","signature":"func() map{str: str}","description":""},"sys.getenv":{"package":"sys","name":"getenv","signature":"func(0 str) str","description":""},"sys.hasenv":{"package":"sys","name":"hasenv","signature":"func(0 str) bool","description":""},"sys.hostname":{"package":"sys","name":"hostname","signature":"func() str","description":""},"sys.load":{"package":"sys","name":"load","signature":"func() struct{x1 float; x5 float; x15 float}","description":""},"sys.uptime":{"package":"sys","name":"uptime","signature":"func() int","description":""},"test.fastcount":{"package":"test","name":"fastcount","signature":"func() int","description":""},"test.one_instance_a":{"package":"test","name":"one_instance_a","signature":"func() str","description":""},"test.one_instance_b":{"package":"test","name":"one_instance_b","signature":"func() str","description":""},"test.one_instance_c":{"package":"test","name":"one_instance_c","signature":"func() str","description":""},"test.one_instance_d":{"package":"test","name":"one_instance_d","signature":"func() str","description":""},"test.one_instance_e":{"package":"test","name":"one_instance_e","signature":"func() str","description":""},"test.one_instance_f":{"package":"test","name":"one_instance_f","signature":"func() str","description":""},"test.one_instance_g":{"package":"test","name":"one_instance_g","signature":"func() str","description":""},"test.one_instance_h":{"package":"test","name":"one_instance_h","signature":"func() str","description":""},"util.hostname_mapper":{"package":"util","name":"hostname_mapper","signature":"func(0 map{str: str}) str","description":""},"value.get":{"package":"value","name":"get","description":""},"value.get_bool":{"package":"value","name":"get_bool","signature":"func(key str) struct{value bool; ready bool}","description":""},"value.get_float":{"package":"value","name":"get_float","signature":"func(key str) struct{value float; ready bool}","description":""},"value.get_int":{"package":"value","name":"get_int","signature":"func(key str) struct{value int; ready bool}","description":""},"value.get_str":{"package":"value","name":"get_str","signature":"func(key str) struct{value str; ready bool}","description":""},"world.exchange":{"package":"world","name":"exchange","signature":"func(namespace str, value str) map{str: str}","description":""},"world.getval":{"package":"world","name":"getval","signature":"func(key str) struct{value str; exists bool}","description":""},"world.kvlookup":{"package":"world","name":"kvlookup","signature":"func(namespace str) map{str: str}","description":""},"world.schedule":{"package":"world","name":"schedule","description":""}}}